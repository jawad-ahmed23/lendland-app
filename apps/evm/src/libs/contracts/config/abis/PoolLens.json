{
  "address": "0x8AEEE42cf218DDDEBFEaeC71350A5f6D1304989d",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolRegistryAddress",
          "type": "address"
        }
      ],
      "name": "getAllPools",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "comptroller",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "blockPosted",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestampPosted",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "category",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURL",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "priceOracle",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "closeFactor",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidationIncentive",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minLiquidatableCollateral",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "leToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "exchangeRateCurrent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRatePerBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRatePerBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "reserveFactorMantissa",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyCaps",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowCaps",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrows",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalCash",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isListed",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralFactorMantissa",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "underlyingAssetAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "leTokenDecimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "underlyingDecimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "pausedActions",
                  "type": "uint256"
                }
              ],
              "internalType": "struct PoolLens.LeTokenMetadata[]",
              "name": "leTokens",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PoolLens.PoolData[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolRegistryAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        }
      ],
      "name": "getLeTokenForAsset",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "comptrollerAddress",
          "type": "address"
        }
      ],
      "name": "getPendingRewards",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "distributorAddress",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "rewardTokenAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalRewards",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "leTokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "amount",
                  "type": "uint256"
                }
              ],
              "internalType": "struct PoolLens.PendingReward[]",
              "name": "pendingRewards",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PoolLens.RewardSummary[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "comptrollerAddress",
          "type": "address"
        }
      ],
      "name": "getPoolBadDebt",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "comptroller",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "totalBadDebtUsd",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "leTokenAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "badDebtUsd",
                  "type": "uint256"
                }
              ],
              "internalType": "struct PoolLens.BadDebt[]",
              "name": "badDebts",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PoolLens.BadDebtSummary",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolRegistryAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "comptroller",
          "type": "address"
        }
      ],
      "name": "getPoolByComptroller",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "comptroller",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "blockPosted",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestampPosted",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "category",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURL",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "priceOracle",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "closeFactor",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidationIncentive",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minLiquidatableCollateral",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "leToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "exchangeRateCurrent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRatePerBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRatePerBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "reserveFactorMantissa",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyCaps",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowCaps",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrows",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalCash",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isListed",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralFactorMantissa",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "underlyingAssetAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "leTokenDecimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "underlyingDecimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "pausedActions",
                  "type": "uint256"
                }
              ],
              "internalType": "struct PoolLens.LeTokenMetadata[]",
              "name": "leTokens",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PoolLens.PoolData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolRegistryAddress",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "comptroller",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "blockPosted",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestampPosted",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolRegistryInterface.LendLandPool",
          "name": "lendlandPool",
          "type": "tuple"
        }
      ],
      "name": "getPoolDataFromLendLandPool",
      "outputs": [
        {
          "components": [
            {
              "internalType": "string",
              "name": "name",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "creator",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "comptroller",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "blockPosted",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "timestampPosted",
              "type": "uint256"
            },
            {
              "internalType": "string",
              "name": "category",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "logoURL",
              "type": "string"
            },
            {
              "internalType": "string",
              "name": "description",
              "type": "string"
            },
            {
              "internalType": "address",
              "name": "priceOracle",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "closeFactor",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "liquidationIncentive",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "minLiquidatableCollateral",
              "type": "uint256"
            },
            {
              "components": [
                {
                  "internalType": "address",
                  "name": "leToken",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "exchangeRateCurrent",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyRatePerBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowRatePerBlock",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "reserveFactorMantissa",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "supplyCaps",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "borrowCaps",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalBorrows",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalReserves",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalSupply",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "totalCash",
                  "type": "uint256"
                },
                {
                  "internalType": "bool",
                  "name": "isListed",
                  "type": "bool"
                },
                {
                  "internalType": "uint256",
                  "name": "collateralFactorMantissa",
                  "type": "uint256"
                },
                {
                  "internalType": "address",
                  "name": "underlyingAssetAddress",
                  "type": "address"
                },
                {
                  "internalType": "uint256",
                  "name": "leTokenDecimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "underlyingDecimals",
                  "type": "uint256"
                },
                {
                  "internalType": "uint256",
                  "name": "pausedActions",
                  "type": "uint256"
                }
              ],
              "internalType": "struct PoolLens.LeTokenMetadata[]",
              "name": "leTokens",
              "type": "tuple[]"
            }
          ],
          "internalType": "struct PoolLens.PoolData",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolRegistryAddress",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        }
      ],
      "name": "getPoolsSupportedByAsset",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract LeToken",
          "name": "leToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "leTokenBalances",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "leToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "balanceOf",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowBalanceCurrent",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balanceOfUnderlying",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenAllowance",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolLens.LeTokenBalances",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract LeToken[]",
          "name": "leTokens",
          "type": "address[]"
        },
        {
          "internalType": "address",
          "name": "account",
          "type": "address"
        }
      ],
      "name": "leTokenBalancesAll",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "leToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "balanceOf",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowBalanceCurrent",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "balanceOfUnderlying",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenBalance",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "tokenAllowance",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolLens.LeTokenBalances[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract LeToken",
          "name": "leToken",
          "type": "address"
        }
      ],
      "name": "leTokenMetadata",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "leToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "exchangeRateCurrent",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyRatePerBlock",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowRatePerBlock",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "reserveFactorMantissa",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyCaps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowCaps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalBorrows",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalCash",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isListed",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "collateralFactorMantissa",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "underlyingAssetAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "leTokenDecimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "underlyingDecimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pausedActions",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolLens.LeTokenMetadata",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract LeToken[]",
          "name": "leTokens",
          "type": "address[]"
        }
      ],
      "name": "leTokenMetadataAll",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "leToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "exchangeRateCurrent",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyRatePerBlock",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowRatePerBlock",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "reserveFactorMantissa",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "supplyCaps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "borrowCaps",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalBorrows",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalReserves",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalSupply",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "totalCash",
              "type": "uint256"
            },
            {
              "internalType": "bool",
              "name": "isListed",
              "type": "bool"
            },
            {
              "internalType": "uint256",
              "name": "collateralFactorMantissa",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "underlyingAssetAddress",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "leTokenDecimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "underlyingDecimals",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "pausedActions",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolLens.LeTokenMetadata[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract LeToken",
          "name": "leToken",
          "type": "address"
        }
      ],
      "name": "leTokenUnderlyingPrice",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "leToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "underlyingPrice",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolLens.LeTokenUnderlyingPrice",
          "name": "",
          "type": "tuple"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract LeToken[]",
          "name": "leTokens",
          "type": "address[]"
        }
      ],
      "name": "leTokenUnderlyingPriceAll",
      "outputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "leToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "underlyingPrice",
              "type": "uint256"
            }
          ],
          "internalType": "struct PoolLens.LeTokenUnderlyingPrice[]",
          "name": "",
          "type": "tuple[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x1c98f72247797727bf61f1b13d20c5e9b2721707d25d6f7ea3cdd6492a8874e5",
  "receipt": {
    "to": null,
    "from": "0x48f9d844364095B1B0B9429A18ec9B4fA5c6Af41",
    "contractAddress": "0x8AEEE42cf218DDDEBFEaeC71350A5f6D1304989d",
    "transactionIndex": 1,
    "gasUsed": "3465573",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xf6444ffcb354b493d6d136ced04763196c779b6479d9cf171785d19c77fca547",
    "transactionHash": "0x1c98f72247797727bf61f1b13d20c5e9b2721707d25d6f7ea3cdd6492a8874e5",
    "logs": [],
    "blockNumber": 4010266,
    "cumulativeGasUsed": "3509412",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "47cdc25dab8d75d0890638c61746a4a2",
  "metadata": "{\"compiler\":{\"version\":\"0.8.13+commit.abaa5c0e\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolRegistryAddress\",\"type\":\"address\"}],\"name\":\"getAllPools\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockPosted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestampPosted\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"category\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logoURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"closeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidatableCollateral\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRateCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedActions\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenMetadata[]\",\"name\":\"leTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PoolLens.PoolData[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getLeTokenForAsset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptrollerAddress\",\"type\":\"address\"}],\"name\":\"getPendingRewards\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"distributorAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"rewardTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalRewards\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"leTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.PendingReward[]\",\"name\":\"pendingRewards\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PoolLens.RewardSummary[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"comptrollerAddress\",\"type\":\"address\"}],\"name\":\"getPoolBadDebt\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"totalBadDebtUsd\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"leTokenAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"badDebtUsd\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.BadDebt[]\",\"name\":\"badDebts\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PoolLens.BadDebtSummary\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"}],\"name\":\"getPoolByComptroller\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockPosted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestampPosted\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"category\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logoURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"closeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidatableCollateral\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRateCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedActions\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenMetadata[]\",\"name\":\"leTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PoolLens.PoolData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolRegistryAddress\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockPosted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestampPosted\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolRegistryInterface.LendLandPool\",\"name\":\"lendlandPool\",\"type\":\"tuple\"}],\"name\":\"getPoolDataFromLendLandPool\",\"outputs\":[{\"components\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"creator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"comptroller\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"blockPosted\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"timestampPosted\",\"type\":\"uint256\"},{\"internalType\":\"string\",\"name\":\"category\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"logoURL\",\"type\":\"string\"},{\"internalType\":\"string\",\"name\":\"description\",\"type\":\"string\"},{\"internalType\":\"address\",\"name\":\"priceOracle\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"closeFactor\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"liquidationIncentive\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minLiquidatableCollateral\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRateCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedActions\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenMetadata[]\",\"name\":\"leTokens\",\"type\":\"tuple[]\"}],\"internalType\":\"struct PoolLens.PoolData\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolRegistryAddress\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"}],\"name\":\"getPoolsSupportedByAsset\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LeToken\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"leTokenBalances\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balanceOf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalanceCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOfUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAllowance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenBalances\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LeToken[]\",\"name\":\"leTokens\",\"type\":\"address[]\"},{\"internalType\":\"address\",\"name\":\"account\",\"type\":\"address\"}],\"name\":\"leTokenBalancesAll\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"balanceOf\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowBalanceCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"balanceOfUnderlying\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenBalance\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"tokenAllowance\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenBalances[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LeToken\",\"name\":\"leToken\",\"type\":\"address\"}],\"name\":\"leTokenMetadata\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRateCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedActions\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenMetadata\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LeToken[]\",\"name\":\"leTokens\",\"type\":\"address[]\"}],\"name\":\"leTokenMetadataAll\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"exchangeRateCurrent\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowRatePerBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"reserveFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"supplyCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"borrowCaps\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalBorrows\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalReserves\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalSupply\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"totalCash\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"isListed\",\"type\":\"bool\"},{\"internalType\":\"uint256\",\"name\":\"collateralFactorMantissa\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"underlyingAssetAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"leTokenDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingDecimals\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"pausedActions\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenMetadata[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LeToken\",\"name\":\"leToken\",\"type\":\"address\"}],\"name\":\"leTokenUnderlyingPrice\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenUnderlyingPrice\",\"name\":\"\",\"type\":\"tuple\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract LeToken[]\",\"name\":\"leTokens\",\"type\":\"address[]\"}],\"name\":\"leTokenUnderlyingPriceAll\",\"outputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"leToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"underlyingPrice\",\"type\":\"uint256\"}],\"internalType\":\"struct PoolLens.LeTokenUnderlyingPrice[]\",\"name\":\"\",\"type\":\"tuple[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"LendLand\",\"kind\":\"dev\",\"methods\":{\"getAllPools(address)\":{\"details\":\"This function is not designed to be called in a transaction: it is too gas-intensive\",\"params\":{\"poolRegistryAddress\":\"The address of the PoolRegistry contract\"},\"returns\":{\"_0\":\"Arrays of all LendLand pools' data\"}},\"getLeTokenForAsset(address,address,address)\":{\"params\":{\"asset\":\"The underlyingAsset of LeToken\",\"comptroller\":\"The pool comptroller\",\"poolRegistryAddress\":\"The address of the PoolRegistry contract\"},\"returns\":{\"_0\":\"Address of the leToken\"}},\"getPendingRewards(address,address)\":{\"params\":{\"account\":\"The user account.\",\"comptrollerAddress\":\"address\"},\"returns\":{\"_0\":\"Pending rewards array\"}},\"getPoolBadDebt(address)\":{\"params\":{\"comptrollerAddress\":\"Address of the comptroller\"},\"returns\":{\"_0\":\"badDebtSummary A struct with comptroller address, total bad debut denominated in usd, and   a break down of bad debt by market\"}},\"getPoolByComptroller(address,address)\":{\"params\":{\"comptroller\":\"The Comptroller implementation address\",\"poolRegistryAddress\":\"The address of the PoolRegistry contract\"},\"returns\":{\"_0\":\"PoolData structure containing the details of the pool\"}},\"getPoolDataFromLendLandPool(address,(string,address,address,uint256,uint256))\":{\"params\":{\"lendlandPool\":\"The LendLandPool Object from PoolRegistry\",\"poolRegistryAddress\":\"Address of the PoolRegistry\"},\"returns\":{\"_0\":\"Enriched PoolData\"}},\"getPoolsSupportedByAsset(address,address)\":{\"params\":{\"asset\":\"The underlying asset of leToken\",\"poolRegistryAddress\":\"The address of the PoolRegistry contract\"},\"returns\":{\"_0\":\"A list of Comptroller contracts\"}},\"leTokenBalances(address,address)\":{\"params\":{\"account\":\"The user Account\",\"leToken\":\"leToken address\"},\"returns\":{\"_0\":\"A struct containing the balances data\"}},\"leTokenBalancesAll(address[],address)\":{\"params\":{\"account\":\"The user Account\",\"leTokens\":\"The list of leToken addresses\"},\"returns\":{\"_0\":\"A list of structs containing balances data\"}},\"leTokenMetadata(address)\":{\"params\":{\"leToken\":\"The address of leToken\"},\"returns\":{\"_0\":\"LeTokenMetadata struct\"}},\"leTokenMetadataAll(address[])\":{\"params\":{\"leTokens\":\"The list of leToken addresses\"},\"returns\":{\"_0\":\"An array of LeTokenMetadata structs\"}},\"leTokenUnderlyingPrice(address)\":{\"params\":{\"leToken\":\"leToken address\"},\"returns\":{\"_0\":\"The price data for each asset\"}},\"leTokenUnderlyingPriceAll(address[])\":{\"params\":{\"leTokens\":\"The list of leToken addresses\"},\"returns\":{\"_0\":\"An array containing the price data for each asset\"}}},\"title\":\"PoolLens\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAllPools(address)\":{\"notice\":\"Queries all pools with addtional details for each of them\"},\"getLeTokenForAsset(address,address,address)\":{\"notice\":\"Returns leToken holding the specified underlying asset in the specified pool\"},\"getPendingRewards(address,address)\":{\"notice\":\"Returns the pending rewards for a user for a given pool.\"},\"getPoolBadDebt(address)\":{\"notice\":\"Returns a summary of a pool's bad debt broken down by market\"},\"getPoolByComptroller(address,address)\":{\"notice\":\"Queries the details of a pool identified by Comptroller address\"},\"getPoolDataFromLendLandPool(address,(string,address,address,uint256,uint256))\":{\"notice\":\"Queries additional information for the pool\"},\"getPoolsSupportedByAsset(address,address)\":{\"notice\":\"Returns all pools that support the specified underlying asset\"},\"leTokenBalances(address,address)\":{\"notice\":\"Queries the user's supply/borrow balances in the specified leToken\"},\"leTokenBalancesAll(address[],address)\":{\"notice\":\"Queries the user's supply/borrow balances in leTokens\"},\"leTokenMetadata(address)\":{\"notice\":\"Returns the metadata of LeToken\"},\"leTokenMetadataAll(address[])\":{\"notice\":\"Returns the metadata of all LeTokens\"},\"leTokenUnderlyingPrice(address)\":{\"notice\":\"Returns the price data for the underlying asset of the specified leToken\"},\"leTokenUnderlyingPriceAll(address[])\":{\"notice\":\"Returns the price data for the underlying assets of the specified leTokens\"}},\"notice\":\"The `PoolLens` contract is designed to retrieve important information for each registered pool. A list of essential information for all pools within the lending protocol can be acquired through the function `getAllPools()`. Additionally, the following records can be looked up for specific pools and markets: - the leToken balance of a given user; - the pool data (oracle address, associated leToken, liquidation incentive, etc) of a pool via its associated comptroller address; - the leToken address in a pool for a given asset; - a list of all pools that support an asset; - the underlying asset price of a leToken; - the metadata (exchange/borrow/supply rate, total supply, collateral factor, etc) of any leToken.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/Lens/PoolLens.sol\":\"PoolLens\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"./OwnableUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership} and {acceptOwnership}.\\n *\\n * This module is used through inheritance. It will make available all functions\\n * from parent (Ownable).\\n */\\nabstract contract Ownable2StepUpgradeable is Initializable, OwnableUpgradeable {\\n    address private _pendingOwner;\\n\\n    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);\\n\\n    function __Ownable2Step_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable2Step_init_unchained() internal onlyInitializing {\\n    }\\n    /**\\n     * @dev Returns the address of the pending owner.\\n     */\\n    function pendingOwner() public view virtual returns (address) {\\n        return _pendingOwner;\\n    }\\n\\n    /**\\n     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual override onlyOwner {\\n        _pendingOwner = newOwner;\\n        emit OwnershipTransferStarted(owner(), newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual override {\\n        delete _pendingOwner;\\n        super._transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev The new owner accepts the ownership transfer.\\n     */\\n    function acceptOwnership() public virtual {\\n        address sender = _msgSender();\\n        require(pendingOwner() == sender, \\\"Ownable2Step: caller is not the new owner\\\");\\n        _transferOwnership(sender);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x9140dabc466abab21b48b72dbda26736b1183a310d0e677d3719d201df026510\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../utils/ContextUpgradeable.sol\\\";\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Contract module which provides a basic access control mechanism, where\\n * there is an account (an owner) that can be granted exclusive access to\\n * specific functions.\\n *\\n * By default, the owner account will be the one that deploys the contract. This\\n * can later be changed with {transferOwnership}.\\n *\\n * This module is used through inheritance. It will make available the modifier\\n * `onlyOwner`, which can be applied to your functions to restrict their use to\\n * the owner.\\n */\\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\\n    address private _owner;\\n\\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\\n\\n    /**\\n     * @dev Initializes the contract setting the deployer as the initial owner.\\n     */\\n    function __Ownable_init() internal onlyInitializing {\\n        __Ownable_init_unchained();\\n    }\\n\\n    function __Ownable_init_unchained() internal onlyInitializing {\\n        _transferOwnership(_msgSender());\\n    }\\n\\n    /**\\n     * @dev Throws if called by any account other than the owner.\\n     */\\n    modifier onlyOwner() {\\n        _checkOwner();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns the address of the current owner.\\n     */\\n    function owner() public view virtual returns (address) {\\n        return _owner;\\n    }\\n\\n    /**\\n     * @dev Throws if the sender is not the owner.\\n     */\\n    function _checkOwner() internal view virtual {\\n        require(owner() == _msgSender(), \\\"Ownable: caller is not the owner\\\");\\n    }\\n\\n    /**\\n     * @dev Leaves the contract without owner. It will not be possible to call\\n     * `onlyOwner` functions. Can only be called by the current owner.\\n     *\\n     * NOTE: Renouncing ownership will leave the contract without an owner,\\n     * thereby disabling any functionality that is only available to the owner.\\n     */\\n    function renounceOwnership() public virtual onlyOwner {\\n        _transferOwnership(address(0));\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Can only be called by the current owner.\\n     */\\n    function transferOwnership(address newOwner) public virtual onlyOwner {\\n        require(newOwner != address(0), \\\"Ownable: new owner is the zero address\\\");\\n        _transferOwnership(newOwner);\\n    }\\n\\n    /**\\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\\n     * Internal function without access restriction.\\n     */\\n    function _transferOwnership(address newOwner) internal virtual {\\n        address oldOwner = _owner;\\n        _owner = newOwner;\\n        emit OwnershipTransferred(oldOwner, newOwner);\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[49] private __gap;\\n}\\n\",\"keccak256\":\"0x359a1ab89b46b9aba7bcad3fb651924baf4893d15153049b9976b0fc9be1358e\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.2;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```solidity\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n *\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n    uint8 private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n    event Initialized(uint8 version);\\n\\n    /**\\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier initializer() {\\n        bool isTopLevelCall = !_initializing;\\n        require(\\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\\n            \\\"Initializable: contract is already initialized\\\"\\n        );\\n        _initialized = 1;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n        }\\n        _;\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n            emit Initialized(1);\\n        }\\n    }\\n\\n    /**\\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n    modifier reinitializer(uint8 version) {\\n        require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n        _initialized = version;\\n        _initializing = true;\\n        _;\\n        _initializing = false;\\n        emit Initialized(version);\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    /**\\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n    function _disableInitializers() internal virtual {\\n        require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n        if (_initialized != type(uint8).max) {\\n            _initialized = type(uint8).max;\\n            emit Initialized(type(uint8).max);\\n        }\\n    }\\n\\n    /**\\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n    function _getInitializedVersion() internal view returns (uint8) {\\n        return _initialized;\\n    }\\n\\n    /**\\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n    function _isInitializing() internal view returns (bool) {\\n        return _initializing;\\n    }\\n}\\n\",\"keccak256\":\"0x89be10e757d242e9b18d5a32c9fbe2019f6d63052bbe46397a430a1d60d7f794\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20Upgradeable {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x0e1f0f5f62f67a881cd1a9597acbc0a5e4071f3c2c10449a183b922ae7272e3f\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20PermitUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20PermitUpgradeable {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x07e881de3b9f6d2c07909f193f24b96c7fe4ea60013260f3f25aecd8bab3c2f8\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20Upgradeable.sol\\\";\\nimport \\\"../extensions/IERC20PermitUpgradeable.sol\\\";\\nimport \\\"../../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20Upgradeable {\\n    using AddressUpgradeable for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20Upgradeable token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20Upgradeable token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20Upgradeable token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20PermitUpgradeable token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20Upgradeable token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20Upgradeable token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && AddressUpgradeable.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0x23b997be73d3dd46885262704f0f8cfc7273fdadfe303d37969a9561373972b5\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9c80f545915582e63fe206c6ce27cbe85a86fc10b9cd2a0e8c9488fb7c2ee422\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)\\n\\npragma solidity ^0.8.0;\\nimport {Initializable} from \\\"../proxy/utils/Initializable.sol\\\";\\n\\n/**\\n * @dev Provides information about the current execution context, including the\\n * sender of the transaction and its data. While these are generally available\\n * via msg.sender and msg.data, they should not be accessed in such a direct\\n * manner, since when dealing with meta-transactions the account sending and\\n * paying for execution may not be the actual sender (as far as an application\\n * is concerned).\\n *\\n * This contract is only required for intermediate, library-like contracts.\\n */\\nabstract contract ContextUpgradeable is Initializable {\\n    function __Context_init() internal onlyInitializing {\\n    }\\n\\n    function __Context_init_unchained() internal onlyInitializing {\\n    }\\n    function _msgSender() internal view virtual returns (address) {\\n        return msg.sender;\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        return msg.data;\\n    }\\n\\n    function _contextSuffixLength() internal view virtual returns (uint256) {\\n        return 0;\\n    }\\n\\n    /**\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\n     * variables without shifting down storage in the inheritance chain.\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n     */\\n    uint256[50] private __gap;\\n}\\n\",\"keccak256\":\"0x75097e35253e7fb282ee4d7f27a80eaacfa759923185bf17302a89cbc059c5ef\",\"license\":\"MIT\"},\"@openzeppelin/contracts/access/IAccessControl.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev External interface of AccessControl declared to support ERC165 detection.\\n */\\ninterface IAccessControl {\\n    /**\\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\\n     *\\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\\n     * {RoleAdminChanged} not being emitted signaling this.\\n     *\\n     * _Available since v3.1._\\n     */\\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\\n\\n    /**\\n     * @dev Emitted when `account` is granted `role`.\\n     *\\n     * `sender` is the account that originated the contract call, an admin role\\n     * bearer except when using {AccessControl-_setupRole}.\\n     */\\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Emitted when `account` is revoked `role`.\\n     *\\n     * `sender` is the account that originated the contract call:\\n     *   - if using `revokeRole`, it is the admin role bearer\\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\\n     */\\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\\n\\n    /**\\n     * @dev Returns `true` if `account` has been granted `role`.\\n     */\\n    function hasRole(bytes32 role, address account) external view returns (bool);\\n\\n    /**\\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\\n     * {revokeRole}.\\n     *\\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\\n     */\\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\\n\\n    /**\\n     * @dev Grants `role` to `account`.\\n     *\\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function grantRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from `account`.\\n     *\\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must have ``role``'s admin role.\\n     */\\n    function revokeRole(bytes32 role, address account) external;\\n\\n    /**\\n     * @dev Revokes `role` from the calling account.\\n     *\\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\\n     * purpose is to provide a mechanism for accounts to lose their privileges\\n     * if they are compromised (such as when a trusted device is misplaced).\\n     *\\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\\n     * event.\\n     *\\n     * Requirements:\\n     *\\n     * - the caller must be `account`.\\n     */\\n    function renounceRole(bytes32 role, address account) external;\\n}\\n\",\"keccak256\":\"0x59ce320a585d7e1f163cd70390a0ef2ff9cec832e2aa544293a00692465a7a57\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\n\\n/**\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n    /**\\n     * @dev Returns the name of the token.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the symbol of the token.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the decimals places of the token.\\n     */\\n    function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x8de418a5503946cabe331f35fe242d3201a73f67f77aaeb7110acb1f30423aca\",\"license\":\"MIT\"},\"contracts/Comptroller.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport {Ownable2StepUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\n\\r\\nimport {IPrime} from \\\"./access-controll/IPrime.sol\\\";\\r\\nimport {AccessControlledV8} from \\\"./access-controll/AccessControlledV8.sol\\\";\\r\\nimport {ResilientOracleInterface} from \\\"./access-controll/interfaces/OracleInterface.sol\\\";\\r\\n\\r\\nimport {ComptrollerInterface, Action} from \\\"./ComptrollerInterface.sol\\\";\\r\\nimport {ComptrollerStorage} from \\\"./ComptrollerStorage.sol\\\";\\r\\nimport {ExponentialNoError} from \\\"./ExponentialNoError.sol\\\";\\r\\nimport {LeToken} from \\\"./LeToken.sol\\\";\\r\\nimport {RewardsDistributor} from \\\"./Rewards/RewardsDistributor.sol\\\";\\r\\nimport {MaxLoopsLimitHelper} from \\\"./MaxLoopsLimitHelper.sol\\\";\\r\\nimport {ensureNonzeroAddress} from \\\"./lib/validators.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Comptroller\\r\\n * @author LendLand\\r\\n * @notice The Comptroller is designed to provide checks for all minting, redeeming, transferring, borrowing, lending, repaying, liquidating,\\r\\n * and seizing done by the `leToken` contract. Each pool has one `Comptroller` checking these interactions across markets. When a user interacts\\r\\n * with a given market by one of these main actions, a call is made to a corresponding hook in the associated `Comptroller`, which either allows\\r\\n * or reverts the transaction. These hooks also update supply and borrow rewards as they are called. The comptroller holds the logic for assessing\\r\\n * liquidity snapshots of an account via the collateral factor and liquidation threshold. This check determines the collateral needed for a borrow,\\r\\n * as well as how much of a borrow may be liquidated. A user may borrow a portion of their collateral with the maximum amount determined by the\\r\\n * markets collateral factor. However, if their borrowed amount exceeds an amount calculated using the market\\u2019s corresponding liquidation threshold,\\r\\n * the borrow is eligible for liquidation.\\r\\n *\\r\\n * The `Comptroller` also includes two functions `liquidateAccount()` and `healAccount()`, which are meant to handle accounts that do not exceed\\r\\n * the `minLiquidatableCollateral` for the `Comptroller`:\\r\\n *\\r\\n * - `healAccount()`: This function is called to seize all of a given user\\u2019s collateral, requiring the `msg.sender` repay a certain percentage\\r\\n * of the debt calculated by `collateral/(borrows*liquidationIncentive)`. The function can only be called if the calculated percentage does not exceed\\r\\n * 100%, because otherwise no `badDebt` would be created and `liquidateAccount()` should be used instead. The difference in the actual amount of debt\\r\\n * and debt paid off is recorded as `badDebt` for each market, which can then be auctioned off for the risk reserves of the associated pool.\\r\\n * - `liquidateAccount()`: This function can only be called if the collateral seized will cover all borrows of an account, as well as the liquidation\\r\\n * incentive. Otherwise, the pool will incur bad debt, in which case the function `healAccount()` should be used instead. This function skips the logic\\r\\n * verifying that the repay amount does not exceed the close factor.\\r\\n */\\r\\ncontract Comptroller is\\r\\n    Ownable2StepUpgradeable,\\r\\n    AccessControlledV8,\\r\\n    ComptrollerStorage,\\r\\n    ComptrollerInterface,\\r\\n    ExponentialNoError,\\r\\n    MaxLoopsLimitHelper\\r\\n{\\r\\n    // PoolRegistry, immutable to save on gas\\r\\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable\\r\\n    address public immutable poolRegistry;\\r\\n\\r\\n    /// @notice Emitted when an account enters a market\\r\\n    event MarketEntered(LeToken indexed leToken, address indexed account);\\r\\n\\r\\n    /// @notice Emitted when an account exits a market\\r\\n    event MarketExited(LeToken indexed leToken, address indexed account);\\r\\n\\r\\n    /// @notice Emitted when close factor is changed by admin\\r\\n    event NewCloseFactor(\\r\\n        uint256 oldCloseFactorMantissa,\\r\\n        uint256 newCloseFactorMantissa\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when a collateral factor is changed by admin\\r\\n    event NewCollateralFactor(\\r\\n        LeToken leToken,\\r\\n        uint256 oldCollateralFactorMantissa,\\r\\n        uint256 newCollateralFactorMantissa\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when liquidation threshold is changed by admin\\r\\n    event NewLiquidationThreshold(\\r\\n        LeToken leToken,\\r\\n        uint256 oldLiquidationThresholdMantissa,\\r\\n        uint256 newLiquidationThresholdMantissa\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when liquidation incentive is changed by admin\\r\\n    event NewLiquidationIncentive(\\r\\n        uint256 oldLiquidationIncentiveMantissa,\\r\\n        uint256 newLiquidationIncentiveMantissa\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when price oracle is changed\\r\\n    event NewPriceOracle(\\r\\n        ResilientOracleInterface oldPriceOracle,\\r\\n        ResilientOracleInterface newPriceOracle\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when an action is paused on a market\\r\\n    event ActionPausedMarket(LeToken leToken, Action action, bool pauseState);\\r\\n\\r\\n    /// @notice Emitted when borrow cap for a leToken is changed\\r\\n    event NewBorrowCap(LeToken indexed leToken, uint256 newBorrowCap);\\r\\n\\r\\n    /// @notice Emitted when the collateral threshold (in USD) for non-batch liquidations is changed\\r\\n    event NewMinLiquidatableCollateral(\\r\\n        uint256 oldMinLiquidatableCollateral,\\r\\n        uint256 newMinLiquidatableCollateral\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when supply cap for a leToken is changed\\r\\n    event NewSupplyCap(LeToken indexed leToken, uint256 newSupplyCap);\\r\\n\\r\\n    /// @notice Emitted when a rewards distributor is added\\r\\n    event NewRewardsDistributor(\\r\\n        address indexed rewardsDistributor,\\r\\n        address indexed rewardToken\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when a market is supported\\r\\n    event MarketSupported(LeToken leToken);\\r\\n\\r\\n    /// @notice Emitted when prime token contract address is changed\\r\\n    event NewPrimeToken(IPrime oldPrimeToken, IPrime newPrimeToken);\\r\\n\\r\\n    /// @notice Emitted when forced liquidation is enabled or disabled for a market\\r\\n    event IsForcedLiquidationEnabledUpdated(\\r\\n        address indexed leToken,\\r\\n        bool enable\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when the borrowing or redeeming delegate rights are updated for an account\\r\\n    event DelegateUpdated(\\r\\n        address indexed approver,\\r\\n        address indexed delegate,\\r\\n        bool approved\\r\\n    );\\r\\n\\r\\n    /// @notice Thrown when collateral factor exceeds the upper bound\\r\\n    error InvalidCollateralFactor();\\r\\n\\r\\n    /// @notice Thrown when liquidation threshold exceeds the collateral factor\\r\\n    error InvalidLiquidationThreshold();\\r\\n\\r\\n    /// @notice Thrown when the action is only available to specific sender, but the real sender was different\\r\\n    error UnexpectedSender(address expectedSender, address actualSender);\\r\\n\\r\\n    /// @notice Thrown when the oracle returns an invalid price for some asset\\r\\n    error PriceError(address leToken);\\r\\n\\r\\n    /// @notice Thrown if LeToken unexpectedly returned a nonzero error code while trying to get account snapshot\\r\\n    error SnapshotError(address leToken, address user);\\r\\n\\r\\n    /// @notice Thrown when the market is not listed\\r\\n    error MarketNotListed(address market);\\r\\n\\r\\n    /// @notice Thrown when a market has an unexpected comptroller\\r\\n    error ComptrollerMismatch();\\r\\n\\r\\n    /// @notice Thrown when user is not member of market\\r\\n    error MarketNotCollateral(address leToken, address user);\\r\\n\\r\\n    /**\\r\\n     * @notice Thrown during the liquidation if user's total collateral amount is lower than\\r\\n     *   a predefined threshold. In this case only batch liquidations (either liquidateAccount\\r\\n     *   or healAccount) are available.\\r\\n     */\\r\\n    error MinimalCollateralViolated(\\r\\n        uint256 expectedGreaterThan,\\r\\n        uint256 actual\\r\\n    );\\r\\n    error CollateralExceedsThreshold(\\r\\n        uint256 expectedLessThanOrEqualTo,\\r\\n        uint256 actual\\r\\n    );\\r\\n    error InsufficientCollateral(\\r\\n        uint256 collateralToSeize,\\r\\n        uint256 availableCollateral\\r\\n    );\\r\\n\\r\\n    /// @notice Thrown when the account doesn't have enough liquidity to redeem or borrow\\r\\n    error InsufficientLiquidity();\\r\\n\\r\\n    /// @notice Thrown when trying to liquidate a healthy account\\r\\n    error InsufficientShortfall();\\r\\n\\r\\n    /// @notice Thrown when trying to repay more than allowed by close factor\\r\\n    error TooMuchRepay();\\r\\n\\r\\n    /// @notice Thrown if the user is trying to exit a market in which they have an outstanding debt\\r\\n    error NonzeroBorrowBalance();\\r\\n\\r\\n    /// @notice Thrown when trying to perform an action that is paused\\r\\n    error ActionPaused(address market, Action action);\\r\\n\\r\\n    /// @notice Thrown when trying to add a market that is already listed\\r\\n    error MarketAlreadyListed(address market);\\r\\n\\r\\n    /// @notice Thrown if the supply cap is exceeded\\r\\n    error SupplyCapExceeded(address market, uint256 cap);\\r\\n\\r\\n    /// @notice Thrown if the borrow cap is exceeded\\r\\n    error BorrowCapExceeded(address market, uint256 cap);\\r\\n\\r\\n    /// @notice Thrown if delegate approval status is already set to the requested value\\r\\n    error DelegationStatusUnchanged();\\r\\n\\r\\n    /// @param poolRegistry_ Pool registry address\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    /// @custom:error ZeroAddressNotAllowed is thrown when pool registry address is zero\\r\\n    constructor(address poolRegistry_) {\\r\\n        ensureNonzeroAddress(poolRegistry_);\\r\\n\\r\\n        poolRegistry = poolRegistry_;\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param loopLimit Limit for the loops can iterate to avoid the DOS\\r\\n     * @param accessControlManager Access control manager contract address\\r\\n     */\\r\\n    function initialize(\\r\\n        uint256 loopLimit,\\r\\n        address accessControlManager\\r\\n    ) external initializer {\\r\\n        __Ownable2Step_init();\\r\\n        __AccessControlled_init_unchained(accessControlManager);\\r\\n\\r\\n        _setMaxLoopsLimit(loopLimit);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add assets to be included in account liquidity calculation; enabling them to be used as collateral\\r\\n     * @param leTokens The list of addresses of the leToken markets to be enabled\\r\\n     * @return errors An array of NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event MarketEntered is emitted for each market on success\\r\\n     * @custom:error ActionPaused error is thrown if entering any of the markets is paused\\r\\n     * @custom:error MarketNotListed error is thrown if any of the markets is not listed\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function enterMarkets(\\r\\n        address[] memory leTokens\\r\\n    ) external override returns (uint256[] memory) {\\r\\n        uint256 len = leTokens.length;\\r\\n\\r\\n        uint256[] memory results = new uint256[](len);\\r\\n        for (uint256 i; i < len; ++i) {\\r\\n            LeToken leToken = LeToken(leTokens[i]);\\r\\n\\r\\n            _addToMarket(leToken, msg.sender);\\r\\n            results[i] = NO_ERROR;\\r\\n        }\\r\\n\\r\\n        return results;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Grants or revokes the borrowing or redeeming delegate rights to / from an account\\r\\n     *  If allowed, the delegate will be able to borrow funds on behalf of the sender\\r\\n     *  Upon a delegated borrow, the delegate will receive the funds, and the borrower\\r\\n     *  will see the debt on their account\\r\\n     *  Upon a delegated redeem, the delegate will receive the redeemed amount and the approver\\r\\n     *  will see a deduction in his leToken balance\\r\\n     * @param delegate The address to update the rights for\\r\\n     * @param approved Whether to grant (true) or revoke (false) the borrowing or redeeming rights\\r\\n     * @custom:event DelegateUpdated emits on success\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when delegate address is zero\\r\\n     * @custom:error DelegationStatusUnchanged is thrown if approval status is already set to the requested value\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function updateDelegate(address delegate, bool approved) external {\\r\\n        ensureNonzeroAddress(delegate);\\r\\n        if (approvedDelegates[msg.sender][delegate] == approved) {\\r\\n            revert DelegationStatusUnchanged();\\r\\n        }\\r\\n\\r\\n        approvedDelegates[msg.sender][delegate] = approved;\\r\\n        emit DelegateUpdated(msg.sender, delegate, approved);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Removes asset from sender's account liquidity calculation; disabling them as collateral\\r\\n     * @dev Sender must not have an outstanding borrow balance in the asset,\\r\\n     *  or be providing necessary collateral for an outstanding borrow.\\r\\n     * @param leTokenAddress The address of the asset to be removed\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event MarketExited is emitted on success\\r\\n     * @custom:error ActionPaused error is thrown if exiting the market is paused\\r\\n     * @custom:error NonzeroBorrowBalance error is thrown if the user has an outstanding borrow in this market\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:error InsufficientLiquidity error is thrown if exiting the market would lead to user's insolvency\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function exitMarket(\\r\\n        address leTokenAddress,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override returns (uint256) {\\r\\n        _checkActionPauseState(leTokenAddress, Action.EXIT_MARKET);\\r\\n        LeToken leToken = LeToken(leTokenAddress);\\r\\n        /* Get sender tokensHeld and amountOwed underlying from the leToken */\\r\\n        (uint256 tokensHeld, uint256 amountOwed, ) = _safeGetAccountSnapshot(\\r\\n            leToken,\\r\\n            msg.sender\\r\\n        );\\r\\n\\r\\n        /* Fail if the sender has a borrow balance */\\r\\n        if (amountOwed != 0) {\\r\\n            revert NonzeroBorrowBalance();\\r\\n        }\\r\\n\\r\\n        /* Fail if the sender is not permitted to redeem all of their tokens */\\r\\n        _checkRedeemAllowed(\\r\\n            leTokenAddress,\\r\\n            msg.sender,\\r\\n            tokensHeld,\\r\\n            priceUpdateData\\r\\n        );\\r\\n\\r\\n        Market storage marketToExit = markets[address(leToken)];\\r\\n\\r\\n        /* Return true if the sender is not already \\u2018in\\u2019 the market */\\r\\n        if (!marketToExit.accountMembership[msg.sender]) {\\r\\n            return NO_ERROR;\\r\\n        }\\r\\n\\r\\n        /* Set leToken account membership to false */\\r\\n        delete marketToExit.accountMembership[msg.sender];\\r\\n\\r\\n        /* Delete leToken from the account\\u2019s list of assets */\\r\\n        // load into memory for faster iteration\\r\\n        LeToken[] memory userAssetList = accountAssets[msg.sender];\\r\\n        uint256 len = userAssetList.length;\\r\\n\\r\\n        uint256 assetIndex = len;\\r\\n        for (uint256 i; i < len; ++i) {\\r\\n            if (userAssetList[i] == leToken) {\\r\\n                assetIndex = i;\\r\\n                break;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // We *must* have found the asset in the list or our redundant data structure is broken\\r\\n        assert(assetIndex < len);\\r\\n\\r\\n        // copy last item in list to location of item to be removed, reduce length by 1\\r\\n        LeToken[] storage storedList = accountAssets[msg.sender];\\r\\n        storedList[assetIndex] = storedList[storedList.length - 1];\\r\\n        storedList.pop();\\r\\n\\r\\n        emit MarketExited(leToken, msg.sender);\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to mint tokens in the given market\\r\\n     * @param leToken The market to verify the mint against\\r\\n     * @param minter The account which would get the minted tokens\\r\\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\\r\\n     * @custom:error ActionPaused error is thrown if supplying to this market is paused\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:error SupplyCapExceeded error is thrown if the total supply exceeds the cap after minting\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function preMintHook(\\r\\n        address leToken,\\r\\n        address minter,\\r\\n        uint256 mintAmount\\r\\n    ) external override {\\r\\n        _checkActionPauseState(leToken, Action.MINT);\\r\\n\\r\\n        if (!markets[leToken].isListed) {\\r\\n            revert MarketNotListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        uint256 supplyCap = supplyCaps[leToken];\\r\\n        // Skipping the cap check for uncapped coins to save some gas\\r\\n        if (supplyCap != type(uint256).max) {\\r\\n            uint256 leTokenSupply = LeToken(leToken).totalSupply();\\r\\n            Exp memory exchangeRate = Exp({\\r\\n                mantissa: LeToken(leToken).exchangeRateStored()\\r\\n            });\\r\\n            uint256 nextTotalSupply = mul_ScalarTruncateAddUInt(\\r\\n                exchangeRate,\\r\\n                leTokenSupply,\\r\\n                mintAmount\\r\\n            );\\r\\n            if (nextTotalSupply > supplyCap) {\\r\\n                revert SupplyCapExceeded(leToken, supplyCap);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            rewardsDistributor.updateRewardTokenSupplyIndex(leToken);\\r\\n            rewardsDistributor.distributeSupplierRewardToken(leToken, minter);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates mint, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leToken Asset being minted\\r\\n     * @param minter The address minting the tokens\\r\\n     * @param actualMintAmount The amount of the underlying asset being minted\\r\\n     * @param mintTokens The number of tokens being minted\\r\\n     */\\r\\n    // solhint-disable-next-line no-unused-vars\\r\\n    function mintVerify(\\r\\n        address leToken,\\r\\n        address minter,\\r\\n        uint256 actualMintAmount,\\r\\n        uint256 mintTokens\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(minter, leToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to redeem tokens in the given market\\r\\n     * @param leToken The market to verify the redeem against\\r\\n     * @param redeemer The account which would redeem the tokens\\r\\n     * @param redeemTokens The number of leTokens to exchange for the underlying asset in the market\\r\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function preRedeemHook(\\r\\n        address leToken,\\r\\n        address redeemer,\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override {\\r\\n        _checkActionPauseState(leToken, Action.REDEEM);\\r\\n\\r\\n        _checkRedeemAllowed(leToken, redeemer, redeemTokens, priceUpdateData);\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            rewardsDistributor.updateRewardTokenSupplyIndex(leToken);\\r\\n            rewardsDistributor.distributeSupplierRewardToken(leToken, redeemer);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates redeem, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leToken Asset being redeemed\\r\\n     * @param redeemer The address redeeming the tokens\\r\\n     * @param redeemAmount The amount of the underlying asset being redeemed\\r\\n     * @param redeemTokens The number of tokens being redeemed\\r\\n     */\\r\\n    function redeemVerify(\\r\\n        address leToken,\\r\\n        address redeemer,\\r\\n        uint256 redeemAmount,\\r\\n        uint256 redeemTokens\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(redeemer, leToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates repayBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leToken Asset being repaid\\r\\n     * @param payer The address repaying the borrow\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param actualRepayAmount The amount of underlying being repaid\\r\\n     */\\r\\n    function repayBorrowVerify(\\r\\n        address leToken,\\r\\n        address payer, // solhint-disable-line no-unused-vars\\r\\n        address borrower,\\r\\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\\r\\n        uint256 borrowerIndex // solhint-disable-line no-unused-vars\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(borrower, leToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates liquidateBorrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param leTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param actualRepayAmount The amount of underlying being repaid\\r\\n     * @param seizeTokens The amount of collateral token that will be seized\\r\\n     */\\r\\n    function liquidateBorrowVerify(\\r\\n        address leTokenBorrowed,\\r\\n        address leTokenCollateral, // solhint-disable-line no-unused-vars\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 actualRepayAmount, // solhint-disable-line no-unused-vars\\r\\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(borrower, leTokenBorrowed);\\r\\n            prime.accrueInterestAndUpdateScore(liquidator, leTokenBorrowed);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates seize, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param leTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param seizeTokens The number of collateral tokens to seize\\r\\n     */\\r\\n    function seizeVerify(\\r\\n        address leTokenCollateral,\\r\\n        address leTokenBorrowed, // solhint-disable-line no-unused-vars\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 seizeTokens // solhint-disable-line no-unused-vars\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(borrower, leTokenCollateral);\\r\\n            prime.accrueInterestAndUpdateScore(liquidator, leTokenCollateral);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates transfer, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leToken Asset being transferred\\r\\n     * @param src The account which sources the tokens\\r\\n     * @param dst The account which receives the tokens\\r\\n     * @param transferTokens The number of leTokens to transfer\\r\\n     */\\r\\n    // solhint-disable-next-line no-unused-vars\\r\\n    function transferVerify(\\r\\n        address leToken,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 transferTokens\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(src, leToken);\\r\\n            prime.accrueInterestAndUpdateScore(dst, leToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\\r\\n     * @param leToken The market to verify the borrow against\\r\\n     * @param borrower The account which would borrow the asset\\r\\n     * @param borrowAmount The amount of underlying the account would borrow\\r\\n     * @custom:error ActionPaused error is thrown if borrowing is paused in this market\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:error InsufficientLiquidity error is thrown if there is not enough collateral to borrow\\r\\n     * @custom:error BorrowCapExceeded is thrown if the borrow cap will be exceeded should this borrow succeed\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     * @custom:access Not restricted if leToken is enabled as collateral, otherwise only leToken\\r\\n     */\\r\\n    /// disable-eslint\\r\\n    function preBorrowHook(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override {\\r\\n        _checkActionPauseState(leToken, Action.BORROW);\\r\\n\\r\\n        if (!markets[leToken].isListed) {\\r\\n            revert MarketNotListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        if (!markets[leToken].accountMembership[borrower]) {\\r\\n            // only leTokens may call borrowAllowed if borrower not in market\\r\\n            _checkSenderIs(leToken);\\r\\n\\r\\n            // attempt to add borrower to the market or revert\\r\\n            _addToMarket(LeToken(msg.sender), borrower);\\r\\n        }\\r\\n\\r\\n        // Update the prices of tokens\\r\\n        updatePrices(borrower, priceUpdateData);\\r\\n\\r\\n        if (oracle.getUnderlyingPrice(leToken) == 0) {\\r\\n            revert PriceError(address(leToken));\\r\\n        }\\r\\n\\r\\n        uint256 borrowCap = borrowCaps[leToken];\\r\\n        // Skipping the cap check for uncapped coins to save some gas\\r\\n        if (borrowCap != type(uint256).max) {\\r\\n            uint256 totalBorrows = LeToken(leToken).totalBorrows();\\r\\n            uint256 badDebt = LeToken(leToken).badDebt();\\r\\n            uint256 nextTotalBorrows = totalBorrows + borrowAmount + badDebt;\\r\\n            if (nextTotalBorrows > borrowCap) {\\r\\n                revert BorrowCapExceeded(leToken, borrowCap);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        AccountLiquiditySnapshot\\r\\n            memory snapshot = _getHypotheticalLiquiditySnapshot(\\r\\n                borrower,\\r\\n                LeToken(leToken),\\r\\n                0,\\r\\n                borrowAmount,\\r\\n                _getCollateralFactor\\r\\n            );\\r\\n\\r\\n        if (snapshot.shortfall > 0) {\\r\\n            revert InsufficientLiquidity();\\r\\n        }\\r\\n\\r\\n        Exp memory borrowIndex = Exp({\\r\\n            mantissa: LeToken(leToken).borrowIndex()\\r\\n        });\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            rewardsDistributor.updateRewardTokenBorrowIndex(\\r\\n                leToken,\\r\\n                borrowIndex\\r\\n            );\\r\\n            rewardsDistributor.distributeBorrowerRewardToken(\\r\\n                leToken,\\r\\n                borrower,\\r\\n                borrowIndex\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Validates borrow, accrues interest and updates score in prime. Reverts on rejection. May emit logs.\\r\\n     * @param leToken Asset whose underlying is being borrowed\\r\\n     * @param borrower The address borrowing the underlying\\r\\n     * @param borrowAmount The amount of the underlying asset requested to borrow\\r\\n     */\\r\\n    // solhint-disable-next-line no-unused-vars\\r\\n    function borrowVerify(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        uint256 borrowAmount\\r\\n    ) external {\\r\\n        if (address(prime) != address(0)) {\\r\\n            prime.accrueInterestAndUpdateScore(borrower, leToken);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to repay a borrow in the given market\\r\\n     * @param leToken The market to verify the repay against\\r\\n     * @param borrower The account which would borrowed the asset\\r\\n     * @custom:error ActionPaused error is thrown if repayments are paused in this market\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function preRepayHook(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override {\\r\\n        _checkActionPauseState(leToken, Action.REPAY);\\r\\n\\r\\n        oracle.updatePrice(leToken, priceUpdateData);\\r\\n\\r\\n        if (!markets[leToken].isListed) {\\r\\n            revert MarketNotListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            Exp memory borrowIndex = Exp({\\r\\n                mantissa: LeToken(leToken).borrowIndex()\\r\\n            });\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            rewardsDistributor.updateRewardTokenBorrowIndex(\\r\\n                leToken,\\r\\n                borrowIndex\\r\\n            );\\r\\n            rewardsDistributor.distributeBorrowerRewardToken(\\r\\n                leToken,\\r\\n                borrower,\\r\\n                borrowIndex\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the liquidation should be allowed to occur\\r\\n     * @param leTokenBorrowed Asset which was borrowed by the borrower\\r\\n     * @param leTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param borrower The address of the borrower\\r\\n     * @param repayAmount The amount of underlying being repaid\\r\\n     * @param skipLiquidityCheck Allows the borrow to be liquidated regardless of the account liquidity\\r\\n     * @custom:error ActionPaused error is thrown if liquidations are paused in this market\\r\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\r\\n     * @custom:error TooMuchRepay error is thrown if the liquidator is trying to repay more than allowed by close factor\\r\\n     * @custom:error MinimalCollateralViolated is thrown if the users' total collateral is lower than the threshold for non-batch liquidations\\r\\n     * @custom:error InsufficientShortfall is thrown when trying to liquidate a healthy account\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     */\\r\\n    function preLiquidateHook(\\r\\n        address leTokenBorrowed,\\r\\n        address leTokenCollateral,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bool skipLiquidityCheck,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override {\\r\\n        // Pause Action.LIQUIDATE on BORROWED TOKEN to prevent liquidating it.\\r\\n        // If we want to pause liquidating to leTokenCollateral, we should pause\\r\\n        // Action.SEIZE on it\\r\\n        _checkActionPauseState(leTokenBorrowed, Action.LIQUIDATE);\\r\\n\\r\\n        // Update the prices of tokens\\r\\n        updatePrices(borrower, priceUpdateData);\\r\\n\\r\\n        if (!markets[leTokenBorrowed].isListed) {\\r\\n            revert MarketNotListed(address(leTokenBorrowed));\\r\\n        }\\r\\n        if (!markets[leTokenCollateral].isListed) {\\r\\n            revert MarketNotListed(address(leTokenCollateral));\\r\\n        }\\r\\n\\r\\n        uint256 borrowBalance = LeToken(leTokenBorrowed).borrowBalanceStored(\\r\\n            borrower\\r\\n        );\\r\\n\\r\\n        /* Allow accounts to be liquidated if it is a forced liquidation */\\r\\n        if (skipLiquidityCheck || isForcedLiquidationEnabled[leTokenBorrowed]) {\\r\\n            if (repayAmount > borrowBalance) {\\r\\n                revert TooMuchRepay();\\r\\n            }\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        /* The borrower must have shortfall and collateral > threshold in order to be liquidatable */\\r\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(\\r\\n            borrower,\\r\\n            _getLiquidationThreshold\\r\\n        );\\r\\n\\r\\n        if (snapshot.totalCollateral <= minLiquidatableCollateral) {\\r\\n            /* The liquidator should use either liquidateAccount or healAccount */\\r\\n            revert MinimalCollateralViolated(\\r\\n                minLiquidatableCollateral,\\r\\n                snapshot.totalCollateral\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (snapshot.shortfall == 0) {\\r\\n            revert InsufficientShortfall();\\r\\n        }\\r\\n\\r\\n        /* The liquidator may not repay more than what is allowed by the closeFactor */\\r\\n        uint256 maxClose = mul_ScalarTruncate(\\r\\n            Exp({mantissa: closeFactorMantissa}),\\r\\n            borrowBalance\\r\\n        );\\r\\n        if (repayAmount > maxClose) {\\r\\n            revert TooMuchRepay();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the seizing of assets should be allowed to occur\\r\\n     * @param leTokenCollateral Asset which was used as collateral and will be seized\\r\\n     * @param seizerContract Contract that tries to seize the asset (either borrowed leToken or Comptroller)\\r\\n     * @param liquidator The address repaying the borrow and seizing the collateral\\r\\n     * @param borrower The address of the borrower\\r\\n     * @custom:error ActionPaused error is thrown if seizing this type of collateral is paused\\r\\n     * @custom:error MarketNotListed error is thrown if either collateral or borrowed token is not listed\\r\\n     * @custom:error ComptrollerMismatch error is when seizer contract or seized asset belong to different pools\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function preSeizeHook(\\r\\n        address leTokenCollateral,\\r\\n        address seizerContract,\\r\\n        address liquidator,\\r\\n        address borrower\\r\\n    ) external override {\\r\\n        // Pause Action.SEIZE on COLLATERAL to prevent seizing it.\\r\\n        // If we want to pause liquidating leTokenBorrowed, we should pause\\r\\n        // Action.LIQUIDATE on it\\r\\n        _checkActionPauseState(leTokenCollateral, Action.SEIZE);\\r\\n\\r\\n        Market storage market = markets[leTokenCollateral];\\r\\n\\r\\n        if (!market.isListed) {\\r\\n            revert MarketNotListed(leTokenCollateral);\\r\\n        }\\r\\n\\r\\n        if (seizerContract == address(this)) {\\r\\n            // If Comptroller is the seizer, just check if collateral's comptroller\\r\\n            // is equal to the current address\\r\\n            if (\\r\\n                address(LeToken(leTokenCollateral).comptroller()) !=\\r\\n                address(this)\\r\\n            ) {\\r\\n                revert ComptrollerMismatch();\\r\\n            }\\r\\n        } else {\\r\\n            // If the seizer is not the Comptroller, check that the seizer is a\\r\\n            // listed market, and that the markets' comptrollers match\\r\\n            if (!markets[seizerContract].isListed) {\\r\\n                revert MarketNotListed(seizerContract);\\r\\n            }\\r\\n            if (\\r\\n                LeToken(leTokenCollateral).comptroller() !=\\r\\n                LeToken(seizerContract).comptroller()\\r\\n            ) {\\r\\n                revert ComptrollerMismatch();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        if (!market.accountMembership[borrower]) {\\r\\n            revert MarketNotCollateral(leTokenCollateral, borrower);\\r\\n        }\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            rewardsDistributor.updateRewardTokenSupplyIndex(leTokenCollateral);\\r\\n            rewardsDistributor.distributeSupplierRewardToken(\\r\\n                leTokenCollateral,\\r\\n                borrower\\r\\n            );\\r\\n            rewardsDistributor.distributeSupplierRewardToken(\\r\\n                leTokenCollateral,\\r\\n                liquidator\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if the account should be allowed to transfer tokens in the given market\\r\\n     * @param leToken The market to verify the transfer against\\r\\n     * @param src The account which sources the tokens\\r\\n     * @param dst The account which receives the tokens\\r\\n     * @param transferTokens The number of leTokens to transfer\\r\\n     * @custom:error ActionPaused error is thrown if withdrawals are paused in this market\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:error InsufficientLiquidity error is thrown if the withdrawal would lead to user's insolvency\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function preTransferHook(\\r\\n        address leToken,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 transferTokens\\r\\n    ) external override {\\r\\n        _checkActionPauseState(leToken, Action.TRANSFER);\\r\\n\\r\\n        // Currently the only consideration is whether or not\\r\\n        //  the src is allowed to redeem this many tokens\\r\\n\\r\\n        // Keep the flywheel moving\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            rewardsDistributor.updateRewardTokenSupplyIndex(leToken);\\r\\n            rewardsDistributor.distributeSupplierRewardToken(leToken, src);\\r\\n            rewardsDistributor.distributeSupplierRewardToken(leToken, dst);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /*** Pool-level operations ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Seizes all the remaining collateral, makes msg.sender repay the existing\\r\\n     *   borrows, and treats the rest of the debt as bad debt (for each market).\\r\\n     *   The sender has to repay a certain percentage of the debt, computed as\\r\\n     *   collateral / (borrows * liquidationIncentive).\\r\\n     * @param user account to heal\\r\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for healing\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function healAccount(address user) external {\\r\\n        LeToken[] memory userAssets = accountAssets[user];\\r\\n        uint256 userAssetsCount = userAssets.length;\\r\\n\\r\\n        {\\r\\n            ResilientOracleInterface oracle_ = oracle;\\r\\n            // We need all user's markets to be fresh for the computations to be correct\\r\\n            for (uint256 i; i < userAssetsCount; ++i) {\\r\\n                userAssets[i].accrueInterest();\\r\\n            }\\r\\n        }\\r\\n\\r\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(\\r\\n            user,\\r\\n            _getLiquidationThreshold\\r\\n        );\\r\\n\\r\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\r\\n            revert CollateralExceedsThreshold(\\r\\n                minLiquidatableCollateral,\\r\\n                snapshot.totalCollateral\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (snapshot.shortfall == 0) {\\r\\n            revert InsufficientShortfall();\\r\\n        }\\r\\n\\r\\n        // percentage = collateral / (borrows * liquidation incentive)\\r\\n        Exp memory collateral = Exp({mantissa: snapshot.totalCollateral});\\r\\n        Exp memory scaledBorrows = mul_(\\r\\n            Exp({mantissa: snapshot.borrows}),\\r\\n            Exp({mantissa: liquidationIncentiveMantissa})\\r\\n        );\\r\\n\\r\\n        Exp memory percentage = div_(collateral, scaledBorrows);\\r\\n        if (lessThanExp(Exp({mantissa: MANTISSA_ONE}), percentage)) {\\r\\n            revert CollateralExceedsThreshold(\\r\\n                scaledBorrows.mantissa,\\r\\n                collateral.mantissa\\r\\n            );\\r\\n        }\\r\\n\\r\\n        for (uint256 i; i < userAssetsCount; ++i) {\\r\\n            LeToken market = userAssets[i];\\r\\n\\r\\n            (uint256 tokens, uint256 borrowBalance, ) = _safeGetAccountSnapshot(\\r\\n                market,\\r\\n                user\\r\\n            );\\r\\n            uint256 repaymentAmount = mul_ScalarTruncate(\\r\\n                percentage,\\r\\n                borrowBalance\\r\\n            );\\r\\n\\r\\n            // Seize the entire collateral\\r\\n            if (tokens != 0) {\\r\\n                market.seize(msg.sender, user, tokens);\\r\\n            }\\r\\n            // Repay a certain percentage of the borrow, forgive the rest\\r\\n            if (borrowBalance != 0) {\\r\\n                bytes[] memory priceUpdateData = new bytes[](0);\\r\\n                market.healBorrow(\\r\\n                    msg.sender,\\r\\n                    user,\\r\\n                    repaymentAmount,\\r\\n                    priceUpdateData\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Liquidates all borrows of the borrower. Callable only if the collateral is less than\\r\\n     *   a predefined threshold, and the account collateral can be seized to cover all borrows. If\\r\\n     *   the collateral is higher than the threshold, use regular liquidations. If the collateral is\\r\\n     *   below the threshold, and the account is insolvent, use healAccount.\\r\\n     * @param borrower the borrower address\\r\\n     * @param orders an array of liquidation orders\\r\\n     * @custom:error CollateralExceedsThreshold error is thrown when the collateral is too big for a batch liquidation\\r\\n     * @custom:error InsufficientCollateral error is thrown when there is not enough collateral to cover the debt\\r\\n     * @custom:error SnapshotError is thrown if some leToken fails to return the account's supply and borrows\\r\\n     * @custom:error PriceError is thrown if the oracle returns an incorrect price for some asset\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function liquidateAccount(\\r\\n        address borrower,\\r\\n        LiquidationOrder[] calldata orders,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external {\\r\\n        // We will accrue interest and update the oracle prices later during the liquidation\\r\\n\\r\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(\\r\\n            borrower,\\r\\n            _getLiquidationThreshold\\r\\n        );\\r\\n\\r\\n        if (snapshot.totalCollateral > minLiquidatableCollateral) {\\r\\n            // You should use the regular leToken.liquidateBorrow(...) call\\r\\n            revert CollateralExceedsThreshold(\\r\\n                minLiquidatableCollateral,\\r\\n                snapshot.totalCollateral\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 collateralToSeize = mul_ScalarTruncate(\\r\\n            Exp({mantissa: liquidationIncentiveMantissa}),\\r\\n            snapshot.borrows\\r\\n        );\\r\\n        if (collateralToSeize >= snapshot.totalCollateral) {\\r\\n            // There is not enough collateral to seize. Use healBorrow to repay some part of the borrow\\r\\n            // and record bad debt.\\r\\n            revert InsufficientCollateral(\\r\\n                collateralToSeize,\\r\\n                snapshot.totalCollateral\\r\\n            );\\r\\n        }\\r\\n\\r\\n        if (snapshot.shortfall == 0) {\\r\\n            revert InsufficientShortfall();\\r\\n        }\\r\\n\\r\\n        uint256 ordersCount = orders.length;\\r\\n\\r\\n        _ensureMaxLoops(ordersCount / 2);\\r\\n\\r\\n        for (uint256 i; i < ordersCount; ++i) {\\r\\n            if (!markets[address(orders[i].leTokenBorrowed)].isListed) {\\r\\n                revert MarketNotListed(address(orders[i].leTokenBorrowed));\\r\\n            }\\r\\n            if (!markets[address(orders[i].leTokenCollateral)].isListed) {\\r\\n                revert MarketNotListed(address(orders[i].leTokenCollateral));\\r\\n            }\\r\\n\\r\\n            LiquidationOrder calldata order = orders[i];\\r\\n            order.leTokenBorrowed.forceLiquidateBorrow(\\r\\n                msg.sender,\\r\\n                borrower,\\r\\n                order.repayAmount,\\r\\n                order.leTokenCollateral,\\r\\n                true,\\r\\n                priceUpdateData\\r\\n            );\\r\\n        }\\r\\n\\r\\n        LeToken[] memory borrowMarkets = accountAssets[borrower];\\r\\n        uint256 marketsCount = borrowMarkets.length;\\r\\n\\r\\n        for (uint256 i; i < marketsCount; ++i) {\\r\\n            (, uint256 borrowBalance, ) = _safeGetAccountSnapshot(\\r\\n                borrowMarkets[i],\\r\\n                borrower\\r\\n            );\\r\\n            require(\\r\\n                borrowBalance == 0,\\r\\n                \\\"Nonzero borrow balance after liquidation\\\"\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the closeFactor to use when liquidating borrows\\r\\n     * @param newCloseFactorMantissa New close factor, scaled by 1e18\\r\\n     * @custom:event Emits NewCloseFactor on success\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setCloseFactor(uint256 newCloseFactorMantissa) external {\\r\\n        _checkAccessAllowed(\\\"setCloseFactor(uint256)\\\");\\r\\n        require(\\r\\n            MAX_CLOSE_FACTOR_MANTISSA >= newCloseFactorMantissa,\\r\\n            \\\"Close factor greater than maximum close factor\\\"\\r\\n        );\\r\\n        require(\\r\\n            MIN_CLOSE_FACTOR_MANTISSA <= newCloseFactorMantissa,\\r\\n            \\\"Close factor smaller than minimum close factor\\\"\\r\\n        );\\r\\n\\r\\n        uint256 oldCloseFactorMantissa = closeFactorMantissa;\\r\\n        closeFactorMantissa = newCloseFactorMantissa;\\r\\n        emit NewCloseFactor(oldCloseFactorMantissa, newCloseFactorMantissa);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the collateralFactor for a market\\r\\n     * @dev This function is restricted by the AccessControlManager\\r\\n     * @param leToken The market to set the factor on\\r\\n     * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\\r\\n     * @param newLiquidationThresholdMantissa The new liquidation threshold, scaled by 1e18\\r\\n     * @custom:event Emits NewCollateralFactor when collateral factor is updated\\r\\n     *    and NewLiquidationThreshold when liquidation threshold is updated\\r\\n     * @custom:error MarketNotListed error is thrown when the market is not listed\\r\\n     * @custom:error InvalidCollateralFactor error is thrown when collateral factor is too high\\r\\n     * @custom:error InvalidLiquidationThreshold error is thrown when liquidation threshold is lower than collateral factor\\r\\n     * @custom:error PriceError is thrown when the oracle returns an invalid price for the asset\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setCollateralFactor(\\r\\n        LeToken leToken,\\r\\n        uint256 newCollateralFactorMantissa,\\r\\n        uint256 newLiquidationThresholdMantissa\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setCollateralFactor(address,uint256,uint256)\\\");\\r\\n\\r\\n        // Verify market is listed\\r\\n        Market storage market = markets[address(leToken)];\\r\\n        if (!market.isListed) {\\r\\n            revert MarketNotListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        // Check collateral factor <= 0.9\\r\\n        if (newCollateralFactorMantissa > MAX_COLLATERAL_FACTOR_MANTISSA) {\\r\\n            revert InvalidCollateralFactor();\\r\\n        }\\r\\n\\r\\n        // Ensure that liquidation threshold <= 1\\r\\n        if (newLiquidationThresholdMantissa > MANTISSA_ONE) {\\r\\n            revert InvalidLiquidationThreshold();\\r\\n        }\\r\\n\\r\\n        // Ensure that liquidation threshold >= CF\\r\\n        if (newLiquidationThresholdMantissa < newCollateralFactorMantissa) {\\r\\n            revert InvalidLiquidationThreshold();\\r\\n        }\\r\\n\\r\\n        // If collateral factor != 0, fail if price == 0\\r\\n        if (\\r\\n            newCollateralFactorMantissa != 0 &&\\r\\n            oracle.getUnderlyingPrice(address(leToken)) == 0\\r\\n        ) {\\r\\n            revert PriceError(address(leToken));\\r\\n        }\\r\\n\\r\\n        uint256 oldCollateralFactorMantissa = market.collateralFactorMantissa;\\r\\n        if (newCollateralFactorMantissa != oldCollateralFactorMantissa) {\\r\\n            market.collateralFactorMantissa = newCollateralFactorMantissa;\\r\\n            emit NewCollateralFactor(\\r\\n                leToken,\\r\\n                oldCollateralFactorMantissa,\\r\\n                newCollateralFactorMantissa\\r\\n            );\\r\\n        }\\r\\n\\r\\n        uint256 oldLiquidationThresholdMantissa = market\\r\\n            .liquidationThresholdMantissa;\\r\\n        if (\\r\\n            newLiquidationThresholdMantissa != oldLiquidationThresholdMantissa\\r\\n        ) {\\r\\n            market\\r\\n                .liquidationThresholdMantissa = newLiquidationThresholdMantissa;\\r\\n            emit NewLiquidationThreshold(\\r\\n                leToken,\\r\\n                oldLiquidationThresholdMantissa,\\r\\n                newLiquidationThresholdMantissa\\r\\n            );\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets liquidationIncentive\\r\\n     * @dev This function is restricted by the AccessControlManager\\r\\n     * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\\r\\n     * @custom:event Emits NewLiquidationIncentive on success\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setLiquidationIncentive(\\r\\n        uint256 newLiquidationIncentiveMantissa\\r\\n    ) external {\\r\\n        require(\\r\\n            newLiquidationIncentiveMantissa >= MANTISSA_ONE,\\r\\n            \\\"liquidation incentive should be greater than 1e18\\\"\\r\\n        );\\r\\n\\r\\n        _checkAccessAllowed(\\\"setLiquidationIncentive(uint256)\\\");\\r\\n\\r\\n        // Save current value for use in log\\r\\n        uint256 oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\\r\\n\\r\\n        // Set liquidation incentive to new incentive\\r\\n        liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\\r\\n\\r\\n        // Emit event with old incentive, new incentive\\r\\n        emit NewLiquidationIncentive(\\r\\n            oldLiquidationIncentiveMantissa,\\r\\n            newLiquidationIncentiveMantissa\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add the market to the markets mapping and set it as listed\\r\\n     * @dev Only callable by the PoolRegistry\\r\\n     * @param leToken The address of the market (token) to list\\r\\n     * @custom:error MarketAlreadyListed is thrown if the market is already listed in this pool\\r\\n     * @custom:access Only PoolRegistry\\r\\n     */\\r\\n    function supportMarket(LeToken leToken) external {\\r\\n        _checkSenderIs(poolRegistry);\\r\\n\\r\\n        if (markets[address(leToken)].isListed) {\\r\\n            revert MarketAlreadyListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        require(leToken.isLeToken(), \\\"Comptroller: Invalid leToken\\\"); // Sanity check to make sure its really a LeToken\\r\\n\\r\\n        Market storage newMarket = markets[address(leToken)];\\r\\n        newMarket.isListed = true;\\r\\n        newMarket.collateralFactorMantissa = 0;\\r\\n        newMarket.liquidationThresholdMantissa = 0;\\r\\n\\r\\n        _addMarket(address(leToken));\\r\\n\\r\\n        uint256 rewardDistributorsCount = rewardsDistributors.length;\\r\\n\\r\\n        for (uint256 i; i < rewardDistributorsCount; ++i) {\\r\\n            rewardsDistributors[i].initializeMarket(address(leToken));\\r\\n        }\\r\\n\\r\\n        emit MarketSupported(leToken);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the given borrow caps for the given leToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\\r\\n     * @dev This function is restricted by the AccessControlManager\\r\\n     * @dev A borrow cap of type(uint256).max corresponds to unlimited borrowing.\\r\\n     * @dev Borrow caps smaller than the current total borrows are accepted. This way, new borrows will not be allowed\\r\\n            until the total borrows amount goes below the new borrow cap\\r\\n     * @param leTokens The addresses of the markets (tokens) to change the borrow caps for\\r\\n     * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited borrowing.\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setMarketBorrowCaps(\\r\\n        LeToken[] calldata leTokens,\\r\\n        uint256[] calldata newBorrowCaps\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setMarketBorrowCaps(address[],uint256[])\\\");\\r\\n\\r\\n        uint256 numMarkets = leTokens.length;\\r\\n        uint256 numBorrowCaps = newBorrowCaps.length;\\r\\n\\r\\n        require(\\r\\n            numMarkets != 0 && numMarkets == numBorrowCaps,\\r\\n            \\\"invalid input\\\"\\r\\n        );\\r\\n\\r\\n        _ensureMaxLoops(numMarkets);\\r\\n\\r\\n        for (uint256 i; i < numMarkets; ++i) {\\r\\n            borrowCaps[address(leTokens[i])] = newBorrowCaps[i];\\r\\n            emit NewBorrowCap(leTokens[i], newBorrowCaps[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the given supply caps for the given leToken markets. Supply that brings total Supply to or above supply cap will revert.\\r\\n     * @dev This function is restricted by the AccessControlManager\\r\\n     * @dev A supply cap of type(uint256).max corresponds to unlimited supply.\\r\\n     * @dev Supply caps smaller than the current total supplies are accepted. This way, new supplies will not be allowed\\r\\n            until the total supplies amount goes below the new supply cap\\r\\n     * @param leTokens The addresses of the markets (tokens) to change the supply caps for\\r\\n     * @param newSupplyCaps The new supply cap values in underlying to be set. A value of type(uint256).max corresponds to unlimited supply.\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setMarketSupplyCaps(\\r\\n        LeToken[] calldata leTokens,\\r\\n        uint256[] calldata newSupplyCaps\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setMarketSupplyCaps(address[],uint256[])\\\");\\r\\n        uint256 leTokensCount = leTokens.length;\\r\\n\\r\\n        require(leTokensCount != 0, \\\"invalid number of markets\\\");\\r\\n        require(\\r\\n            leTokensCount == newSupplyCaps.length,\\r\\n            \\\"invalid number of markets\\\"\\r\\n        );\\r\\n\\r\\n        _ensureMaxLoops(leTokensCount);\\r\\n\\r\\n        for (uint256 i; i < leTokensCount; ++i) {\\r\\n            supplyCaps[address(leTokens[i])] = newSupplyCaps[i];\\r\\n            emit NewSupplyCap(leTokens[i], newSupplyCaps[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Pause/unpause specified actions\\r\\n     * @dev This function is restricted by the AccessControlManager\\r\\n     * @param marketsList Markets to pause/unpause the actions on\\r\\n     * @param actionsList List of action ids to pause/unpause\\r\\n     * @param paused The new paused state (true=paused, false=unpaused)\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setActionsPaused(\\r\\n        LeToken[] calldata marketsList,\\r\\n        Action[] calldata actionsList,\\r\\n        bool paused\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setActionsPaused(address[],uint256[],bool)\\\");\\r\\n\\r\\n        uint256 marketsCount = marketsList.length;\\r\\n        uint256 actionsCount = actionsList.length;\\r\\n\\r\\n        _ensureMaxLoops(marketsCount * actionsCount);\\r\\n\\r\\n        for (uint256 marketIdx; marketIdx < marketsCount; ++marketIdx) {\\r\\n            for (uint256 actionIdx; actionIdx < actionsCount; ++actionIdx) {\\r\\n                _setActionPaused(\\r\\n                    address(marketsList[marketIdx]),\\r\\n                    actionsList[actionIdx],\\r\\n                    paused\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the given collateral threshold for non-batch liquidations. Regular liquidations\\r\\n     *   will fail if the collateral amount is less than this threshold. Liquidators should use batch\\r\\n     *   operations like liquidateAccount or healAccount.\\r\\n     * @dev This function is restricted by the AccessControlManager\\r\\n     * @param newMinLiquidatableCollateral The new min liquidatable collateral (in USD).\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setMinLiquidatableCollateral(\\r\\n        uint256 newMinLiquidatableCollateral\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setMinLiquidatableCollateral(uint256)\\\");\\r\\n\\r\\n        uint256 oldMinLiquidatableCollateral = minLiquidatableCollateral;\\r\\n        minLiquidatableCollateral = newMinLiquidatableCollateral;\\r\\n        emit NewMinLiquidatableCollateral(\\r\\n            oldMinLiquidatableCollateral,\\r\\n            newMinLiquidatableCollateral\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a new RewardsDistributor and initialize it with all markets. We can add several RewardsDistributor\\r\\n     * contracts with the same rewardToken, and there could be overlaping among them considering the last reward block\\r\\n     * @dev Only callable by the admin\\r\\n     * @param _rewardsDistributor Address of the RewardDistributor contract to add\\r\\n     * @custom:access Only Governance\\r\\n     * @custom:event Emits NewRewardsDistributor with distributor address\\r\\n     */\\r\\n    function addRewardsDistributor(\\r\\n        RewardsDistributor _rewardsDistributor\\r\\n    ) external onlyOwner {\\r\\n        require(\\r\\n            !rewardsDistributorExists[address(_rewardsDistributor)],\\r\\n            \\\"already exists\\\"\\r\\n        );\\r\\n\\r\\n        uint256 rewardsDistributorsLen = rewardsDistributors.length;\\r\\n        _ensureMaxLoops(rewardsDistributorsLen + 1);\\r\\n\\r\\n        rewardsDistributors.push(_rewardsDistributor);\\r\\n        rewardsDistributorExists[address(_rewardsDistributor)] = true;\\r\\n\\r\\n        uint256 marketsCount = allMarkets.length;\\r\\n\\r\\n        for (uint256 i; i < marketsCount; ++i) {\\r\\n            _rewardsDistributor.initializeMarket(address(allMarkets[i]));\\r\\n        }\\r\\n\\r\\n        emit NewRewardsDistributor(\\r\\n            address(_rewardsDistributor),\\r\\n            address(_rewardsDistributor.rewardToken())\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets a new price oracle for the Comptroller\\r\\n     * @dev Only callable by the admin\\r\\n     * @param newOracle Address of the new price oracle to set\\r\\n     * @custom:event Emits NewPriceOracle on success\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when the new oracle address is zero\\r\\n     */\\r\\n    function setPriceOracle(\\r\\n        ResilientOracleInterface newOracle\\r\\n    ) external onlyOwner {\\r\\n        ensureNonzeroAddress(address(newOracle));\\r\\n\\r\\n        ResilientOracleInterface oldOracle = oracle;\\r\\n        oracle = newOracle;\\r\\n        emit NewPriceOracle(oldOracle, newOracle);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the for loop iteration limit to avoid DOS\\r\\n     * @param limit Limit for the max loops can execute at a time\\r\\n     */\\r\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\r\\n        _setMaxLoopsLimit(limit);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the prime token contract for the comptroller\\r\\n     * @param _prime Address of the Prime contract\\r\\n     */\\r\\n    function setPrimeToken(IPrime _prime) external onlyOwner {\\r\\n        ensureNonzeroAddress(address(_prime));\\r\\n\\r\\n        emit NewPrimeToken(prime, _prime);\\r\\n        prime = _prime;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Enables forced liquidations for a market. If forced liquidation is enabled,\\r\\n     * borrows in the market may be liquidated regardless of the account liquidity\\r\\n     * @param leTokenBorrowed Borrowed leToken\\r\\n     * @param enable Whether to enable forced liquidations\\r\\n     */\\r\\n    function setForcedLiquidation(\\r\\n        address leTokenBorrowed,\\r\\n        bool enable\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setForcedLiquidation(address,bool)\\\");\\r\\n        ensureNonzeroAddress(leTokenBorrowed);\\r\\n\\r\\n        if (!markets[leTokenBorrowed].isListed) {\\r\\n            revert MarketNotListed(leTokenBorrowed);\\r\\n        }\\r\\n\\r\\n        isForcedLiquidationEnabled[leTokenBorrowed] = enable;\\r\\n        emit IsForcedLiquidationEnabledUpdated(leTokenBorrowed, enable);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine the current account liquidity with respect to liquidation threshold requirements\\r\\n     * @dev The interface of this function is intentionally kept compatible with Compound and LendLand Core\\r\\n     * @param account The account get liquidity for\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @return liquidity Account liquidity in excess of liquidation threshold requirements,\\r\\n     * @return shortfall Account shortfall below liquidation threshold requirements\\r\\n     */\\r\\n    function getAccountLiquidity(\\r\\n        address account\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 error, uint256 liquidity, uint256 shortfall)\\r\\n    {\\r\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(\\r\\n            account,\\r\\n            _getLiquidationThreshold\\r\\n        );\\r\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine the current account liquidity with respect to collateral requirements\\r\\n     * @dev The interface of this function is intentionally kept compatible with Compound and LendLand Core\\r\\n     * @param account The account get liquidity for\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @return liquidity Account liquidity in excess of collateral requirements,\\r\\n     * @return shortfall Account shortfall below collateral requirements\\r\\n     */\\r\\n    function getBorrowingPower(\\r\\n        address account\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 error, uint256 liquidity, uint256 shortfall)\\r\\n    {\\r\\n        AccountLiquiditySnapshot memory snapshot = _getCurrentLiquiditySnapshot(\\r\\n            account,\\r\\n            _getCollateralFactor\\r\\n        );\\r\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\\r\\n     * @dev The interface of this function is intentionally kept compatible with Compound and LendLand Core\\r\\n     * @param leTokenModify The market to hypothetically redeem/borrow in\\r\\n     * @param account The account to determine liquidity for\\r\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\r\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @return liquidity Hypothetical account liquidity in excess of collateral requirements,\\r\\n     * @return shortfall Hypothetical account shortfall below collateral requirements\\r\\n     */\\r\\n    function getHypotheticalAccountLiquidity(\\r\\n        address account,\\r\\n        address leTokenModify,\\r\\n        uint256 redeemTokens,\\r\\n        uint256 borrowAmount\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 error, uint256 liquidity, uint256 shortfall)\\r\\n    {\\r\\n        AccountLiquiditySnapshot\\r\\n            memory snapshot = _getHypotheticalLiquiditySnapshot(\\r\\n                account,\\r\\n                LeToken(leTokenModify),\\r\\n                redeemTokens,\\r\\n                borrowAmount,\\r\\n                _getCollateralFactor\\r\\n            );\\r\\n        return (NO_ERROR, snapshot.liquidity, snapshot.shortfall);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return all of the markets\\r\\n     * @dev The automatic getter may be used to access an individual market.\\r\\n     * @return markets The list of market addresses\\r\\n     */\\r\\n    function getAllMarkets() external view override returns (LeToken[] memory) {\\r\\n        return allMarkets;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Check if a market is marked as listed (active)\\r\\n     * @param leToken leToken Address for the market to check\\r\\n     * @return listed True if listed otherwise false\\r\\n     */\\r\\n    function isMarketListed(LeToken leToken) external view returns (bool) {\\r\\n        return markets[address(leToken)].isListed;\\r\\n    }\\r\\n\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the assets an account has entered\\r\\n     * @param account The address of the account to pull assets for\\r\\n     * @return A list with the assets the account has entered\\r\\n     */\\r\\n    function getAssetsIn(\\r\\n        address account\\r\\n    ) external view returns (LeToken[] memory) {\\r\\n        LeToken[] memory assetsIn = accountAssets[account];\\r\\n\\r\\n        return assetsIn;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns whether the given account is entered in a given market\\r\\n     * @param account The address of the account to check\\r\\n     * @param leToken The leToken to check\\r\\n     * @return True if the account is in the market specified, otherwise false.\\r\\n     */\\r\\n    function checkMembership(\\r\\n        address account,\\r\\n        LeToken leToken\\r\\n    ) external view returns (bool) {\\r\\n        return markets[address(leToken)].accountMembership[account];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\\r\\n     * @dev Used in liquidation (called in leToken.liquidateBorrowFresh)\\r\\n     * @param leTokenBorrowed The address of the borrowed leToken\\r\\n     * @param leTokenCollateral The address of the collateral leToken\\r\\n     * @param actualRepayAmount The amount of leTokenBorrowed underlying to convert into leTokenCollateral tokens\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @return tokensToSeize Number of leTokenCollateral tokens to be seized in a liquidation\\r\\n     * @custom:error PriceError if the oracle returns an invalid price\\r\\n     */\\r\\n    function liquidateCalculateSeizeTokens(\\r\\n        address leTokenBorrowed,\\r\\n        address leTokenCollateral,\\r\\n        uint256 actualRepayAmount\\r\\n    ) external view override returns (uint256 error, uint256 tokensToSeize) {\\r\\n        /* Read oracle prices for borrowed and collateral markets */\\r\\n        uint256 priceBorrowedMantissa = _safeGetUnderlyingPrice(\\r\\n            LeToken(leTokenBorrowed)\\r\\n        );\\r\\n        uint256 priceCollateralMantissa = _safeGetUnderlyingPrice(\\r\\n            LeToken(leTokenCollateral)\\r\\n        );\\r\\n\\r\\n        /*\\r\\n         * Get the exchange rate and calculate the number of collateral tokens to seize:\\r\\n         *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\\r\\n         *  seizeTokens = seizeAmount / exchangeRate\\r\\n         *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\\r\\n         */\\r\\n        uint256 exchangeRateMantissa = LeToken(leTokenCollateral)\\r\\n            .exchangeRateStored(); // Note: reverts on error\\r\\n        uint256 seizeTokens;\\r\\n        Exp memory numerator;\\r\\n        Exp memory denominator;\\r\\n        Exp memory ratio;\\r\\n\\r\\n        numerator = mul_(\\r\\n            Exp({mantissa: liquidationIncentiveMantissa}),\\r\\n            Exp({mantissa: priceBorrowedMantissa})\\r\\n        );\\r\\n        denominator = mul_(\\r\\n            Exp({mantissa: priceCollateralMantissa}),\\r\\n            Exp({mantissa: exchangeRateMantissa})\\r\\n        );\\r\\n        ratio = div_(numerator, denominator);\\r\\n\\r\\n        seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\\r\\n\\r\\n        return (NO_ERROR, seizeTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns reward speed given a leToken\\r\\n     * @param leToken The leToken to get the reward speeds for\\r\\n     * @return rewardSpeeds Array of total supply and borrow speeds and reward token for all reward distributors\\r\\n     */\\r\\n    function getRewardsByMarket(\\r\\n        address leToken\\r\\n    ) external view returns (RewardSpeeds[] memory rewardSpeeds) {\\r\\n        uint256 rewardsDistributorsLength = rewardsDistributors.length;\\r\\n        rewardSpeeds = new RewardSpeeds[](rewardsDistributorsLength);\\r\\n        for (uint256 i; i < rewardsDistributorsLength; ++i) {\\r\\n            RewardsDistributor rewardsDistributor = rewardsDistributors[i];\\r\\n            address rewardToken = address(rewardsDistributor.rewardToken());\\r\\n            rewardSpeeds[i] = RewardSpeeds({\\r\\n                rewardToken: rewardToken,\\r\\n                supplySpeed: rewardsDistributor.rewardTokenSupplySpeeds(\\r\\n                    leToken\\r\\n                ),\\r\\n                borrowSpeed: rewardsDistributor.rewardTokenBorrowSpeeds(leToken)\\r\\n            });\\r\\n        }\\r\\n        return rewardSpeeds;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return all reward distributors for this pool\\r\\n     * @return Array of RewardDistributor addresses\\r\\n     */\\r\\n    function getRewardDistributors()\\r\\n        external\\r\\n        view\\r\\n        returns (RewardsDistributor[] memory)\\r\\n    {\\r\\n        return rewardsDistributors;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A marker method that returns true for a valid Comptroller contract\\r\\n     * @return Always true\\r\\n     */\\r\\n    function isComptroller() external pure override returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update the prices of all the tokens associated with the provided account\\r\\n     * @param account Address of the account to get associated tokens with\\r\\n     */\\r\\n    function updatePrices(\\r\\n        address account,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) public {\\r\\n        LeToken[] memory leTokens = accountAssets[account];\\r\\n        uint256 leTokensCount = leTokens.length;\\r\\n\\r\\n        ResilientOracleInterface oracle_ = oracle;\\r\\n\\r\\n        for (uint256 i; i < leTokensCount; ++i) {\\r\\n            oracle_.updatePrice(address(leTokens[i]), priceUpdateData);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Checks if a certain action is paused on a market\\r\\n     * @param market leToken address\\r\\n     * @param action Action to check\\r\\n     * @return paused True if the action is paused otherwise false\\r\\n     */\\r\\n    function actionPaused(\\r\\n        address market,\\r\\n        Action action\\r\\n    ) public view returns (bool) {\\r\\n        return _actionPaused[market][action];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add the market to the borrower's \\\"assets in\\\" for liquidity calculations\\r\\n     * @param leToken The market to enter\\r\\n     * @param borrower The address of the account to modify\\r\\n     */\\r\\n    function _addToMarket(LeToken leToken, address borrower) internal {\\r\\n        _checkActionPauseState(address(leToken), Action.ENTER_MARKET);\\r\\n        Market storage marketToJoin = markets[address(leToken)];\\r\\n\\r\\n        if (!marketToJoin.isListed) {\\r\\n            revert MarketNotListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        if (marketToJoin.accountMembership[borrower]) {\\r\\n            // already joined\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // survived the gauntlet, add to list\\r\\n        // NOTE: we store these somewhat redundantly as a significant optimization\\r\\n        //  this avoids having to iterate through the list for the most common use cases\\r\\n        //  that is, only when we need to perform liquidity checks\\r\\n        //  and not whenever we want to check if an account is in a particular market\\r\\n        marketToJoin.accountMembership[borrower] = true;\\r\\n        accountAssets[borrower].push(leToken);\\r\\n\\r\\n        emit MarketEntered(leToken, borrower);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Internal function to validate that a market hasn't already been added\\r\\n     * and if it hasn't adds it\\r\\n     * @param leToken The market to support\\r\\n     */\\r\\n    function _addMarket(address leToken) internal {\\r\\n        uint256 marketsCount = allMarkets.length;\\r\\n\\r\\n        for (uint256 i; i < marketsCount; ++i) {\\r\\n            if (allMarkets[i] == LeToken(leToken)) {\\r\\n                revert MarketAlreadyListed(leToken);\\r\\n            }\\r\\n        }\\r\\n        allMarkets.push(LeToken(leToken));\\r\\n        marketsCount = allMarkets.length;\\r\\n        _ensureMaxLoops(marketsCount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Pause/unpause an action on a market\\r\\n     * @param market Market to pause/unpause the action on\\r\\n     * @param action Action id to pause/unpause\\r\\n     * @param paused The new paused state (true=paused, false=unpaused)\\r\\n     */\\r\\n    function _setActionPaused(\\r\\n        address market,\\r\\n        Action action,\\r\\n        bool paused\\r\\n    ) internal {\\r\\n        require(\\r\\n            markets[market].isListed,\\r\\n            \\\"cannot pause a market that is not listed\\\"\\r\\n        );\\r\\n        _actionPaused[market][action] = paused;\\r\\n        emit ActionPausedMarket(LeToken(market), action, paused);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to check that leTokens can be safely redeemed for the underlying asset.\\r\\n     * @param leToken Address of the leTokens to redeem\\r\\n     * @param redeemer Account redeeming the tokens\\r\\n     * @param redeemTokens The number of tokens to redeem\\r\\n     */\\r\\n    function _checkRedeemAllowed(\\r\\n        address leToken,\\r\\n        address redeemer,\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) internal {\\r\\n        Market storage market = markets[leToken];\\r\\n\\r\\n        if (!market.isListed) {\\r\\n            revert MarketNotListed(address(leToken));\\r\\n        }\\r\\n\\r\\n        /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\\r\\n        if (!market.accountMembership[redeemer]) {\\r\\n            return;\\r\\n        }\\r\\n\\r\\n        // Update the prices of tokens\\r\\n        updatePrices(redeemer, priceUpdateData);\\r\\n\\r\\n        /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\\r\\n        AccountLiquiditySnapshot\\r\\n            memory snapshot = _getHypotheticalLiquiditySnapshot(\\r\\n                redeemer,\\r\\n                LeToken(leToken),\\r\\n                redeemTokens,\\r\\n                0,\\r\\n                _getCollateralFactor\\r\\n            );\\r\\n        if (snapshot.shortfall > 0) {\\r\\n            revert InsufficientLiquidity();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the total collateral, weighted collateral, borrow balance, liquidity, shortfall\\r\\n     * @param account The account to get the snapshot for\\r\\n     * @param weight The function to compute the weight of the collateral \\u2013\\u00a0either collateral factor or\\r\\n     *  liquidation threshold. Accepts the address of the leToken and returns the weight as Exp.\\r\\n     * @dev Note that we calculate the exchangeRateStored for each collateral leToken using stored data,\\r\\n     *  without calculating accumulated interest.\\r\\n     * @return snapshot Account liquidity snapshot\\r\\n     */\\r\\n    function _getCurrentLiquiditySnapshot(\\r\\n        address account,\\r\\n        function(LeToken) internal view returns (Exp memory) weight\\r\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\r\\n        return\\r\\n            _getHypotheticalLiquiditySnapshot(\\r\\n                account,\\r\\n                LeToken(address(0)),\\r\\n                0,\\r\\n                0,\\r\\n                weight\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Determine what the supply/borrow balances would be if the given amounts were redeemed/borrowed\\r\\n     * @param leTokenModify The market to hypothetically redeem/borrow in\\r\\n     * @param account The account to determine liquidity for\\r\\n     * @param redeemTokens The number of tokens to hypothetically redeem\\r\\n     * @param borrowAmount The amount of underlying to hypothetically borrow\\r\\n     * @param weight The function to compute the weight of the collateral \\u2013\\u00a0either collateral factor or\\r\\n         liquidation threshold. Accepts the address of the LeToken and returns the weight\\r\\n     * @dev Note that we calculate the exchangeRateStored for each collateral leToken using stored data,\\r\\n     *  without calculating accumulated interest.\\r\\n     * @return snapshot Account liquidity snapshot\\r\\n     */\\r\\n    function _getHypotheticalLiquiditySnapshot(\\r\\n        address account,\\r\\n        LeToken leTokenModify,\\r\\n        uint256 redeemTokens,\\r\\n        uint256 borrowAmount,\\r\\n        function(LeToken) internal view returns (Exp memory) weight\\r\\n    ) internal view returns (AccountLiquiditySnapshot memory snapshot) {\\r\\n        // For each asset the account is in\\r\\n        LeToken[] memory assets = accountAssets[account];\\r\\n        uint256 assetsCount = assets.length;\\r\\n\\r\\n        for (uint256 i; i < assetsCount; ++i) {\\r\\n            LeToken asset = assets[i];\\r\\n\\r\\n            // Read the balances and exchange rate from the leToken\\r\\n            (\\r\\n                uint256 leTokenBalance,\\r\\n                uint256 borrowBalance,\\r\\n                uint256 exchangeRateMantissa\\r\\n            ) = _safeGetAccountSnapshot(asset, account);\\r\\n\\r\\n            // Get the normalized price of the asset\\r\\n            Exp memory oraclePrice = Exp({\\r\\n                mantissa: _safeGetUnderlyingPrice(asset)\\r\\n            });\\r\\n\\r\\n            // Pre-compute conversion factors from leTokens -> usd\\r\\n            Exp memory leTokenPrice = mul_(\\r\\n                Exp({mantissa: exchangeRateMantissa}),\\r\\n                oraclePrice\\r\\n            );\\r\\n            Exp memory weightedLeTokenPrice = mul_(weight(asset), leTokenPrice);\\r\\n\\r\\n            // weightedCollateral += weightedLeTokenPrice * leTokenBalance\\r\\n            snapshot.weightedCollateral = mul_ScalarTruncateAddUInt(\\r\\n                weightedLeTokenPrice,\\r\\n                leTokenBalance,\\r\\n                snapshot.weightedCollateral\\r\\n            );\\r\\n\\r\\n            // totalCollateral += leTokenPrice * leTokenBalance\\r\\n            snapshot.totalCollateral = mul_ScalarTruncateAddUInt(\\r\\n                leTokenPrice,\\r\\n                leTokenBalance,\\r\\n                snapshot.totalCollateral\\r\\n            );\\r\\n\\r\\n            // borrows += oraclePrice * borrowBalance\\r\\n            snapshot.borrows = mul_ScalarTruncateAddUInt(\\r\\n                oraclePrice,\\r\\n                borrowBalance,\\r\\n                snapshot.borrows\\r\\n            );\\r\\n\\r\\n            // Calculate effects of interacting with leTokenModify\\r\\n            if (asset == leTokenModify) {\\r\\n                // redeem effect\\r\\n                // effects += tokensToDenom * redeemTokens\\r\\n                snapshot.effects = mul_ScalarTruncateAddUInt(\\r\\n                    weightedLeTokenPrice,\\r\\n                    redeemTokens,\\r\\n                    snapshot.effects\\r\\n                );\\r\\n\\r\\n                // borrow effect\\r\\n                // effects += oraclePrice * borrowAmount\\r\\n                snapshot.effects = mul_ScalarTruncateAddUInt(\\r\\n                    oraclePrice,\\r\\n                    borrowAmount,\\r\\n                    snapshot.effects\\r\\n                );\\r\\n            }\\r\\n        }\\r\\n\\r\\n        uint256 borrowPlusEffects = snapshot.borrows + snapshot.effects;\\r\\n        // These are safe, as the underflow condition is checked first\\r\\n        unchecked {\\r\\n            if (snapshot.weightedCollateral > borrowPlusEffects) {\\r\\n                snapshot.liquidity =\\r\\n                    snapshot.weightedCollateral -\\r\\n                    borrowPlusEffects;\\r\\n                snapshot.shortfall = 0;\\r\\n            } else {\\r\\n                snapshot.liquidity = 0;\\r\\n                snapshot.shortfall =\\r\\n                    borrowPlusEffects -\\r\\n                    snapshot.weightedCollateral;\\r\\n            }\\r\\n        }\\r\\n\\r\\n        return snapshot;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieves price from oracle for an asset and checks it is nonzero\\r\\n     * @param asset Address for asset to query price\\r\\n     * @return Underlying price\\r\\n     */\\r\\n    function _safeGetUnderlyingPrice(\\r\\n        LeToken asset\\r\\n    ) internal view returns (uint256) {\\r\\n        uint256 oraclePriceMantissa = oracle.getUnderlyingPrice(address(asset));\\r\\n        if (oraclePriceMantissa == 0) {\\r\\n            revert PriceError(address(asset));\\r\\n        }\\r\\n        return oraclePriceMantissa;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Return collateral factor for a market\\r\\n     * @param asset Address for asset\\r\\n     * @return Collateral factor as exponential\\r\\n     */\\r\\n    function _getCollateralFactor(\\r\\n        LeToken asset\\r\\n    ) internal view returns (Exp memory) {\\r\\n        return\\r\\n            Exp({mantissa: markets[address(asset)].collateralFactorMantissa});\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Retrieves liquidation threshold for a market as an exponential\\r\\n     * @param asset Address for asset to liquidation threshold\\r\\n     * @return Liquidation threshold as exponential\\r\\n     */\\r\\n    function _getLiquidationThreshold(\\r\\n        LeToken asset\\r\\n    ) internal view returns (Exp memory) {\\r\\n        return\\r\\n            Exp({\\r\\n                mantissa: markets[address(asset)].liquidationThresholdMantissa\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Returns supply and borrow balances of user in leToken, reverts on failure\\r\\n     * @param leToken Market to query\\r\\n     * @param user Account address\\r\\n     * @return leTokenBalance Balance of leTokens, the same as leToken.balanceOf(user)\\r\\n     * @return borrowBalance Borrowed amount, including the interest\\r\\n     * @return exchangeRateMantissa Stored exchange rate\\r\\n     */\\r\\n    function _safeGetAccountSnapshot(\\r\\n        LeToken leToken,\\r\\n        address user\\r\\n    )\\r\\n        internal\\r\\n        view\\r\\n        returns (\\r\\n            uint256 leTokenBalance,\\r\\n            uint256 borrowBalance,\\r\\n            uint256 exchangeRateMantissa\\r\\n        )\\r\\n    {\\r\\n        uint256 err;\\r\\n        (err, leTokenBalance, borrowBalance, exchangeRateMantissa) = leToken\\r\\n            .getAccountSnapshot(user);\\r\\n        if (err != 0) {\\r\\n            revert SnapshotError(address(leToken), user);\\r\\n        }\\r\\n        return (leTokenBalance, borrowBalance, exchangeRateMantissa);\\r\\n    }\\r\\n\\r\\n    /// @notice Reverts if the call is not from expectedSender\\r\\n    /// @param expectedSender Expected transaction sender\\r\\n    function _checkSenderIs(address expectedSender) internal view {\\r\\n        if (msg.sender != expectedSender) {\\r\\n            revert UnexpectedSender(expectedSender, msg.sender);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /// @notice Reverts if a certain action is paused on a market\\r\\n    /// @param market Market to check\\r\\n    /// @param action Action to check\\r\\n    function _checkActionPauseState(\\r\\n        address market,\\r\\n        Action action\\r\\n    ) private view {\\r\\n        if (actionPaused(market, action)) {\\r\\n            revert ActionPaused(market, action);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x33ebe3b8a891aed93a6bfa0669e58177f2dd9a452ab3b3089542627eb94740b6\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport {LeToken} from \\\"./LeToken.sol\\\";\\r\\nimport {RewardsDistributor} from \\\"./Rewards/RewardsDistributor.sol\\\";\\r\\nimport {ResilientOracleInterface} from \\\"./access-controll/interfaces/OracleInterface.sol\\\";\\r\\n\\r\\nenum Action {\\r\\n    MINT,\\r\\n    REDEEM,\\r\\n    BORROW,\\r\\n    REPAY,\\r\\n    SEIZE,\\r\\n    LIQUIDATE,\\r\\n    TRANSFER,\\r\\n    ENTER_MARKET,\\r\\n    EXIT_MARKET\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ComptrollerInterface\\r\\n * @author LendLand\\r\\n * @notice Interface implemented by the `Comptroller` contract.\\r\\n */\\r\\ninterface ComptrollerInterface {\\r\\n    /*** Assets You Are In ***/\\r\\n\\r\\n    function enterMarkets(\\r\\n        address[] calldata leTokens\\r\\n    ) external returns (uint256[] memory);\\r\\n\\r\\n    function exitMarket(\\r\\n        address leToken,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external returns (uint256);\\r\\n\\r\\n    /*** Policy Hooks ***/\\r\\n\\r\\n    function preMintHook(\\r\\n        address leToken,\\r\\n        address minter,\\r\\n        uint256 mintAmount\\r\\n    ) external;\\r\\n\\r\\n    function preRedeemHook(\\r\\n        address leToken,\\r\\n        address redeemer,\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external;\\r\\n\\r\\n    function preBorrowHook(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external;\\r\\n\\r\\n    function preRepayHook(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external;\\r\\n\\r\\n    function preLiquidateHook(\\r\\n        address leTokenBorrowed,\\r\\n        address leTokenCollateral,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bool skipLiquidityCheck,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external;\\r\\n\\r\\n    function preSeizeHook(\\r\\n        address leTokenCollateral,\\r\\n        address leTokenBorrowed,\\r\\n        address liquidator,\\r\\n        address borrower\\r\\n    ) external;\\r\\n\\r\\n    function borrowVerify(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        uint borrowAmount\\r\\n    ) external;\\r\\n\\r\\n    function mintVerify(\\r\\n        address leToken,\\r\\n        address minter,\\r\\n        uint mintAmount,\\r\\n        uint mintTokens\\r\\n    ) external;\\r\\n\\r\\n    function redeemVerify(\\r\\n        address leToken,\\r\\n        address redeemer,\\r\\n        uint redeemAmount,\\r\\n        uint redeemTokens\\r\\n    ) external;\\r\\n\\r\\n    function repayBorrowVerify(\\r\\n        address leToken,\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        uint borrowerIndex\\r\\n    ) external;\\r\\n\\r\\n    function liquidateBorrowVerify(\\r\\n        address leTokenBorrowed,\\r\\n        address leTokenCollateral,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint repayAmount,\\r\\n        uint seizeTokens\\r\\n    ) external;\\r\\n\\r\\n    function seizeVerify(\\r\\n        address leTokenCollateral,\\r\\n        address leTokenBorrowed,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint seizeTokens\\r\\n    ) external;\\r\\n\\r\\n    function transferVerify(\\r\\n        address leToken,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint transferTokens\\r\\n    ) external;\\r\\n\\r\\n    function preTransferHook(\\r\\n        address leToken,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 transferTokens\\r\\n    ) external;\\r\\n\\r\\n    function isComptroller() external view returns (bool);\\r\\n\\r\\n    /*** Liquidity/Liquidation Calculations ***/\\r\\n\\r\\n    function liquidateCalculateSeizeTokens(\\r\\n        address leTokenBorrowed,\\r\\n        address leTokenCollateral,\\r\\n        uint256 repayAmount\\r\\n    ) external view returns (uint256, uint256);\\r\\n\\r\\n    function getAllMarkets() external view returns (LeToken[] memory);\\r\\n\\r\\n    function actionPaused(\\r\\n        address market,\\r\\n        Action action\\r\\n    ) external view returns (bool);\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title ComptrollerViewInterface\\r\\n * @author LendLand\\r\\n * @notice Interface implemented by the `Comptroller` contract, including only some util view functions.\\r\\n */\\r\\ninterface ComptrollerViewInterface {\\r\\n    function markets(address) external view returns (bool, uint256);\\r\\n\\r\\n    function oracle() external view returns (ResilientOracleInterface);\\r\\n\\r\\n    function getAssetsIn(address) external view returns (LeToken[] memory);\\r\\n\\r\\n    function closeFactorMantissa() external view returns (uint256);\\r\\n\\r\\n    function liquidationIncentiveMantissa() external view returns (uint256);\\r\\n\\r\\n    function minLiquidatableCollateral() external view returns (uint256);\\r\\n\\r\\n    function getRewardDistributors()\\r\\n        external\\r\\n        view\\r\\n        returns (RewardsDistributor[] memory);\\r\\n\\r\\n    function getAllMarkets() external view returns (LeToken[] memory);\\r\\n\\r\\n    function borrowCaps(address) external view returns (uint256);\\r\\n\\r\\n    function supplyCaps(address) external view returns (uint256);\\r\\n\\r\\n    function approvedDelegates(\\r\\n        address user,\\r\\n        address delegate\\r\\n    ) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x1df4959c66332e9a28e8d44e40ee19a561f50fe90111f51a5eba2285c4207f2f\",\"license\":\"BSD-3-Clause\"},\"contracts/ComptrollerStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport { ResilientOracleInterface } from \\\"./access-controll/interfaces/OracleInterface.sol\\\";\\r\\n\\r\\nimport { LeToken } from \\\"./LeToken.sol\\\";\\r\\nimport { RewardsDistributor } from \\\"./Rewards/RewardsDistributor.sol\\\";\\r\\nimport { IPrime } from \\\"./access-controll/IPrime.sol\\\";\\r\\nimport { Action } from \\\"./ComptrollerInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title ComptrollerStorage\\r\\n * @author LendLand\\r\\n * @notice Storage layout for the `Comptroller` contract.\\r\\n */\\r\\ncontract ComptrollerStorage {\\r\\n    struct LiquidationOrder {\\r\\n        LeToken leTokenCollateral;\\r\\n        LeToken leTokenBorrowed;\\r\\n        uint256 repayAmount;\\r\\n    }\\r\\n\\r\\n    struct AccountLiquiditySnapshot {\\r\\n        uint256 totalCollateral;\\r\\n        uint256 weightedCollateral;\\r\\n        uint256 borrows;\\r\\n        uint256 effects;\\r\\n        uint256 liquidity;\\r\\n        uint256 shortfall;\\r\\n    }\\r\\n\\r\\n    struct RewardSpeeds {\\r\\n        address rewardToken;\\r\\n        uint256 supplySpeed;\\r\\n        uint256 borrowSpeed;\\r\\n    }\\r\\n\\r\\n    struct Market {\\r\\n        // Whether or not this market is listed\\r\\n        bool isListed;\\r\\n        //  Multiplier representing the most one can borrow against their collateral in this market.\\r\\n        //  For instance, 0.9 to allow borrowing 90% of collateral value.\\r\\n        //  Must be between 0 and 1, and stored as a mantissa.\\r\\n        uint256 collateralFactorMantissa;\\r\\n        //  Multiplier representing the collateralization after which the borrow is eligible\\r\\n        //  for liquidation. For instance, 0.8 liquidate when the borrow is 80% of collateral\\r\\n        //  value. Must be between 0 and collateral factor, stored as a mantissa.\\r\\n        uint256 liquidationThresholdMantissa;\\r\\n        // Per-market mapping of \\\"accounts in this asset\\\"\\r\\n        mapping(address => bool) accountMembership;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Oracle which gives the price of any given asset\\r\\n     */\\r\\n    ResilientOracleInterface public oracle;\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\\r\\n     */\\r\\n    uint256 public closeFactorMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Multiplier representing the discount on collateral that a liquidator receives\\r\\n     */\\r\\n    uint256 public liquidationIncentiveMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Per-account mapping of \\\"assets you are in\\\"\\r\\n     */\\r\\n    mapping(address => LeToken[]) public accountAssets;\\r\\n\\r\\n    /**\\r\\n     * @notice Official mapping of leTokens -> Market metadata\\r\\n     * @dev Used e.g. to determine if a market is supported\\r\\n     */\\r\\n    mapping(address => Market) public markets;\\r\\n\\r\\n    /// @notice A list of all markets\\r\\n    LeToken[] public allMarkets;\\r\\n\\r\\n    /// @notice Borrow caps enforced by borrowAllowed for each leToken address. Defaults to zero which restricts borrowing.\\r\\n    mapping(address => uint256) public borrowCaps;\\r\\n\\r\\n    /// @notice Minimal collateral required for regular (non-batch) liquidations\\r\\n    uint256 public minLiquidatableCollateral;\\r\\n\\r\\n    /// @notice Supply caps enforced by mintAllowed for each leToken address. Defaults to zero which corresponds to minting not allowed\\r\\n    mapping(address => uint256) public supplyCaps;\\r\\n\\r\\n    /// @notice True if a certain action is paused on a certain market\\r\\n    mapping(address => mapping(Action => bool)) internal _actionPaused;\\r\\n\\r\\n    // List of Reward Distributors added\\r\\n    RewardsDistributor[] internal rewardsDistributors;\\r\\n\\r\\n    // Used to check if rewards distributor is added\\r\\n    mapping(address => bool) internal rewardsDistributorExists;\\r\\n\\r\\n    /// @notice Flag indicating whether forced liquidation enabled for a market\\r\\n    mapping(address => bool) public isForcedLiquidationEnabled;\\r\\n\\r\\n    uint256 internal constant NO_ERROR = 0;\\r\\n\\r\\n    // closeFactorMantissa must be strictly greater than this value\\r\\n    uint256 internal constant MIN_CLOSE_FACTOR_MANTISSA = 0.05e18; // 0.05\\r\\n\\r\\n    // closeFactorMantissa must not exceed this value\\r\\n    uint256 internal constant MAX_CLOSE_FACTOR_MANTISSA = 0.9e18; // 0.9\\r\\n\\r\\n    // No collateralFactorMantissa may exceed this value\\r\\n    uint256 internal constant MAX_COLLATERAL_FACTOR_MANTISSA = 0.9e18; // 0.9\\r\\n\\r\\n    /// Prime token address\\r\\n    IPrime public prime;\\r\\n\\r\\n    /// @notice Whether the delegate is allowed to borrow or redeem on behalf of the user\\r\\n    //mapping(address user => mapping (address delegate => bool approved)) public approvedDelegates;\\r\\n    mapping(address => mapping(address => bool)) public approvedDelegates;\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[47] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0xcae5c819839b8192e2931b504ad4eb60db255f91e28323959c9e9a182995baa0\",\"license\":\"BSD-3-Clause\"},\"contracts/ErrorReporter.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\n/**\\r\\n * @title TokenErrorReporter\\r\\n * @author LendLand\\r\\n * @notice Errors that can be thrown by the `LeToken` contract.\\r\\n */\\r\\ncontract TokenErrorReporter {\\r\\n    uint256 public constant NO_ERROR = 0; // support legacy return codes\\r\\n\\r\\n    error TransferNotAllowed();\\r\\n\\r\\n    error MintFreshnessCheck();\\r\\n\\r\\n    error RedeemFreshnessCheck();\\r\\n    error RedeemTransferOutNotPossible();\\r\\n\\r\\n    error BorrowFreshnessCheck();\\r\\n    error BorrowCashNotAvailable();\\r\\n    error DelegateNotApproved();\\r\\n\\r\\n    error RepayBorrowFreshnessCheck();\\r\\n\\r\\n    error HealBorrowUnauthorized();\\r\\n    error ForceLiquidateBorrowUnauthorized();\\r\\n\\r\\n    error LiquidateFreshnessCheck();\\r\\n    error LiquidateCollateralFreshnessCheck();\\r\\n    error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\\r\\n    error LiquidateLiquidatorIsBorrower();\\r\\n    error LiquidateCloseAmountIsZero();\\r\\n    error LiquidateCloseAmountIsUintMax();\\r\\n\\r\\n    error LiquidateSeizeLiquidatorIsBorrower();\\r\\n\\r\\n    error ProtocolSeizeShareTooBig();\\r\\n\\r\\n    error SetReserveFactorFreshCheck();\\r\\n    error SetReserveFactorBoundsCheck();\\r\\n\\r\\n    error AddReservesFactorFreshCheck(uint256 actualAddAmount);\\r\\n\\r\\n    error ReduceReservesFreshCheck();\\r\\n    error ReduceReservesCashNotAvailable();\\r\\n    error ReduceReservesCashValidation();\\r\\n\\r\\n    error SetInterestRateModelFreshCheck();\\r\\n}\\r\\n\",\"keccak256\":\"0x221c4ab5c10a9fdfb1264c92a5cd9460ba023206ad14f2177df7fee38755186d\",\"license\":\"BSD-3-Clause\"},\"contracts/ExponentialNoError.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport { EXP_SCALE as EXP_SCALE_, MANTISSA_ONE as MANTISSA_ONE_ } from \\\"./lib/constants.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title Exponential module for storing fixed-precision decimals\\r\\n * @author Compound\\r\\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\\r\\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\\r\\n *         `Exp({mantissa: 5100000000000000000})`.\\r\\n */\\r\\ncontract ExponentialNoError {\\r\\n    struct Exp {\\r\\n        uint256 mantissa;\\r\\n    }\\r\\n\\r\\n    struct Double {\\r\\n        uint256 mantissa;\\r\\n    }\\r\\n\\r\\n    uint256 internal constant EXP_SCALE = EXP_SCALE_;\\r\\n    uint256 internal constant DOUBLE_SCALE = 1e36;\\r\\n    uint256 internal constant HALF_EXP_SCALE = EXP_SCALE / 2;\\r\\n    uint256 internal constant MANTISSA_ONE = MANTISSA_ONE_;\\r\\n\\r\\n    /**\\r\\n     * @dev Truncates the given exp to a whole number value.\\r\\n     *      For example, truncate(Exp{mantissa: 15 * EXP_SCALE}) = 15\\r\\n     */\\r\\n    function truncate(Exp memory exp) internal pure returns (uint256) {\\r\\n        // Note: We are not using careful math here as we're performing a division that cannot fail\\r\\n        return exp.mantissa / EXP_SCALE;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function mul_ScalarTruncate(Exp memory a, uint256 scalar) internal pure returns (uint256) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return truncate(product);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\\r\\n     */\\r\\n    // solhint-disable-next-line func-name-mixedcase\\r\\n    function mul_ScalarTruncateAddUInt(Exp memory a, uint256 scalar, uint256 addend) internal pure returns (uint256) {\\r\\n        Exp memory product = mul_(a, scalar);\\r\\n        return add_(truncate(product), addend);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Checks if first Exp is less than second Exp.\\r\\n     */\\r\\n    function lessThanExp(Exp memory left, Exp memory right) internal pure returns (bool) {\\r\\n        return left.mantissa < right.mantissa;\\r\\n    }\\r\\n\\r\\n    function safe224(uint256 n, string memory errorMessage) internal pure returns (uint224) {\\r\\n        require(n <= type(uint224).max, errorMessage);\\r\\n        return uint224(n);\\r\\n    }\\r\\n\\r\\n    function safe32(uint256 n, string memory errorMessage) internal pure returns (uint32) {\\r\\n        require(n <= type(uint32).max, errorMessage);\\r\\n        return uint32(n);\\r\\n    }\\r\\n\\r\\n    function add_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({ mantissa: add_(a.mantissa, b.mantissa) });\\r\\n    }\\r\\n\\r\\n    function add_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: add_(a.mantissa, b.mantissa) });\\r\\n    }\\r\\n\\r\\n    function add_(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a + b;\\r\\n    }\\r\\n\\r\\n    function sub_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({ mantissa: sub_(a.mantissa, b.mantissa) });\\r\\n    }\\r\\n\\r\\n    function sub_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: sub_(a.mantissa, b.mantissa) });\\r\\n    }\\r\\n\\r\\n    function sub_(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a - b;\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({ mantissa: mul_(a.mantissa, b.mantissa) / EXP_SCALE });\\r\\n    }\\r\\n\\r\\n    function mul_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\r\\n        return Exp({ mantissa: mul_(a.mantissa, b) });\\r\\n    }\\r\\n\\r\\n    function mul_(uint256 a, Exp memory b) internal pure returns (uint256) {\\r\\n        return mul_(a, b.mantissa) / EXP_SCALE;\\r\\n    }\\r\\n\\r\\n    function mul_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: mul_(a.mantissa, b.mantissa) / DOUBLE_SCALE });\\r\\n    }\\r\\n\\r\\n    function mul_(Double memory a, uint256 b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: mul_(a.mantissa, b) });\\r\\n    }\\r\\n\\r\\n    function mul_(uint256 a, Double memory b) internal pure returns (uint256) {\\r\\n        return mul_(a, b.mantissa) / DOUBLE_SCALE;\\r\\n    }\\r\\n\\r\\n    function mul_(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a * b;\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, Exp memory b) internal pure returns (Exp memory) {\\r\\n        return Exp({ mantissa: div_(mul_(a.mantissa, EXP_SCALE), b.mantissa) });\\r\\n    }\\r\\n\\r\\n    function div_(Exp memory a, uint256 b) internal pure returns (Exp memory) {\\r\\n        return Exp({ mantissa: div_(a.mantissa, b) });\\r\\n    }\\r\\n\\r\\n    function div_(uint256 a, Exp memory b) internal pure returns (uint256) {\\r\\n        return div_(mul_(a, EXP_SCALE), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(Double memory a, Double memory b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: div_(mul_(a.mantissa, DOUBLE_SCALE), b.mantissa) });\\r\\n    }\\r\\n\\r\\n    function div_(Double memory a, uint256 b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: div_(a.mantissa, b) });\\r\\n    }\\r\\n\\r\\n    function div_(uint256 a, Double memory b) internal pure returns (uint256) {\\r\\n        return div_(mul_(a, DOUBLE_SCALE), b.mantissa);\\r\\n    }\\r\\n\\r\\n    function div_(uint256 a, uint256 b) internal pure returns (uint256) {\\r\\n        return a / b;\\r\\n    }\\r\\n\\r\\n    function fraction(uint256 a, uint256 b) internal pure returns (Double memory) {\\r\\n        return Double({ mantissa: div_(mul_(a, DOUBLE_SCALE), b) });\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1b6fe55a634bc784af9af45c25c14fdea3cf28a0aba79a1cea5547945ac47cab\",\"license\":\"BSD-3-Clause\"},\"contracts/InterestRateModel.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\n/**\\r\\n * @title Compound's InterestRateModel Interface\\r\\n * @author Compound\\r\\n */\\r\\nabstract contract InterestRateModel {\\r\\n    /**\\r\\n     * @notice Calculates the current borrow interest rate per block\\r\\n     * @param cash The total amount of cash the market has\\r\\n     * @param borrows The total amount of borrows the market has outstanding\\r\\n     * @param reserves The total amount of reserves the market has\\r\\n     * @param badDebt The amount of badDebt in the market\\r\\n     * @return The borrow rate per block (as a percentage, and scaled by 1e18)\\r\\n     */\\r\\n    function getBorrowRate(\\r\\n        uint256 cash,\\r\\n        uint256 borrows,\\r\\n        uint256 reserves,\\r\\n        uint256 badDebt\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the current supply interest rate per block\\r\\n     * @param cash The total amount of cash the market has\\r\\n     * @param borrows The total amount of borrows the market has outstanding\\r\\n     * @param reserves The total amount of reserves the market has\\r\\n     * @param reserveFactorMantissa The current reserve factor the market has\\r\\n     * @param badDebt The amount of badDebt in the market\\r\\n     * @return The supply rate per block (as a percentage, and scaled by 1e18)\\r\\n     */\\r\\n    function getSupplyRate(\\r\\n        uint256 cash,\\r\\n        uint256 borrows,\\r\\n        uint256 reserves,\\r\\n        uint256 reserveFactorMantissa,\\r\\n        uint256 badDebt\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Indicator that this is an InterestRateModel contract (for inspection)\\r\\n     * @return Always true\\r\\n     */\\r\\n    function isInterestRateModel() external pure virtual returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x03ec2088210f4aacaa6a8f17a05ede4aef75b99e00f42b58bdc900d621888961\",\"license\":\"BSD-3-Clause\"},\"contracts/LeToken.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport {Ownable2StepUpgradeable} from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport {SafeERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport {AccessControlledV8} from \\\"./access-controll/AccessControlledV8.sol\\\";\\r\\nimport {IProtocolShareReserve} from \\\"./access-controll/IProtocolShareReserve.sol\\\";\\r\\n\\r\\nimport {LeTokenInterface} from \\\"./LeTokenInterfaces.sol\\\";\\r\\nimport {ComptrollerInterface, ComptrollerViewInterface} from \\\"./ComptrollerInterface.sol\\\";\\r\\nimport {TokenErrorReporter} from \\\"./ErrorReporter.sol\\\";\\r\\nimport {InterestRateModel} from \\\"./InterestRateModel.sol\\\";\\r\\nimport {ExponentialNoError} from \\\"./ExponentialNoError.sol\\\";\\r\\nimport {ensureNonzeroAddress} from \\\"./lib/validators.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LeToken\\r\\n * @author LendLand\\r\\n * @notice Each asset that is supported by a pool is integrated through an instance of the `LeToken` contract. As outlined in the protocol overview,\\r\\n * each isolated pool creates its own `leToken` corresponding to an asset. Within a given pool, each included `leToken` is referred to as a market of\\r\\n * the pool. The main actions a user regularly interacts with in a market are:\\r\\n\\r\\n- mint/redeem of leTokens;\\r\\n- transfer of leTokens;\\r\\n- borrow/repay a loan on an underlying asset;\\r\\n- liquidate a borrow or liquidate/heal an account.\\r\\n\\r\\n * A user supplies the underlying asset to a pool by minting `leTokens`, where the corresponding `leToken` amount is determined by the `exchangeRate`.\\r\\n * The `exchangeRate` will change over time, dependent on a number of factors, some of which accrue interest. Additionally, once users have minted\\r\\n * `leToken` in a pool, they can borrow any asset in the isolated pool by using their `leToken` as collateral. In order to borrow an asset or use a `leToken`\\r\\n * as collateral, the user must be entered into each corresponding market (else, the `leToken` will not be considered collateral for a borrow). Note that\\r\\n * a user may borrow up to a portion of their collateral determined by the market\\u2019s collateral factor. However, if their borrowed amount exceeds an amount\\r\\n * calculated using the market\\u2019s corresponding liquidation threshold, the borrow is eligible for liquidation. When a user repays a borrow, they must also\\r\\n * pay off interest accrued on the borrow.\\r\\n * \\r\\n * The LendLand protocol includes unique mechanisms for healing an account and liquidating an account. These actions are performed in the `Comptroller`\\r\\n * and consider all borrows and collateral for which a given account is entered within a market. These functions may only be called on an account with a\\r\\n * total collateral amount that is no larger than a universal `minLiquidatableCollateral` value, which is used for all markets within a `Comptroller`.\\r\\n * Both functions settle all of an account\\u2019s borrows, but `healAccount()` may add `badDebt` to a leToken. For more detail, see the description of\\r\\n * `healAccount()` and `liquidateAccount()` in the `Comptroller` summary section below.\\r\\n */\\r\\ncontract LeToken is\\r\\n    Ownable2StepUpgradeable,\\r\\n    AccessControlledV8,\\r\\n    LeTokenInterface,\\r\\n    ExponentialNoError,\\r\\n    TokenErrorReporter\\r\\n{\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    uint256 internal constant DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA = 5e16; // 5%\\r\\n\\r\\n    /**\\r\\n     * Reentrancy Guard **\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\r\\n     */\\r\\n    modifier nonReentrant() {\\r\\n        require(_notEntered, \\\"re-entered\\\");\\r\\n        _notEntered = false;\\r\\n        _;\\r\\n        _notEntered = true; // get a gas-refund post-Istanbul\\r\\n    }\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor() {\\r\\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\\r\\n        // to set the state variables.\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Construct a new money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     * @param accessControlManager_ AccessControlManager contract address\\r\\n     * @param riskManagement Addresses of risk & income related contracts\\r\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when admin address is zero\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\r\\n     */\\r\\n    function initialize(\\r\\n        address underlying_,\\r\\n        ComptrollerInterface comptroller_,\\r\\n        InterestRateModel interestRateModel_,\\r\\n        uint256 initialExchangeRateMantissa_,\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        address admin_,\\r\\n        address accessControlManager_,\\r\\n        RiskManagementInit memory riskManagement,\\r\\n        uint256 reserveFactorMantissa_\\r\\n    ) external initializer {\\r\\n        ensureNonzeroAddress(admin_);\\r\\n\\r\\n        // Initialize the market\\r\\n        _initialize(\\r\\n            underlying_,\\r\\n            comptroller_,\\r\\n            interestRateModel_,\\r\\n            initialExchangeRateMantissa_,\\r\\n            name_,\\r\\n            symbol_,\\r\\n            decimals_,\\r\\n            admin_,\\r\\n            accessControlManager_,\\r\\n            riskManagement,\\r\\n            reserveFactorMantissa_\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return success True if the transfer succeeded, reverts otherwise\\r\\n     * @custom:event Emits Transfer event on success\\r\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function transfer(\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external override nonReentrant returns (bool) {\\r\\n        _transferTokens(msg.sender, msg.sender, dst, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `amount` tokens from `src` to `dst`\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param amount The number of tokens to transfer\\r\\n     * @return success True if the transfer succeeded, reverts otherwise\\r\\n     * @custom:event Emits Transfer event on success\\r\\n     * @custom:error TransferNotAllowed is thrown if trying to transfer to self\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function transferFrom(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external override nonReentrant returns (bool) {\\r\\n        _transferTokens(msg.sender, src, dst, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Approve `spender` to transfer up to `amount` from `src`\\r\\n     * @dev This will overwrite the approval amount for `spender`\\r\\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\\r\\n     * @return success Whether or not the approval succeeded\\r\\n     * @custom:event Emits Approval event\\r\\n     * @custom:access Not restricted\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\r\\n     */\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external override returns (bool) {\\r\\n        ensureNonzeroAddress(spender);\\r\\n\\r\\n        address src = msg.sender;\\r\\n        transferAllowances[src][spender] = amount;\\r\\n        emit Approval(src, spender, amount);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Increase approval for `spender`\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param addedValue The number of additional tokens spender can transfer\\r\\n     * @return success Whether or not the approval succeeded\\r\\n     * @custom:event Emits Approval event\\r\\n     * @custom:access Not restricted\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\r\\n     */\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint256 addedValue\\r\\n    ) external override returns (bool) {\\r\\n        ensureNonzeroAddress(spender);\\r\\n\\r\\n        address src = msg.sender;\\r\\n        uint256 newAllowance = transferAllowances[src][spender];\\r\\n        newAllowance += addedValue;\\r\\n        transferAllowances[src][spender] = newAllowance;\\r\\n\\r\\n        emit Approval(src, spender, newAllowance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Decreases approval for `spender`\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @param subtractedValue The number of tokens to remove from total approval\\r\\n     * @return success Whether or not the approval succeeded\\r\\n     * @custom:event Emits Approval event\\r\\n     * @custom:access Not restricted\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when spender address is zero\\r\\n     */\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint256 subtractedValue\\r\\n    ) external override returns (bool) {\\r\\n        ensureNonzeroAddress(spender);\\r\\n\\r\\n        address src = msg.sender;\\r\\n        uint256 currentAllowance = transferAllowances[src][spender];\\r\\n        require(\\r\\n            currentAllowance >= subtractedValue,\\r\\n            \\\"decreased allowance below zero\\\"\\r\\n        );\\r\\n        unchecked {\\r\\n            currentAllowance -= subtractedValue;\\r\\n        }\\r\\n\\r\\n        transferAllowances[src][spender] = currentAllowance;\\r\\n\\r\\n        emit Approval(src, spender, currentAllowance);\\r\\n        return true;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the underlying balance of the `owner`\\r\\n     * @dev This also accrues interest in a transaction\\r\\n     * @param owner The address of the account to query\\r\\n     * @return amount The amount of underlying owned by `owner`\\r\\n     */\\r\\n    function balanceOfUnderlying(\\r\\n        address owner\\r\\n    ) external override returns (uint256) {\\r\\n        Exp memory exchangeRate = Exp({mantissa: exchangeRateCurrent()});\\r\\n        return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current total borrows plus accrued interest\\r\\n     * @return totalBorrows The total borrows with interest\\r\\n     */\\r\\n    function totalBorrowsCurrent()\\r\\n        external\\r\\n        override\\r\\n        nonReentrant\\r\\n        returns (uint256)\\r\\n    {\\r\\n        accrueInterest();\\r\\n        return totalBorrows;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\\r\\n     * @param account The address whose balance should be calculated after updating borrowIndex\\r\\n     * @return borrowBalance The calculated balance\\r\\n     */\\r\\n    function borrowBalanceCurrent(\\r\\n        address account\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n        return _borrowBalanceStored(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender supplies assets into the market and receives leTokens in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function mint(\\r\\n        uint256 mintAmount\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        _mintFresh(msg.sender, msg.sender, mintAmount);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender calls on-behalf of minter. minter supplies assets into the market and receives leTokens in exchange\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param minter User whom the supply will be attributed to\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits Mint and Transfer events; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when minter address is zero\\r\\n     */\\r\\n    function mintBehalf(\\r\\n        address minter,\\r\\n        uint256 mintAmount\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        ensureNonzeroAddress(minter);\\r\\n\\r\\n        accrueInterest();\\r\\n\\r\\n        _mintFresh(msg.sender, minter, mintAmount);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems leTokens in exchange for the underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemTokens The number of leTokens to redeem into underlying\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\\r\\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function redeem(\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        _redeemFresh(msg.sender, msg.sender, redeemTokens, 0, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems assets on behalf of some other address. This function is only available\\r\\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemer The user on behalf of whom to redeem\\r\\n     * @param redeemTokens The number of leTokens to redeem into underlying\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:error InsufficientRedeemApproval is thrown when sender is not approved by the redeemer for the given amount\\r\\n     * @custom:error RedeemTransferOutNotPossible is thrown when the protocol has insufficient cash\\r\\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function redeemBehalf(\\r\\n        address redeemer,\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        _ensureSenderIsDelegateOf(redeemer);\\r\\n\\r\\n        accrueInterest();\\r\\n\\r\\n        _redeemFresh(redeemer, msg.sender, redeemTokens, 0, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems leTokens in exchange for a specified amount of underlying asset\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemAmount The amount of underlying to receive from redeeming leTokens\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     */\\r\\n    function redeemUnderlying(\\r\\n        uint256 redeemAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        _redeemFresh(msg.sender, msg.sender, 0, redeemAmount, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender redeems underlying assets on behalf of some other address. This function is only available\\r\\n     *   for senders, explicitly marked as delegates of the supplier using `comptroller.updateDelegate`\\r\\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\\r\\n     * @param redeemer, on behalf of whom to redeem\\r\\n     * @param redeemAmount The amount of underlying to receive from redeeming leTokens\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:error InsufficientRedeemApproval is thrown when sender is not approved by the redeemer for the given amount\\r\\n     * @custom:event Emits Redeem and Transfer events; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function redeemUnderlyingBehalf(\\r\\n        address redeemer,\\r\\n        uint256 redeemAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        _ensureSenderIsDelegateOf(redeemer);\\r\\n\\r\\n        accrueInterest();\\r\\n\\r\\n        _redeemFresh(redeemer, msg.sender, 0, redeemAmount, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender borrows assets from the protocol to their own address\\r\\n     * @param borrowAmount The amount of the underlying asset to borrow\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits Borrow event; may emit AccrueInterest\\r\\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function borrow(\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        _borrowFresh(msg.sender, msg.sender, borrowAmount, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender borrows assets on behalf of some other address. This function is only available\\r\\n     *   for senders, explicitly marked as delegates of the borrower using `comptroller.updateDelegate`\\r\\n     * @param borrower The borrower, on behalf of whom to borrow\\r\\n     * @param borrowAmount The amount of the underlying asset to borrow\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:error DelegateNotApproved is thrown if caller is not approved delegate\\r\\n     * @custom:error BorrowCashNotAvailable is thrown when the protocol has insufficient cash\\r\\n     * @custom:event Emits Borrow event; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function borrowBehalf(\\r\\n        address borrower,\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override returns (uint256) {\\r\\n        _ensureSenderIsDelegateOf(borrower);\\r\\n        accrueInterest();\\r\\n\\r\\n        _borrowFresh(borrower, msg.sender, borrowAmount, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays their own borrow\\r\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function repayBorrow(\\r\\n        uint256 repayAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        _repayBorrowFresh(msg.sender, msg.sender, repayAmount, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sender repays a borrow belonging to borrower\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount The amount to repay, or type(uint256).max for the full outstanding amount\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits RepayBorrow event; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function repayBorrowBehalf(\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant returns (uint256) {\\r\\n        accrueInterest();\\r\\n\\r\\n        _repayBorrowFresh(msg.sender, borrower, repayAmount, priceUpdateData);\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param borrower The borrower of this leToken to be liquidated\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @param leTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\r\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral leToken\\r\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral leToken\\r\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\r\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\r\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function liquidateBorrow(\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        LeTokenInterface leTokenCollateral,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override returns (uint256) {\\r\\n        _liquidateBorrow(\\r\\n            msg.sender,\\r\\n            borrower,\\r\\n            repayAmount,\\r\\n            leTokenCollateral,\\r\\n            false,\\r\\n            priceUpdateData\\r\\n        );\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice sets protocol share accumulated from liquidations\\r\\n     * @dev must be equal or less than liquidation incentive - 1\\r\\n     * @param newProtocolSeizeShareMantissa_ new protocol share mantissa\\r\\n     * @custom:event Emits NewProtocolSeizeShare event on success\\r\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\r\\n     * @custom:error ProtocolSeizeShareTooBig is thrown when the new seize share is too high\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setProtocolSeizeShare(\\r\\n        uint256 newProtocolSeizeShareMantissa_\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setProtocolSeizeShare(uint256)\\\");\\r\\n        uint256 liquidationIncentive = ComptrollerViewInterface(\\r\\n            address(comptroller)\\r\\n        ).liquidationIncentiveMantissa();\\r\\n        if (\\r\\n            newProtocolSeizeShareMantissa_ + MANTISSA_ONE > liquidationIncentive\\r\\n        ) {\\r\\n            revert ProtocolSeizeShareTooBig();\\r\\n        }\\r\\n\\r\\n        uint256 oldProtocolSeizeShareMantissa = protocolSeizeShareMantissa;\\r\\n        protocolSeizeShareMantissa = newProtocolSeizeShareMantissa_;\\r\\n        emit NewProtocolSeizeShare(\\r\\n            oldProtocolSeizeShareMantissa,\\r\\n            newProtocolSeizeShareMantissa_\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\\r\\n     * @dev Admin function to accrue interest and set a new reserve factor\\r\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\r\\n     * @custom:event Emits NewReserveFactor event; may emit AccrueInterest\\r\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\r\\n     * @custom:error SetReserveFactorBoundsCheck is thrown when the new reserve factor is too high\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setReserveFactor(\\r\\n        uint256 newReserveFactorMantissa\\r\\n    ) external override nonReentrant {\\r\\n        _checkAccessAllowed(\\\"setReserveFactor(uint256)\\\");\\r\\n\\r\\n        accrueInterest();\\r\\n        _setReserveFactorFresh(newReserveFactorMantissa);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrues interest and reduces reserves by transferring to the protocol reserve contract\\r\\n     * @dev Gracefully return if reserves already reduced in accrueInterest\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     * @custom:event Emits ReservesReduced event; may emit AccrueInterest\\r\\n     * @custom:error ReduceReservesCashNotAvailable is thrown when the leToken does not have sufficient cash\\r\\n     * @custom:error ReduceReservesCashValidation is thrown when trying to withdraw more cash than the reserves have\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function reduceReserves(\\r\\n        uint256 reduceAmount\\r\\n    ) external override nonReentrant {\\r\\n        accrueInterest();\\r\\n        if (reduceReservesBlockNumber == _getBlockNumber()) return;\\r\\n        _reduceReservesFresh(reduceAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender adds to reserves.\\r\\n     * @param addAmount The amount of underlying token to add as reserves\\r\\n     * @custom:event Emits ReservesAdded event; may emit AccrueInterest\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function addReserves(uint256 addAmount) external override nonReentrant {\\r\\n        accrueInterest();\\r\\n        _addReservesFresh(addAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\\r\\n     * @dev Admin function to accrue interest and update the interest rate model\\r\\n     * @param newInterestRateModel the new interest rate model to use\\r\\n     * @custom:event Emits NewMarketInterestRateModel event; may emit AccrueInterest\\r\\n     * @custom:error Unauthorized error is thrown when the call is not authorized by AccessControlManager\\r\\n     * @custom:access Controlled by AccessControlManager\\r\\n     */\\r\\n    function setInterestRateModel(\\r\\n        InterestRateModel newInterestRateModel\\r\\n    ) external override {\\r\\n        _checkAccessAllowed(\\\"setInterestRateModel(address)\\\");\\r\\n\\r\\n        accrueInterest();\\r\\n        _setInterestRateModelFresh(newInterestRateModel);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Repays a certain amount of debt, treats the rest of the borrow as bad debt, essentially\\r\\n     *   \\\"forgiving\\\" the borrower. Healing is a situation that should rarely happen. However, some pools\\r\\n     *   may list risky assets or be configured improperly \\u2013 we want to still handle such cases gracefully.\\r\\n     *   We assume that Comptroller does the seizing, so this function is only available to Comptroller.\\r\\n     * @dev This function does not call any Comptroller hooks (like \\\"healAllowed\\\"), because we assume\\r\\n     *   the Comptroller does all the necessary checks before calling this function.\\r\\n     * @param payer account who repays the debt\\r\\n     * @param borrower account to heal\\r\\n     * @param repayAmount amount to repay\\r\\n     * @custom:event Emits RepayBorrow, BadDebtIncreased events; may emit AccrueInterest\\r\\n     * @custom:error HealBorrowUnauthorized is thrown when the request does not come from Comptroller\\r\\n     * @custom:access Only Comptroller\\r\\n     */\\r\\n    function healBorrow(\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override nonReentrant {\\r\\n        if (repayAmount != 0) {\\r\\n            comptroller.preRepayHook(address(this), borrower, priceUpdateData);\\r\\n        }\\r\\n\\r\\n        if (msg.sender != address(comptroller)) {\\r\\n            revert HealBorrowUnauthorized();\\r\\n        }\\r\\n\\r\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\r\\n        uint256 totalBorrowsNew = totalBorrows;\\r\\n\\r\\n        uint256 actualRepayAmount;\\r\\n        if (repayAmount != 0) {\\r\\n            // _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n            // We violate checks-effects-interactions here to account for tokens that take transfer fees\\r\\n            actualRepayAmount = _doTransferIn(payer, repayAmount);\\r\\n            totalBorrowsNew = totalBorrowsNew - actualRepayAmount;\\r\\n            emit RepayBorrow(\\r\\n                payer,\\r\\n                borrower,\\r\\n                actualRepayAmount,\\r\\n                accountBorrowsPrev - actualRepayAmount,\\r\\n                totalBorrowsNew\\r\\n            );\\r\\n        }\\r\\n\\r\\n        // The transaction will fail if trying to repay too much\\r\\n        uint256 badDebtDelta = accountBorrowsPrev - actualRepayAmount;\\r\\n        if (badDebtDelta != 0) {\\r\\n            uint256 badDebtOld = badDebt;\\r\\n            uint256 badDebtNew = badDebtOld + badDebtDelta;\\r\\n            totalBorrowsNew = totalBorrowsNew - badDebtDelta;\\r\\n            badDebt = badDebtNew;\\r\\n\\r\\n            // We treat healing as \\\"repayment\\\", where leToken is the payer\\r\\n            emit RepayBorrow(\\r\\n                address(this),\\r\\n                borrower,\\r\\n                badDebtDelta,\\r\\n                0,\\r\\n                totalBorrowsNew\\r\\n            );\\r\\n            emit BadDebtIncreased(\\r\\n                borrower,\\r\\n                badDebtDelta,\\r\\n                badDebtOld,\\r\\n                badDebtNew\\r\\n            );\\r\\n        }\\r\\n\\r\\n        accountBorrows[borrower].principal = 0;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n\\r\\n        emit HealBorrow(payer, borrower, repayAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The extended version of liquidations, callable only by Comptroller. May skip\\r\\n     *  the close factor check. The collateral seized is transferred to the liquidator.\\r\\n     * @param liquidator The address repaying the borrow and seizing collateral\\r\\n     * @param borrower The borrower of this leToken to be liquidated\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @param leTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\r\\n     *   regardless of the account liquidity\\r\\n     * @custom:event Emits LiquidateBorrow event; may emit AccrueInterest\\r\\n     * @custom:error ForceLiquidateBorrowUnauthorized is thrown when the request does not come from Comptroller\\r\\n     * @custom:error LiquidateAccrueCollateralInterestFailed is thrown when it is not possible to accrue interest on the collateral leToken\\r\\n     * @custom:error LiquidateCollateralFreshnessCheck is thrown when interest has not been accrued on the collateral leToken\\r\\n     * @custom:error LiquidateLiquidatorIsBorrower is thrown when trying to liquidate self\\r\\n     * @custom:error LiquidateCloseAmountIsZero is thrown when repayment amount is zero\\r\\n     * @custom:error LiquidateCloseAmountIsUintMax is thrown when repayment amount is UINT_MAX\\r\\n     * @custom:access Only Comptroller\\r\\n     */\\r\\n    function forceLiquidateBorrow(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        LeTokenInterface leTokenCollateral,\\r\\n        bool skipLiquidityCheck,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external override {\\r\\n        if (msg.sender != address(comptroller)) {\\r\\n            revert ForceLiquidateBorrowUnauthorized();\\r\\n        }\\r\\n        _liquidateBorrow(\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            repayAmount,\\r\\n            leTokenCollateral,\\r\\n            skipLiquidityCheck,\\r\\n            priceUpdateData\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\r\\n     * @dev Will fail unless called by another leToken during the process of liquidation.\\r\\n     *  It's absolutely critical to use msg.sender as the borrowed leToken and not a parameter.\\r\\n     * @param liquidator The account receiving seized collateral\\r\\n     * @param borrower The account having collateral seized\\r\\n     * @param seizeTokens The number of leTokens to seize\\r\\n     * @custom:event Emits Transfer, ReservesAdded events\\r\\n     * @custom:error LiquidateSeizeLiquidatorIsBorrower is thrown when trying to liquidate self\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function seize(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 seizeTokens\\r\\n    ) external override nonReentrant {\\r\\n        _seize(msg.sender, liquidator, borrower, seizeTokens);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Updates bad debt\\r\\n     * @dev Called only when bad debt is recovered from auction\\r\\n     * @param recoveredAmount_ The amount of bad debt recovered\\r\\n     * @custom:event Emits BadDebtRecovered event\\r\\n     * @custom:access Only Shortfall contract\\r\\n     */\\r\\n    function badDebtRecovered(uint256 recoveredAmount_) external {\\r\\n        require(\\r\\n            msg.sender == shortfall,\\r\\n            \\\"only shortfall contract can update bad debt\\\"\\r\\n        );\\r\\n        require(\\r\\n            recoveredAmount_ <= badDebt,\\r\\n            \\\"more than bad debt recovered from auction\\\"\\r\\n        );\\r\\n\\r\\n        uint256 badDebtOld = badDebt;\\r\\n        uint256 badDebtNew = badDebtOld - recoveredAmount_;\\r\\n        badDebt = badDebtNew;\\r\\n\\r\\n        emit BadDebtRecovered(badDebtOld, badDebtNew);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets protocol share reserve contract address\\r\\n     * @param protocolShareReserve_ The address of the protocol share reserve contract\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when protocol share reserve address is zero\\r\\n     * @custom:access Only Governance\\r\\n     */\\r\\n    function setProtocolShareReserve(\\r\\n        address payable protocolShareReserve_\\r\\n    ) external onlyOwner {\\r\\n        _setProtocolShareReserve(protocolShareReserve_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets shortfall contract address\\r\\n     * @param shortfall_ The address of the shortfall contract\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when shortfall contract address is zero\\r\\n     * @custom:access Only Governance\\r\\n     */\\r\\n    function setShortfallContract(address shortfall_) external onlyOwner {\\r\\n        _setShortfallContract(shortfall_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\\r\\n     * @param token The address of the ERC-20 token to sweep\\r\\n     * @custom:access Only Governance\\r\\n     */\\r\\n    function sweepToken(IERC20Upgradeable token) external override {\\r\\n        require(\\r\\n            msg.sender == owner(),\\r\\n            \\\"LeToken::sweepToken: only admin can sweep tokens\\\"\\r\\n        );\\r\\n        require(\\r\\n            address(token) != underlying,\\r\\n            \\\"LeToken::sweepToken: can not sweep underlying token\\\"\\r\\n        );\\r\\n        uint256 balance = token.balanceOf(address(this));\\r\\n        token.safeTransfer(owner(), balance);\\r\\n\\r\\n        emit SweepToken(address(token));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice A public function to set new threshold of block difference after which funds will be sent to the protocol share reserve\\r\\n     * @param _newReduceReservesBlockDelta block difference value\\r\\n     * @custom:access Only Governance\\r\\n     */\\r\\n    function setReduceReservesBlockDelta(\\r\\n        uint256 _newReduceReservesBlockDelta\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setReduceReservesBlockDelta(uint256)\\\");\\r\\n        require(_newReduceReservesBlockDelta > 0, \\\"Invalid Input\\\");\\r\\n        emit NewReduceReservesBlockDelta(\\r\\n            reduceReservesBlockDelta,\\r\\n            _newReduceReservesBlockDelta\\r\\n        );\\r\\n        reduceReservesBlockDelta = _newReduceReservesBlockDelta;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the current allowance from `owner` for `spender`\\r\\n     * @param owner The address of the account which owns the tokens to be spent\\r\\n     * @param spender The address of the account which may transfer tokens\\r\\n     * @return amount The number of tokens allowed to be spent (type(uint256).max means infinite)\\r\\n     */\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view override returns (uint256) {\\r\\n        return transferAllowances[owner][spender];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get the token balance of the `owner`\\r\\n     * @param owner The address of the account to query\\r\\n     * @return amount The number of tokens owned by `owner`\\r\\n     */\\r\\n    function balanceOf(address owner) external view override returns (uint256) {\\r\\n        return accountTokens[owner];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\\r\\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\\r\\n     * @param account Address of the account to snapshot\\r\\n     * @return error Always NO_ERROR for compatibility with LendLand core tooling\\r\\n     * @return leTokenBalance User's balance of leTokens\\r\\n     * @return borrowBalance Amount owed in terms of underlying\\r\\n     * @return exchangeRate Stored exchange rate\\r\\n     */\\r\\n    function getAccountSnapshot(\\r\\n        address account\\r\\n    )\\r\\n        external\\r\\n        view\\r\\n        override\\r\\n        returns (\\r\\n            uint256 error,\\r\\n            uint256 leTokenBalance,\\r\\n            uint256 borrowBalance,\\r\\n            uint256 exchangeRate\\r\\n        )\\r\\n    {\\r\\n        return (\\r\\n            NO_ERROR,\\r\\n            accountTokens[account],\\r\\n            _borrowBalanceStored(account),\\r\\n            _exchangeRateStored()\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Get cash balance of this leToken in the underlying asset\\r\\n     * @return cash The quantity of underlying asset owned by this contract\\r\\n     */\\r\\n    function getCash() external view override returns (uint256) {\\r\\n        return _getCashPrior();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current per-block borrow interest rate for this leToken\\r\\n     * @return rate The borrow interest rate per block, scaled by 1e18\\r\\n     */\\r\\n    function borrowRatePerBlock() external view override returns (uint256) {\\r\\n        return\\r\\n            interestRateModel.getBorrowRate(\\r\\n                _getCashPrior(),\\r\\n                totalBorrows,\\r\\n                totalReserves,\\r\\n                badDebt\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the current per-block supply interest rate for this v\\r\\n     * @return rate The supply interest rate per block, scaled by 1e18\\r\\n     */\\r\\n    function supplyRatePerBlock() external view override returns (uint256) {\\r\\n        return\\r\\n            interestRateModel.getSupplyRate(\\r\\n                _getCashPrior(),\\r\\n                totalBorrows,\\r\\n                totalReserves,\\r\\n                reserveFactorMantissa,\\r\\n                badDebt\\r\\n            );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the borrow balance of account based on stored data\\r\\n     * @param account The address whose balance should be calculated\\r\\n     * @return borrowBalance The calculated balance\\r\\n     */\\r\\n    function borrowBalanceStored(\\r\\n        address account\\r\\n    ) external view override returns (uint256) {\\r\\n        return _borrowBalanceStored(account);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the exchange rate from the underlying to the LeToken\\r\\n     * @dev This function does not accrue interest before calculating the exchange rate\\r\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateStored() external view override returns (uint256) {\\r\\n        return _exchangeRateStored();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue interest then return the up-to-date exchange rate\\r\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function exchangeRateCurrent()\\r\\n        public\\r\\n        override\\r\\n        nonReentrant\\r\\n        returns (uint256)\\r\\n    {\\r\\n        accrueInterest();\\r\\n        return _exchangeRateStored();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Applies accrued interest to total borrows and reserves\\r\\n     * @dev This calculates interest accrued from the last checkpointed block\\r\\n     *  up to the current block and writes new checkpoint to storage and\\r\\n     *  reduce spread reserves to protocol share reserve\\r\\n     *  if currentBlock - reduceReservesBlockNumber >= blockDelta\\r\\n     * @return Always NO_ERROR\\r\\n     * @custom:event Emits AccrueInterest event on success\\r\\n     * @custom:access Not restricted\\r\\n     */\\r\\n    function accrueInterest() public virtual override returns (uint256) {\\r\\n        /* Remember the initial block number */\\r\\n        uint256 currentBlockNumber = _getBlockNumber();\\r\\n        uint256 accrualBlockNumberPrior = accrualBlockNumber;\\r\\n\\r\\n        /* Short-circuit accumulating 0 interest */\\r\\n        if (accrualBlockNumberPrior == currentBlockNumber) {\\r\\n            return NO_ERROR;\\r\\n        }\\r\\n\\r\\n        /* Read the previous values out of storage */\\r\\n        uint256 cashPrior = _getCashPrior();\\r\\n        uint256 borrowsPrior = totalBorrows;\\r\\n        uint256 reservesPrior = totalReserves;\\r\\n        uint256 borrowIndexPrior = borrowIndex;\\r\\n\\r\\n        /* Calculate the current borrow interest rate */\\r\\n        uint256 borrowRateMantissa = interestRateModel.getBorrowRate(\\r\\n            cashPrior,\\r\\n            borrowsPrior,\\r\\n            reservesPrior,\\r\\n            badDebt\\r\\n        );\\r\\n        require(\\r\\n            borrowRateMantissa <= MAX_BORROW_RATE_MANTISSA,\\r\\n            \\\"borrow rate is absurdly high\\\"\\r\\n        );\\r\\n\\r\\n        /* Calculate the number of blocks elapsed since the last accrual */\\r\\n        uint256 blockDelta = currentBlockNumber - accrualBlockNumberPrior;\\r\\n\\r\\n        /*\\r\\n         * Calculate the interest accumulated into borrows and reserves and the new index:\\r\\n         *  simpleInterestFactor = borrowRate * blockDelta\\r\\n         *  interestAccumulated = simpleInterestFactor * totalBorrows\\r\\n         *  totalBorrowsNew = interestAccumulated + totalBorrows\\r\\n         *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\\r\\n         *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\\r\\n         */\\r\\n\\r\\n        Exp memory simpleInterestFactor = mul_(\\r\\n            Exp({mantissa: borrowRateMantissa}),\\r\\n            blockDelta\\r\\n        );\\r\\n        uint256 interestAccumulated = mul_ScalarTruncate(\\r\\n            simpleInterestFactor,\\r\\n            borrowsPrior\\r\\n        );\\r\\n        uint256 totalBorrowsNew = interestAccumulated + borrowsPrior;\\r\\n        uint256 totalReservesNew = mul_ScalarTruncateAddUInt(\\r\\n            Exp({mantissa: reserveFactorMantissa}),\\r\\n            interestAccumulated,\\r\\n            reservesPrior\\r\\n        );\\r\\n        uint256 borrowIndexNew = mul_ScalarTruncateAddUInt(\\r\\n            simpleInterestFactor,\\r\\n            borrowIndexPrior,\\r\\n            borrowIndexPrior\\r\\n        );\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /* We write the previously calculated values into storage */\\r\\n        accrualBlockNumber = currentBlockNumber;\\r\\n        borrowIndex = borrowIndexNew;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        if (\\r\\n            currentBlockNumber - reduceReservesBlockNumber >=\\r\\n            reduceReservesBlockDelta\\r\\n        ) {\\r\\n            reduceReservesBlockNumber = currentBlockNumber;\\r\\n            if (cashPrior < totalReservesNew) {\\r\\n                _reduceReservesFresh(cashPrior);\\r\\n            } else {\\r\\n                _reduceReservesFresh(totalReservesNew);\\r\\n            }\\r\\n        }\\r\\n\\r\\n        /* We emit an AccrueInterest event */\\r\\n        emit AccrueInterest(\\r\\n            cashPrior,\\r\\n            interestAccumulated,\\r\\n            borrowIndexNew,\\r\\n            totalBorrowsNew\\r\\n        );\\r\\n\\r\\n        return NO_ERROR;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice User supplies assets into the market and receives leTokens in exchange\\r\\n     * @dev Assumes interest has already been accrued up to the current block\\r\\n     * @param payer The address of the account which is sending the assets for supply\\r\\n     * @param minter The address of the account which is supplying the assets\\r\\n     * @param mintAmount The amount of the underlying asset to supply\\r\\n     */\\r\\n    function _mintFresh(\\r\\n        address payer,\\r\\n        address minter,\\r\\n        uint256 mintAmount\\r\\n    ) internal {\\r\\n        /* Fail if mint not allowed */\\r\\n        comptroller.preMintHook(address(this), minter, mintAmount);\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert MintFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         *  We call `_doTransferIn` for the minter and the mintAmount.\\r\\n         *  `_doTransferIn` reverts if anything goes wrong, since we can't be sure if\\r\\n         *  side-effects occurred. The function returns the amount actually transferred,\\r\\n         *  in case of a fee. On success, the leToken holds an additional `actualMintAmount`\\r\\n         *  of cash.\\r\\n         */\\r\\n        uint256 actualMintAmount = _doTransferIn(payer, mintAmount);\\r\\n\\r\\n        /*\\r\\n         * We get the current exchange rate and calculate the number of leTokens to be minted:\\r\\n         *  mintTokens = actualMintAmount / exchangeRate\\r\\n         */\\r\\n\\r\\n        uint256 mintTokens = div_(actualMintAmount, exchangeRate);\\r\\n\\r\\n        /*\\r\\n         * We calculate the new total supply of leTokens and minter token balance, checking for overflow:\\r\\n         *  totalSupplyNew = totalSupply + mintTokens\\r\\n         *  accountTokensNew = accountTokens[minter] + mintTokens\\r\\n         * And write them into storage\\r\\n         */\\r\\n        totalSupply = totalSupply + mintTokens;\\r\\n        uint256 balanceAfter = accountTokens[minter] + mintTokens;\\r\\n        accountTokens[minter] = balanceAfter;\\r\\n\\r\\n        /* We emit a Mint event, and a Transfer event */\\r\\n        emit Mint(minter, actualMintAmount, mintTokens, balanceAfter);\\r\\n        emit Transfer(address(0), minter, mintTokens);\\r\\n\\r\\n        /* We call the defense and prime accrue interest hook */\\r\\n        comptroller.mintVerify(\\r\\n            address(this),\\r\\n            minter,\\r\\n            actualMintAmount,\\r\\n            mintTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Redeemer redeems leTokens in exchange for the underlying assets, transferred to the receiver. Redeemer and receiver can be the same\\r\\n     *   address, or different addresses if the receiver was previously approved by the redeemer as a valid delegate (see Comptroller.updateDelegate)\\r\\n     * @dev Assumes interest has already been accrued up to the current block\\r\\n     * @param redeemer The address of the account which is redeeming the tokens\\r\\n     * @param receiver The receiver of the underlying tokens\\r\\n     * @param redeemTokensIn The number of leTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\r\\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming leTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\\r\\n     */\\r\\n    function _redeemFresh(\\r\\n        address redeemer,\\r\\n        address receiver,\\r\\n        uint256 redeemTokensIn,\\r\\n        uint256 redeemAmountIn,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) internal {\\r\\n        require(\\r\\n            redeemTokensIn == 0 || redeemAmountIn == 0,\\r\\n            \\\"one of redeemTokensIn or redeemAmountIn must be zero\\\"\\r\\n        );\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert RedeemFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* exchangeRate = invoke Exchange Rate Stored() */\\r\\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\\r\\n\\r\\n        uint256 redeemTokens;\\r\\n        uint256 redeemAmount;\\r\\n\\r\\n        /* If redeemTokensIn > 0: */\\r\\n        if (redeemTokensIn > 0) {\\r\\n            /*\\r\\n             * We calculate the exchange rate and the amount of underlying to be redeemed:\\r\\n             *  redeemTokens = redeemTokensIn\\r\\n             */\\r\\n            redeemTokens = redeemTokensIn;\\r\\n        } else {\\r\\n            /*\\r\\n             * We get the current exchange rate and calculate the amount to be redeemed:\\r\\n             *  redeemTokens = redeemAmountIn / exchangeRate\\r\\n             */\\r\\n            redeemTokens = div_(redeemAmountIn, exchangeRate);\\r\\n\\r\\n            uint256 _redeemAmount = mul_(redeemTokens, exchangeRate);\\r\\n            if (_redeemAmount != 0 && _redeemAmount != redeemAmountIn)\\r\\n                redeemTokens++; // round up\\r\\n        }\\r\\n\\r\\n        // redeemAmount = exchangeRate * redeemTokens\\r\\n        redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokens);\\r\\n\\r\\n        // Revert if amount is zero\\r\\n        if (redeemAmount == 0) {\\r\\n            revert(\\\"redeemAmount is zero\\\");\\r\\n        }\\r\\n\\r\\n        /* Fail if redeem not allowed */\\r\\n        comptroller.preRedeemHook(\\r\\n            address(this),\\r\\n            redeemer,\\r\\n            redeemTokens,\\r\\n            priceUpdateData\\r\\n        );\\r\\n\\r\\n        /* Fail gracefully if protocol has insufficient cash */\\r\\n        if (_getCashPrior() - totalReserves < redeemAmount) {\\r\\n            revert RedeemTransferOutNotPossible();\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We write the previously calculated values into storage.\\r\\n         *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\\r\\n         */\\r\\n        totalSupply = totalSupply - redeemTokens;\\r\\n        uint256 balanceAfter = accountTokens[redeemer] - redeemTokens;\\r\\n        accountTokens[redeemer] = balanceAfter;\\r\\n\\r\\n        /*\\r\\n         * We invoke _doTransferOut for the receiver and the redeemAmount.\\r\\n         *  On success, the leToken has redeemAmount less of cash.\\r\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         */\\r\\n        _doTransferOut(receiver, redeemAmount);\\r\\n\\r\\n        /* We emit a Transfer event, and a Redeem event */\\r\\n        emit Transfer(redeemer, address(this), redeemTokens);\\r\\n        emit Redeem(redeemer, redeemAmount, redeemTokens, balanceAfter);\\r\\n\\r\\n        /* We call the defense and prime accrue interest hook */\\r\\n        comptroller.redeemVerify(\\r\\n            address(this),\\r\\n            redeemer,\\r\\n            redeemAmount,\\r\\n            redeemTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Users or their delegates borrow assets from the protocol\\r\\n     * @param borrower User who borrows the assets\\r\\n     * @param receiver The receiver of the tokens, if called by a delegate\\r\\n     * @param borrowAmount The amount of the underlying asset to borrow\\r\\n     */\\r\\n    function _borrowFresh(\\r\\n        address borrower,\\r\\n        address receiver,\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) internal {\\r\\n        /* Fail if borrow not allowed */\\r\\n        comptroller.preBorrowHook(\\r\\n            address(this),\\r\\n            borrower,\\r\\n            borrowAmount,\\r\\n            priceUpdateData\\r\\n        );\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert BorrowFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Fail gracefully if protocol has insufficient underlying cash */\\r\\n        if (_getCashPrior() - totalReserves < borrowAmount) {\\r\\n            revert BorrowCashNotAvailable();\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and total borrow balances, failing on overflow:\\r\\n         *  accountBorrowNew = accountBorrow + borrowAmount\\r\\n         *  totalBorrowsNew = totalBorrows + borrowAmount\\r\\n         */\\r\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\r\\n        uint256 accountBorrowsNew = accountBorrowsPrev + borrowAmount;\\r\\n        uint256 totalBorrowsNew = totalBorrows + borrowAmount;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We write the previously calculated values into storage.\\r\\n         *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\\r\\n        `*/\\r\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n\\r\\n        /*\\r\\n         * We invoke _doTransferOut for the receiver and the borrowAmount.\\r\\n         *  On success, the leToken borrowAmount less of cash.\\r\\n         *  _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         */\\r\\n        _doTransferOut(receiver, borrowAmount);\\r\\n\\r\\n        /* We emit a Borrow event */\\r\\n        emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\\r\\n\\r\\n        /* We call the defense and prime accrue interest hook */\\r\\n        comptroller.borrowVerify(address(this), borrower, borrowAmount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Borrows are repaid by another user (possibly the borrower).\\r\\n     * @param payer the account paying off the borrow\\r\\n     * @param borrower the account with the debt being payed off\\r\\n     * @param repayAmount the amount of underlying tokens being returned, or type(uint256).max for the full outstanding amount\\r\\n     * @return (uint) the actual repayment amount.\\r\\n     */\\r\\n    function _repayBorrowFresh(\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) internal returns (uint256) {\\r\\n        /* Fail if repayBorrow not allowed */\\r\\n        comptroller.preRepayHook(address(this), borrower, priceUpdateData);\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert RepayBorrowFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* We fetch the amount the borrower owes, with accumulated interest */\\r\\n        uint256 accountBorrowsPrev = _borrowBalanceStored(borrower);\\r\\n\\r\\n        uint256 repayAmountFinal = repayAmount >= accountBorrowsPrev\\r\\n            ? accountBorrowsPrev\\r\\n            : repayAmount;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /*\\r\\n         * We call _doTransferIn for the payer and the repayAmount\\r\\n         *  On success, the leToken holds an additional repayAmount of cash.\\r\\n         *  _doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n         *   it returns the amount actually transferred, in case of a fee.\\r\\n         */\\r\\n        uint256 actualRepayAmount = _doTransferIn(payer, repayAmountFinal);\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and total borrow balances, failing on underflow:\\r\\n         *  accountBorrowsNew = accountBorrows - actualRepayAmount\\r\\n         *  totalBorrowsNew = totalBorrows - actualRepayAmount\\r\\n         */\\r\\n        uint256 accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\\r\\n        uint256 totalBorrowsNew = totalBorrows - actualRepayAmount;\\r\\n\\r\\n        /* We write the previously calculated values into storage */\\r\\n        accountBorrows[borrower].principal = accountBorrowsNew;\\r\\n        accountBorrows[borrower].interestIndex = borrowIndex;\\r\\n        totalBorrows = totalBorrowsNew;\\r\\n\\r\\n        /* We emit a RepayBorrow event */\\r\\n        emit RepayBorrow(\\r\\n            payer,\\r\\n            borrower,\\r\\n            actualRepayAmount,\\r\\n            accountBorrowsNew,\\r\\n            totalBorrowsNew\\r\\n        );\\r\\n\\r\\n        /* We call the defense and prime accrue interest hook */\\r\\n        comptroller.repayBorrowVerify(\\r\\n            address(this),\\r\\n            payer,\\r\\n            borrower,\\r\\n            actualRepayAmount,\\r\\n            borrowIndex\\r\\n        );\\r\\n\\r\\n        return actualRepayAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The sender liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param liquidator The address repaying the borrow and seizing collateral\\r\\n     * @param borrower The borrower of this leToken to be liquidated\\r\\n     * @param leTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\r\\n     *   regardless of the account liquidity\\r\\n     */\\r\\n    function _liquidateBorrow(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        LeTokenInterface leTokenCollateral,\\r\\n        bool skipLiquidityCheck,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) internal nonReentrant {\\r\\n        accrueInterest();\\r\\n\\r\\n        uint256 error = leTokenCollateral.accrueInterest();\\r\\n        if (error != NO_ERROR) {\\r\\n            // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\\r\\n            revert LiquidateAccrueCollateralInterestFailed(error);\\r\\n        }\\r\\n\\r\\n        _liquidateBorrowFresh(\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            repayAmount,\\r\\n            leTokenCollateral,\\r\\n            skipLiquidityCheck,\\r\\n            priceUpdateData\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice The liquidator liquidates the borrowers collateral.\\r\\n     *  The collateral seized is transferred to the liquidator.\\r\\n     * @param liquidator The address repaying the borrow and seizing collateral\\r\\n     * @param borrower The borrower of this leToken to be liquidated\\r\\n     * @param leTokenCollateral The market in which to seize collateral from the borrower\\r\\n     * @param repayAmount The amount of the underlying borrowed asset to repay\\r\\n     * @param skipLiquidityCheck If set to true, allows to liquidate up to 100% of the borrow\\r\\n     *   regardless of the account liquidity\\r\\n     */\\r\\n    function _liquidateBorrowFresh(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        LeTokenInterface leTokenCollateral,\\r\\n        bool skipLiquidityCheck,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) internal {\\r\\n        /* Fail if liquidate not allowed */\\r\\n        comptroller.preLiquidateHook(\\r\\n            address(this),\\r\\n            address(leTokenCollateral),\\r\\n            borrower,\\r\\n            repayAmount,\\r\\n            skipLiquidityCheck,\\r\\n            priceUpdateData\\r\\n        );\\r\\n\\r\\n        /* Verify market's block number equals current block number */\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert LiquidateFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Verify leTokenCollateral market's block number equals current block number */\\r\\n        if (leTokenCollateral.accrualBlockNumber() != _getBlockNumber()) {\\r\\n            revert LiquidateCollateralFreshnessCheck();\\r\\n        }\\r\\n\\r\\n        /* Fail if borrower = liquidator */\\r\\n        if (borrower == liquidator) {\\r\\n            revert LiquidateLiquidatorIsBorrower();\\r\\n        }\\r\\n\\r\\n        /* Fail if repayAmount = 0 */\\r\\n        if (repayAmount == 0) {\\r\\n            revert LiquidateCloseAmountIsZero();\\r\\n        }\\r\\n\\r\\n        /* Fail if repayAmount = type(uint256).max */\\r\\n        if (repayAmount == type(uint256).max) {\\r\\n            revert LiquidateCloseAmountIsUintMax();\\r\\n        }\\r\\n\\r\\n        /* Fail if repayBorrow fails */\\r\\n        uint256 actualRepayAmount = _repayBorrowFresh(\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            repayAmount,\\r\\n            priceUpdateData\\r\\n        );\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /* We calculate the number of collateral tokens that will be seized */\\r\\n        (uint256 amountSeizeError, uint256 seizeTokens) = comptroller\\r\\n            .liquidateCalculateSeizeTokens(\\r\\n                address(this),\\r\\n                address(leTokenCollateral),\\r\\n                actualRepayAmount\\r\\n            );\\r\\n        require(\\r\\n            amountSeizeError == NO_ERROR,\\r\\n            \\\"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\\\"\\r\\n        );\\r\\n\\r\\n        /* Revert if borrower collateral token balance < seizeTokens */\\r\\n        require(\\r\\n            leTokenCollateral.balanceOf(borrower) >= seizeTokens,\\r\\n            \\\"LIQUIDATE_SEIZE_TOO_MUCH\\\"\\r\\n        );\\r\\n\\r\\n        // If this is also the collateral, call _seize internally to avoid re-entrancy, otherwise make an external call\\r\\n        if (address(leTokenCollateral) == address(this)) {\\r\\n            _seize(address(this), liquidator, borrower, seizeTokens);\\r\\n        } else {\\r\\n            leTokenCollateral.seize(liquidator, borrower, seizeTokens);\\r\\n        }\\r\\n\\r\\n        /* We emit a LiquidateBorrow event */\\r\\n        emit LiquidateBorrow(\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            actualRepayAmount,\\r\\n            address(leTokenCollateral),\\r\\n            seizeTokens\\r\\n        );\\r\\n\\r\\n        /* We call the defense and prime accrue interest hook */\\r\\n        comptroller.liquidateBorrowVerify(\\r\\n            address(this),\\r\\n            address(leTokenCollateral),\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            actualRepayAmount,\\r\\n            seizeTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfers collateral tokens (this market) to the liquidator.\\r\\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another LeToken.\\r\\n     *  It's absolutely critical to use msg.sender as the seizer leToken and not a parameter.\\r\\n     * @param seizerContract The contract seizing the collateral (either borrowed leToken or Comptroller)\\r\\n     * @param liquidator The account receiving seized collateral\\r\\n     * @param borrower The account having collateral seized\\r\\n     * @param seizeTokens The number of leTokens to seize\\r\\n     */\\r\\n    function _seize(\\r\\n        address seizerContract,\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 seizeTokens\\r\\n    ) internal {\\r\\n        /* Fail if seize not allowed */\\r\\n        comptroller.preSeizeHook(\\r\\n            address(this),\\r\\n            seizerContract,\\r\\n            liquidator,\\r\\n            borrower\\r\\n        );\\r\\n\\r\\n        /* Fail if borrower = liquidator */\\r\\n        if (borrower == liquidator) {\\r\\n            revert LiquidateSeizeLiquidatorIsBorrower();\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\\r\\n         *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\\r\\n         *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\\r\\n         */\\r\\n        uint256 liquidationIncentiveMantissa = ComptrollerViewInterface(\\r\\n            address(comptroller)\\r\\n        ).liquidationIncentiveMantissa();\\r\\n        uint256 numerator = mul_(\\r\\n            seizeTokens,\\r\\n            Exp({mantissa: protocolSeizeShareMantissa})\\r\\n        );\\r\\n        uint256 protocolSeizeTokens = div_(\\r\\n            numerator,\\r\\n            Exp({mantissa: liquidationIncentiveMantissa})\\r\\n        );\\r\\n        uint256 liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\\r\\n        Exp memory exchangeRate = Exp({mantissa: _exchangeRateStored()});\\r\\n        uint256 protocolSeizeAmount = mul_ScalarTruncate(\\r\\n            exchangeRate,\\r\\n            protocolSeizeTokens\\r\\n        );\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        /* We write the calculated values into storage */\\r\\n        totalSupply = totalSupply - protocolSeizeTokens;\\r\\n        accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\\r\\n        accountTokens[liquidator] =\\r\\n            accountTokens[liquidator] +\\r\\n            liquidatorSeizeTokens;\\r\\n\\r\\n        // _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n        // Transferring an underlying asset to the protocolShareReserve contract to channel the funds for different use.\\r\\n        _doTransferOut(protocolShareReserve, protocolSeizeAmount);\\r\\n\\r\\n        // Update the pool asset's state in the protocol share reserve for the above transfer.\\r\\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\\r\\n            address(comptroller),\\r\\n            underlying,\\r\\n            IProtocolShareReserve.IncomeType.LIQUIDATION\\r\\n        );\\r\\n\\r\\n        /* Emit a Transfer event */\\r\\n        emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\\r\\n        emit ProtocolSeize(borrower, protocolShareReserve, protocolSeizeAmount);\\r\\n\\r\\n        /* We call the defense and prime accrue interest hook */\\r\\n        comptroller.seizeVerify(\\r\\n            address(this),\\r\\n            seizerContract,\\r\\n            liquidator,\\r\\n            borrower,\\r\\n            seizeTokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _setComptroller(ComptrollerInterface newComptroller) internal {\\r\\n        ComptrollerInterface oldComptroller = comptroller;\\r\\n        // Ensure invoke comptroller.isComptroller() returns true\\r\\n        require(newComptroller.isComptroller(), \\\"marker method returned false\\\");\\r\\n\\r\\n        // Set market's comptroller to newComptroller\\r\\n        comptroller = newComptroller;\\r\\n\\r\\n        // Emit NewComptroller(oldComptroller, newComptroller)\\r\\n        emit NewComptroller(oldComptroller, newComptroller);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\\r\\n     * @dev Admin function to set a new reserve factor\\r\\n     * @param newReserveFactorMantissa New reserve factor (from 0 to 1e18)\\r\\n     */\\r\\n    function _setReserveFactorFresh(uint256 newReserveFactorMantissa) internal {\\r\\n        // Verify market's block number equals current block number\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert SetReserveFactorFreshCheck();\\r\\n        }\\r\\n\\r\\n        // Check newReserveFactor \\u2264 maxReserveFactor\\r\\n        if (newReserveFactorMantissa > MAX_RESERVE_FACTOR_MANTISSA) {\\r\\n            revert SetReserveFactorBoundsCheck();\\r\\n        }\\r\\n\\r\\n        uint256 oldReserveFactorMantissa = reserveFactorMantissa;\\r\\n        reserveFactorMantissa = newReserveFactorMantissa;\\r\\n\\r\\n        emit NewReserveFactor(\\r\\n            oldReserveFactorMantissa,\\r\\n            newReserveFactorMantissa\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add reserves by transferring from caller\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param addAmount Amount of addition to reserves\\r\\n     * @return actualAddAmount The actual amount added, excluding the potential token fees\\r\\n     */\\r\\n    function _addReservesFresh(uint256 addAmount) internal returns (uint256) {\\r\\n        // totalReserves + actualAddAmount\\r\\n        uint256 totalReservesNew;\\r\\n        uint256 actualAddAmount;\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert AddReservesFactorFreshCheck(actualAddAmount);\\r\\n        }\\r\\n\\r\\n        actualAddAmount = _doTransferIn(msg.sender, addAmount);\\r\\n        totalReservesNew = totalReserves + actualAddAmount;\\r\\n        totalReserves = totalReservesNew;\\r\\n        emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\\r\\n\\r\\n        return actualAddAmount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reduces reserves by transferring to the protocol reserve contract\\r\\n     * @dev Requires fresh interest accrual\\r\\n     * @param reduceAmount Amount of reduction to reserves\\r\\n     */\\r\\n    function _reduceReservesFresh(uint256 reduceAmount) internal {\\r\\n        if (reduceAmount == 0) {\\r\\n            return;\\r\\n        }\\r\\n        // totalReserves - reduceAmount\\r\\n        uint256 totalReservesNew;\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert ReduceReservesFreshCheck();\\r\\n        }\\r\\n\\r\\n        // Fail gracefully if protocol has insufficient underlying cash\\r\\n        if (_getCashPrior() < reduceAmount) {\\r\\n            revert ReduceReservesCashNotAvailable();\\r\\n        }\\r\\n\\r\\n        // Check reduceAmount \\u2264 reserves[n] (totalReserves)\\r\\n        if (reduceAmount > totalReserves) {\\r\\n            revert ReduceReservesCashValidation();\\r\\n        }\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n        // (No safe failures beyond this point)\\r\\n\\r\\n        totalReservesNew = totalReserves - reduceAmount;\\r\\n\\r\\n        // Store reserves[n+1] = reserves[n] - reduceAmount\\r\\n        totalReserves = totalReservesNew;\\r\\n\\r\\n        // _doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\\r\\n        // Transferring an underlying asset to the protocolShareReserve contract to channel the funds for different use.\\r\\n        _doTransferOut(protocolShareReserve, reduceAmount);\\r\\n\\r\\n        // Update the pool asset's state in the protocol share reserve for the above transfer.\\r\\n        IProtocolShareReserve(protocolShareReserve).updateAssetsState(\\r\\n            address(comptroller),\\r\\n            underlying,\\r\\n            IProtocolShareReserve.IncomeType.SPREAD\\r\\n        );\\r\\n\\r\\n        emit SpreadReservesReduced(\\r\\n            protocolShareReserve,\\r\\n            reduceAmount,\\r\\n            totalReservesNew\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice updates the interest rate model (*requires fresh interest accrual)\\r\\n     * @dev Admin function to update the interest rate model\\r\\n     * @param newInterestRateModel the new interest rate model to use\\r\\n     */\\r\\n    function _setInterestRateModelFresh(\\r\\n        InterestRateModel newInterestRateModel\\r\\n    ) internal {\\r\\n        // Used to store old model for use in the event that is emitted on success\\r\\n        InterestRateModel oldInterestRateModel;\\r\\n\\r\\n        // We fail gracefully unless market's block number equals current block number\\r\\n        if (accrualBlockNumber != _getBlockNumber()) {\\r\\n            revert SetInterestRateModelFreshCheck();\\r\\n        }\\r\\n\\r\\n        // Track the market's current interest rate model\\r\\n        oldInterestRateModel = interestRateModel;\\r\\n\\r\\n        // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\\r\\n        require(\\r\\n            newInterestRateModel.isInterestRateModel(),\\r\\n            \\\"marker method returned false\\\"\\r\\n        );\\r\\n\\r\\n        // Set the interest rate model to newInterestRateModel\\r\\n        interestRateModel = newInterestRateModel;\\r\\n\\r\\n        // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\\r\\n        emit NewMarketInterestRateModel(\\r\\n            oldInterestRateModel,\\r\\n            newInterestRateModel\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * Safe Token **\\r\\n     */\\r\\n\\r\\n    /**\\r\\n     * @dev Similar to ERC-20 transfer, but handles tokens that have transfer fees.\\r\\n     *      This function returns the actual amount received,\\r\\n     *      which may be less than `amount` if there is a fee attached to the transfer.\\r\\n     * @param from Sender of the underlying tokens\\r\\n     * @param amount Amount of underlying to transfer\\r\\n     * @return Actual amount received\\r\\n     */\\r\\n    function _doTransferIn(\\r\\n        address from,\\r\\n        uint256 amount\\r\\n    ) internal virtual returns (uint256) {\\r\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\r\\n        uint256 balanceBefore = token.balanceOf(address(this));\\r\\n        token.safeTransferFrom(from, address(this), amount);\\r\\n        uint256 balanceAfter = token.balanceOf(address(this));\\r\\n        // Return the amount that was *actually* transferred\\r\\n        return balanceAfter - balanceBefore;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Just a regular ERC-20 transfer, reverts on failure\\r\\n     * @param to Receiver of the underlying tokens\\r\\n     * @param amount Amount of underlying to transfer\\r\\n     */\\r\\n    function _doTransferOut(address to, uint256 amount) internal virtual {\\r\\n        IERC20Upgradeable token = IERC20Upgradeable(underlying);\\r\\n        token.safeTransfer(to, amount);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\\r\\n     * @dev Called by both `transfer` and `transferFrom` internally\\r\\n     * @param spender The address of the account performing the transfer\\r\\n     * @param src The address of the source account\\r\\n     * @param dst The address of the destination account\\r\\n     * @param tokens The number of tokens to transfer\\r\\n     */\\r\\n    function _transferTokens(\\r\\n        address spender,\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 tokens\\r\\n    ) internal {\\r\\n        /* Fail if transfer not allowed */\\r\\n        comptroller.preTransferHook(\\r\\n            address(this),\\r\\n            src,\\r\\n            dst,\\r\\n            tokens\\r\\n        );\\r\\n\\r\\n        /* Do not allow self-transfers */\\r\\n        if (src == dst) {\\r\\n            revert TransferNotAllowed();\\r\\n        }\\r\\n\\r\\n        /* Get the allowance, infinite for the account owner */\\r\\n        uint256 startingAllowance;\\r\\n        if (spender == src) {\\r\\n            startingAllowance = type(uint256).max;\\r\\n        } else {\\r\\n            startingAllowance = transferAllowances[src][spender];\\r\\n        }\\r\\n\\r\\n        /* Do the calculations, checking for {under,over}flow */\\r\\n        uint256 allowanceNew = startingAllowance - tokens;\\r\\n        uint256 srcTokensNew = accountTokens[src] - tokens;\\r\\n        uint256 dstTokensNew = accountTokens[dst] + tokens;\\r\\n\\r\\n        /////////////////////////\\r\\n        // EFFECTS & INTERACTIONS\\r\\n\\r\\n        accountTokens[src] = srcTokensNew;\\r\\n        accountTokens[dst] = dstTokensNew;\\r\\n\\r\\n        /* Eat some of the allowance (if necessary) */\\r\\n        if (startingAllowance != type(uint256).max) {\\r\\n            transferAllowances[src][spender] = allowanceNew;\\r\\n        }\\r\\n\\r\\n        /* We emit a Transfer event */\\r\\n        emit Transfer(src, dst, tokens);\\r\\n\\r\\n        comptroller.transferVerify(\\r\\n            address(this),\\r\\n            src,\\r\\n            dst,\\r\\n            tokens\\r\\n        );\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initialize the money market\\r\\n     * @param underlying_ The address of the underlying asset\\r\\n     * @param comptroller_ The address of the Comptroller\\r\\n     * @param interestRateModel_ The address of the interest rate model\\r\\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\\r\\n     * @param name_ ERC-20 name of this token\\r\\n     * @param symbol_ ERC-20 symbol of this token\\r\\n     * @param decimals_ ERC-20 decimal precision of this token\\r\\n     * @param admin_ Address of the administrator of this token\\r\\n     * @param accessControlManager_ AccessControlManager contract address\\r\\n     * @param riskManagement Addresses of risk & income related contracts\\r\\n     * @param reserveFactorMantissa_ Percentage of borrow interest that goes to reserves (from 0 to 1e18)\\r\\n     */\\r\\n    function _initialize(\\r\\n        address underlying_,\\r\\n        ComptrollerInterface comptroller_,\\r\\n        InterestRateModel interestRateModel_,\\r\\n        uint256 initialExchangeRateMantissa_,\\r\\n        string memory name_,\\r\\n        string memory symbol_,\\r\\n        uint8 decimals_,\\r\\n        address admin_,\\r\\n        address accessControlManager_,\\r\\n        RiskManagementInit memory riskManagement,\\r\\n        uint256 reserveFactorMantissa_\\r\\n    ) internal onlyInitializing {\\r\\n        __Ownable2Step_init();\\r\\n        __AccessControlled_init_unchained(accessControlManager_);\\r\\n        require(\\r\\n            accrualBlockNumber == 0 && borrowIndex == 0,\\r\\n            \\\"market may only be initialized once\\\"\\r\\n        );\\r\\n\\r\\n        // Set initial exchange rate\\r\\n        initialExchangeRateMantissa = initialExchangeRateMantissa_;\\r\\n        require(\\r\\n            initialExchangeRateMantissa > 0,\\r\\n            \\\"initial exchange rate must be greater than zero.\\\"\\r\\n        );\\r\\n\\r\\n        _setComptroller(comptroller_);\\r\\n\\r\\n        // Initialize block number and borrow index (block number mocks depend on comptroller being set)\\r\\n        accrualBlockNumber = _getBlockNumber();\\r\\n        borrowIndex = MANTISSA_ONE;\\r\\n\\r\\n        // Set the interest rate model (depends on block number / borrow index)\\r\\n        _setInterestRateModelFresh(interestRateModel_);\\r\\n\\r\\n        _setReserveFactorFresh(reserveFactorMantissa_);\\r\\n\\r\\n        name = name_;\\r\\n        symbol = symbol_;\\r\\n        decimals = decimals_;\\r\\n        _setShortfallContract(riskManagement.shortfall);\\r\\n        _setProtocolShareReserve(riskManagement.protocolShareReserve);\\r\\n        protocolSeizeShareMantissa = DEFAULT_PROTOCOL_SEIZE_SHARE_MANTISSA;\\r\\n\\r\\n        // Set underlying and sanity check it\\r\\n        underlying = underlying_;\\r\\n        IERC20Upgradeable(underlying).totalSupply();\\r\\n\\r\\n        // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\\r\\n        _notEntered = true;\\r\\n        _transferOwnership(admin_);\\r\\n    }\\r\\n\\r\\n    function _setShortfallContract(address shortfall_) internal {\\r\\n        ensureNonzeroAddress(shortfall_);\\r\\n        address oldShortfall = shortfall;\\r\\n        shortfall = shortfall_;\\r\\n        emit NewShortfallContract(oldShortfall, shortfall_);\\r\\n    }\\r\\n\\r\\n    function _setProtocolShareReserve(\\r\\n        address payable protocolShareReserve_\\r\\n    ) internal {\\r\\n        ensureNonzeroAddress(protocolShareReserve_);\\r\\n        address oldProtocolShareReserve = address(protocolShareReserve);\\r\\n        protocolShareReserve = protocolShareReserve_;\\r\\n        emit NewProtocolShareReserve(\\r\\n            oldProtocolShareReserve,\\r\\n            address(protocolShareReserve_)\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function _ensureSenderIsDelegateOf(address user) internal view {\\r\\n        if (\\r\\n            !ComptrollerViewInterface(address(comptroller)).approvedDelegates(\\r\\n                user,\\r\\n                msg.sender\\r\\n            )\\r\\n        ) {\\r\\n            revert DelegateNotApproved();\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Gets balance of this contract in terms of the underlying\\r\\n     * @dev This excludes the value of the current message, if any\\r\\n     * @return The quantity of underlying tokens owned by this contract\\r\\n     */\\r\\n    function _getCashPrior() internal view virtual returns (uint256) {\\r\\n        return IERC20Upgradeable(underlying).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Function to simply retrieve block number\\r\\n     *  This exists mainly for inheriting test contracts to stub this result.\\r\\n     * @return Current block number\\r\\n     */\\r\\n    function _getBlockNumber() internal view virtual returns (uint256) {\\r\\n        return block.number;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Return the borrow balance of account based on stored data\\r\\n     * @param account The address whose balance should be calculated\\r\\n     * @return borrowBalance the calculated balance\\r\\n     */\\r\\n    function _borrowBalanceStored(\\r\\n        address account\\r\\n    ) internal view returns (uint256) {\\r\\n        /* Get borrowBalance and borrowIndex */\\r\\n        BorrowSnapshot memory borrowSnapshot = accountBorrows[account];\\r\\n\\r\\n        /* If borrowBalance = 0 then borrowIndex is likely also 0.\\r\\n         * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\\r\\n         */\\r\\n        if (borrowSnapshot.principal == 0) {\\r\\n            return 0;\\r\\n        }\\r\\n\\r\\n        /* Calculate new borrow balance using the interest index:\\r\\n         *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\\r\\n         */\\r\\n        uint256 principalTimesIndex = borrowSnapshot.principal * borrowIndex;\\r\\n\\r\\n        return principalTimesIndex / borrowSnapshot.interestIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculates the exchange rate from the underlying to the LeToken\\r\\n     * @dev This function does not accrue interest before calculating the exchange rate\\r\\n     * @return exchangeRate Calculated exchange rate scaled by 1e18\\r\\n     */\\r\\n    function _exchangeRateStored() internal view virtual returns (uint256) {\\r\\n        uint256 _totalSupply = totalSupply;\\r\\n        if (_totalSupply == 0) {\\r\\n            /*\\r\\n             * If there are no tokens minted:\\r\\n             *  exchangeRate = initialExchangeRate\\r\\n             */\\r\\n            return initialExchangeRateMantissa;\\r\\n        }\\r\\n        /*\\r\\n         * Otherwise:\\r\\n         *  exchangeRate = (totalCash + totalBorrows + badDebt - totalReserves) / totalSupply\\r\\n         */\\r\\n        uint256 totalCash = _getCashPrior();\\r\\n        uint256 cashPlusBorrowsMinusReserves = totalCash +\\r\\n            totalBorrows +\\r\\n            badDebt -\\r\\n            totalReserves;\\r\\n        uint256 exchangeRate = (cashPlusBorrowsMinusReserves * EXP_SCALE) /\\r\\n            _totalSupply;\\r\\n\\r\\n        return exchangeRate;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xcbe5d57ab0f686cf1a81c9ee9c3aa0ea84b1edd5d1d695e820d2fa6ab85f1c33\",\"license\":\"BSD-3-Clause\"},\"contracts/LeTokenInterfaces.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport {IERC20Upgradeable} from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport {ResilientOracleInterface} from \\\"./access-controll/interfaces/OracleInterface.sol\\\";\\r\\n\\r\\nimport {ComptrollerInterface} from \\\"./ComptrollerInterface.sol\\\";\\r\\nimport {InterestRateModel} from \\\"./InterestRateModel.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title LeTokenStorage\\r\\n * @author LendLand\\r\\n * @notice Storage layout used by the `LeToken` contract\\r\\n */\\r\\n// solhint-disable-next-line max-states-count\\r\\ncontract LeTokenStorage {\\r\\n    /**\\r\\n     * @notice Container for borrow balance information\\r\\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\\r\\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\\r\\n     */\\r\\n    struct BorrowSnapshot {\\r\\n        uint256 principal;\\r\\n        uint256 interestIndex;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Guard variable for re-entrancy checks\\r\\n     */\\r\\n    bool internal _notEntered;\\r\\n\\r\\n    /**\\r\\n     * @notice Underlying asset for this LeToken\\r\\n     */\\r\\n    address public underlying;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token name for this token\\r\\n     */\\r\\n    string public name;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token symbol for this token\\r\\n     */\\r\\n    string public symbol;\\r\\n\\r\\n    /**\\r\\n     * @notice EIP-20 token decimals for this token\\r\\n     */\\r\\n    uint8 public decimals;\\r\\n\\r\\n    /**\\r\\n     * @notice Protocol share Reserve contract address\\r\\n     */\\r\\n    address payable public protocolShareReserve;\\r\\n\\r\\n    // Maximum borrow rate that can ever be applied (.0005% / block)\\r\\n    uint256 internal constant MAX_BORROW_RATE_MANTISSA = 0.0005e16;\\r\\n\\r\\n    // Maximum fraction of interest that can be set aside for reserves\\r\\n    uint256 internal constant MAX_RESERVE_FACTOR_MANTISSA = 1e18;\\r\\n\\r\\n    /**\\r\\n     * @notice Contract which oversees inter-leToken operations\\r\\n     */\\r\\n    ComptrollerInterface public comptroller;\\r\\n\\r\\n    /**\\r\\n     * @notice Model which tells what the current interest rate should be\\r\\n     */\\r\\n    InterestRateModel public interestRateModel;\\r\\n\\r\\n    // Initial exchange rate used when minting the first LeTokens (used when totalSupply = 0)\\r\\n    uint256 internal initialExchangeRateMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Fraction of interest currently set aside for reserves\\r\\n     */\\r\\n    uint256 public reserveFactorMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Block number that interest was last accrued at\\r\\n     */\\r\\n    uint256 public accrualBlockNumber;\\r\\n\\r\\n    /**\\r\\n     * @notice Accumulator of the total earned interest rate since the opening of the market\\r\\n     */\\r\\n    uint256 public borrowIndex;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of outstanding borrows of the underlying in this market\\r\\n     */\\r\\n    uint256 public totalBorrows;\\r\\n\\r\\n    /**\\r\\n     * @notice Total amount of reserves of the underlying held in this market\\r\\n     */\\r\\n    uint256 public totalReserves;\\r\\n\\r\\n    /**\\r\\n     * @notice Total number of tokens in circulation\\r\\n     */\\r\\n    uint256 public totalSupply;\\r\\n\\r\\n    /**\\r\\n     * @notice Total bad debt of the market\\r\\n     */\\r\\n    uint256 public badDebt;\\r\\n\\r\\n    // Official record of token balances for each account\\r\\n    mapping(address => uint256) internal accountTokens;\\r\\n\\r\\n    // Approved token transfer amounts on behalf of others\\r\\n    mapping(address => mapping(address => uint256)) internal transferAllowances;\\r\\n\\r\\n    // Mapping of account addresses to outstanding borrow balances\\r\\n    mapping(address => BorrowSnapshot) internal accountBorrows;\\r\\n\\r\\n    /**\\r\\n     * @notice Share of seized collateral that is added to reserves\\r\\n     */\\r\\n    uint256 public protocolSeizeShareMantissa;\\r\\n\\r\\n    /**\\r\\n     * @notice Storage of Shortfall contract address\\r\\n     */\\r\\n    address public shortfall;\\r\\n\\r\\n    /**\\r\\n     * @notice delta block after which reserves will be reduced\\r\\n     */\\r\\n    uint256 public reduceReservesBlockDelta;\\r\\n\\r\\n    /**\\r\\n     * @notice last block number at which reserves were reduced\\r\\n     */\\r\\n    uint256 public reduceReservesBlockNumber;\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[48] private __gap;\\r\\n}\\r\\n\\r\\n/**\\r\\n * @title LeTokenInterface\\r\\n * @author LendLand\\r\\n * @notice Interface implemented by the `LeToken` contract\\r\\n */\\r\\nabstract contract LeTokenInterface is LeTokenStorage {\\r\\n    struct RiskManagementInit {\\r\\n        address shortfall;\\r\\n        address payable protocolShareReserve;\\r\\n    }\\r\\n\\r\\n    /*** Market Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interest is accrued\\r\\n     */\\r\\n    event AccrueInterest(\\r\\n        uint256 cashPrior,\\r\\n        uint256 interestAccumulated,\\r\\n        uint256 borrowIndex,\\r\\n        uint256 totalBorrows\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are minted\\r\\n     */\\r\\n    event Mint(\\r\\n        address indexed minter,\\r\\n        uint256 mintAmount,\\r\\n        uint256 mintTokens,\\r\\n        uint256 accountBalance\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are redeemed\\r\\n     */\\r\\n    event Redeem(\\r\\n        address indexed redeemer,\\r\\n        uint256 redeemAmount,\\r\\n        uint256 redeemTokens,\\r\\n        uint256 accountBalance\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when underlying is borrowed\\r\\n     */\\r\\n    event Borrow(\\r\\n        address indexed borrower,\\r\\n        uint256 borrowAmount,\\r\\n        uint256 accountBorrows,\\r\\n        uint256 totalBorrows\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is repaid\\r\\n     */\\r\\n    event RepayBorrow(\\r\\n        address indexed payer,\\r\\n        address indexed borrower,\\r\\n        uint256 repayAmount,\\r\\n        uint256 accountBorrows,\\r\\n        uint256 totalBorrows\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when bad debt is accumulated on a market\\r\\n     * @param borrower borrower to \\\"forgive\\\"\\r\\n     * @param badDebtDelta amount of new bad debt recorded\\r\\n     * @param badDebtOld previous bad debt value\\r\\n     * @param badDebtNew new bad debt value\\r\\n     */\\r\\n    event BadDebtIncreased(\\r\\n        address indexed borrower,\\r\\n        uint256 badDebtDelta,\\r\\n        uint256 badDebtOld,\\r\\n        uint256 badDebtNew\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when bad debt is recovered via an auction\\r\\n     * @param badDebtOld previous bad debt value\\r\\n     * @param badDebtNew new bad debt value\\r\\n     */\\r\\n    event BadDebtRecovered(uint256 badDebtOld, uint256 badDebtNew);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when a borrow is liquidated\\r\\n     */\\r\\n    event LiquidateBorrow(\\r\\n        address indexed liquidator,\\r\\n        address indexed borrower,\\r\\n        uint256 repayAmount,\\r\\n        address indexed leTokenCollateral,\\r\\n        uint256 seizeTokens\\r\\n    );\\r\\n\\r\\n    /*** Admin Events ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when comptroller is changed\\r\\n     */\\r\\n    event NewComptroller(\\r\\n        ComptrollerInterface indexed oldComptroller,\\r\\n        ComptrollerInterface indexed newComptroller\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when shortfall contract address is changed\\r\\n     */\\r\\n    event NewShortfallContract(\\r\\n        address indexed oldShortfall,\\r\\n        address indexed newShortfall\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when protocol share reserve contract address is changed\\r\\n     */\\r\\n    event NewProtocolShareReserve(\\r\\n        address indexed oldProtocolShareReserve,\\r\\n        address indexed newProtocolShareReserve\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when interestRateModel is changed\\r\\n     */\\r\\n    event NewMarketInterestRateModel(\\r\\n        InterestRateModel indexed oldInterestRateModel,\\r\\n        InterestRateModel indexed newInterestRateModel\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when protocol seize share is changed\\r\\n     */\\r\\n    event NewProtocolSeizeShare(\\r\\n        uint256 oldProtocolSeizeShareMantissa,\\r\\n        uint256 newProtocolSeizeShareMantissa\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserve factor is changed\\r\\n     */\\r\\n    event NewReserveFactor(\\r\\n        uint256 oldReserveFactorMantissa,\\r\\n        uint256 newReserveFactorMantissa\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the reserves are added\\r\\n     */\\r\\n    event ReservesAdded(\\r\\n        address indexed benefactor,\\r\\n        uint256 addAmount,\\r\\n        uint256 newTotalReserves\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when the spread reserves are reduced\\r\\n     */\\r\\n    event SpreadReservesReduced(\\r\\n        address indexed protocolShareReserve,\\r\\n        uint256 reduceAmount,\\r\\n        uint256 newTotalReserves\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Transfer event\\r\\n     */\\r\\n    event Transfer(address indexed from, address indexed to, uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @notice EIP20 Approval event\\r\\n     */\\r\\n    event Approval(\\r\\n        address indexed owner,\\r\\n        address indexed spender,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when healing the borrow\\r\\n     */\\r\\n    event HealBorrow(\\r\\n        address indexed payer,\\r\\n        address indexed borrower,\\r\\n        uint256 repayAmount\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when tokens are swept\\r\\n     */\\r\\n    event SweepToken(address indexed token);\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when reduce reserves block delta is changed\\r\\n     */\\r\\n    event NewReduceReservesBlockDelta(\\r\\n        uint256 oldReduceReservesBlockDelta,\\r\\n        uint256 newReduceReservesBlockDelta\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Event emitted when liquidation reserves are reduced\\r\\n     */\\r\\n    event ProtocolSeize(\\r\\n        address indexed from,\\r\\n        address indexed to,\\r\\n        uint256 amount\\r\\n    );\\r\\n\\r\\n    /*** User Interface ***/\\r\\n\\r\\n    function mint(uint256 mintAmount) external virtual returns (uint256);\\r\\n\\r\\n    function mintBehalf(\\r\\n        address minter,\\r\\n        uint256 mintAllowed\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function redeem(\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function redeemBehalf(\\r\\n        address redeemer,\\r\\n        uint256 redeemTokens,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function redeemUnderlying(\\r\\n        uint256 redeemAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function redeemUnderlyingBehalf(\\r\\n        address redeemer,\\r\\n        uint256 redeemAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function borrow(\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function borrowBehalf(\\r\\n        address borrwwer,\\r\\n        uint256 borrowAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function repayBorrow(\\r\\n        uint256 repayAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function repayBorrowBehalf(\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function liquidateBorrow(\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        LeTokenInterface leTokenCollateral,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function healBorrow(\\r\\n        address payer,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual;\\r\\n\\r\\n    function forceLiquidateBorrow(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 repayAmount,\\r\\n        LeTokenInterface leTokenCollateral,\\r\\n        bool skipCloseFactorCheck,\\r\\n        bytes[] memory priceUpdateData\\r\\n    ) external virtual;\\r\\n\\r\\n    function seize(\\r\\n        address liquidator,\\r\\n        address borrower,\\r\\n        uint256 seizeTokens\\r\\n    ) external virtual;\\r\\n\\r\\n    function transfer(\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function transferFrom(\\r\\n        address src,\\r\\n        address dst,\\r\\n        uint256 amount\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function accrueInterest() external virtual returns (uint256);\\r\\n\\r\\n    function sweepToken(IERC20Upgradeable token) external virtual;\\r\\n\\r\\n    /*** Admin Functions ***/\\r\\n\\r\\n    function setReserveFactor(\\r\\n        uint256 newReserveFactorMantissa\\r\\n    ) external virtual;\\r\\n\\r\\n    function reduceReserves(uint256 reduceAmount) external virtual;\\r\\n\\r\\n    function exchangeRateCurrent() external virtual returns (uint256);\\r\\n\\r\\n    function borrowBalanceCurrent(\\r\\n        address account\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function setInterestRateModel(\\r\\n        InterestRateModel newInterestRateModel\\r\\n    ) external virtual;\\r\\n\\r\\n    function addReserves(uint256 addAmount) external virtual;\\r\\n\\r\\n    function totalBorrowsCurrent() external virtual returns (uint256);\\r\\n\\r\\n    function balanceOfUnderlying(\\r\\n        address owner\\r\\n    ) external virtual returns (uint256);\\r\\n\\r\\n    function approve(\\r\\n        address spender,\\r\\n        uint256 amount\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function increaseAllowance(\\r\\n        address spender,\\r\\n        uint256 addedValue\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function decreaseAllowance(\\r\\n        address spender,\\r\\n        uint256 subtractedValue\\r\\n    ) external virtual returns (bool);\\r\\n\\r\\n    function allowance(\\r\\n        address owner,\\r\\n        address spender\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function balanceOf(address owner) external view virtual returns (uint256);\\r\\n\\r\\n    function getAccountSnapshot(\\r\\n        address account\\r\\n    ) external view virtual returns (uint256, uint256, uint256, uint256);\\r\\n\\r\\n    function borrowRatePerBlock() external view virtual returns (uint256);\\r\\n\\r\\n    function supplyRatePerBlock() external view virtual returns (uint256);\\r\\n\\r\\n    function borrowBalanceStored(\\r\\n        address account\\r\\n    ) external view virtual returns (uint256);\\r\\n\\r\\n    function exchangeRateStored() external view virtual returns (uint256);\\r\\n\\r\\n    function getCash() external view virtual returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Indicator that this is a LeToken contract (for inspection)\\r\\n     * @return Always true\\r\\n     */\\r\\n    function isLeToken() external pure virtual returns (bool) {\\r\\n        return true;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0xfd8976b0bc59998476cb795361bd4499ed60f7f668a38072ac8ce4f3ac88914c\",\"license\":\"BSD-3-Clause\"},\"contracts/Lens/PoolLens.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\r\\nimport { IERC20Metadata } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\\\";\\r\\nimport { ResilientOracleInterface } from \\\"../access-controll/interfaces/OracleInterface.sol\\\";\\r\\n\\r\\nimport { ExponentialNoError } from \\\"../ExponentialNoError.sol\\\";\\r\\nimport { LeToken } from \\\"../LeToken.sol\\\";\\r\\nimport { Action, ComptrollerInterface, ComptrollerViewInterface } from \\\"../ComptrollerInterface.sol\\\";\\r\\nimport { PoolRegistryInterface } from \\\"../Pool/PoolRegistryInterface.sol\\\";\\r\\nimport { PoolRegistry } from \\\"../Pool/PoolRegistry.sol\\\";\\r\\nimport { RewardsDistributor } from \\\"../Rewards/RewardsDistributor.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title PoolLens\\r\\n * @author LendLand\\r\\n * @notice The `PoolLens` contract is designed to retrieve important information for each registered pool. A list of essential information\\r\\n * for all pools within the lending protocol can be acquired through the function `getAllPools()`. Additionally, the following records can be\\r\\n * looked up for specific pools and markets:\\r\\n- the leToken balance of a given user;\\r\\n- the pool data (oracle address, associated leToken, liquidation incentive, etc) of a pool via its associated comptroller address;\\r\\n- the leToken address in a pool for a given asset;\\r\\n- a list of all pools that support an asset;\\r\\n- the underlying asset price of a leToken;\\r\\n- the metadata (exchange/borrow/supply rate, total supply, collateral factor, etc) of any leToken.\\r\\n */\\r\\ncontract PoolLens is ExponentialNoError {\\r\\n    /**\\r\\n     * @dev Struct for PoolDetails.\\r\\n     */\\r\\n    struct PoolData {\\r\\n        string name;\\r\\n        address creator;\\r\\n        address comptroller;\\r\\n        uint256 blockPosted;\\r\\n        uint256 timestampPosted;\\r\\n        string category;\\r\\n        string logoURL;\\r\\n        string description;\\r\\n        address priceOracle;\\r\\n        uint256 closeFactor;\\r\\n        uint256 liquidationIncentive;\\r\\n        uint256 minLiquidatableCollateral;\\r\\n        LeTokenMetadata[] leTokens;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct for LeToken.\\r\\n     */\\r\\n    struct LeTokenMetadata {\\r\\n        address leToken;\\r\\n        uint256 exchangeRateCurrent;\\r\\n        uint256 supplyRatePerBlock;\\r\\n        uint256 borrowRatePerBlock;\\r\\n        uint256 reserveFactorMantissa;\\r\\n        uint256 supplyCaps;\\r\\n        uint256 borrowCaps;\\r\\n        uint256 totalBorrows;\\r\\n        uint256 totalReserves;\\r\\n        uint256 totalSupply;\\r\\n        uint256 totalCash;\\r\\n        bool isListed;\\r\\n        uint256 collateralFactorMantissa;\\r\\n        address underlyingAssetAddress;\\r\\n        uint256 leTokenDecimals;\\r\\n        uint256 underlyingDecimals;\\r\\n        uint256 pausedActions;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct for LeTokenBalance.\\r\\n     */\\r\\n    struct LeTokenBalances {\\r\\n        address leToken;\\r\\n        uint256 balanceOf;\\r\\n        uint256 borrowBalanceCurrent;\\r\\n        uint256 balanceOfUnderlying;\\r\\n        uint256 tokenBalance;\\r\\n        uint256 tokenAllowance;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct for underlyingPrice of LeToken.\\r\\n     */\\r\\n    struct LeTokenUnderlyingPrice {\\r\\n        address leToken;\\r\\n        uint256 underlyingPrice;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct with pending reward info for a market.\\r\\n     */\\r\\n    struct PendingReward {\\r\\n        address leTokenAddress;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct with reward distribution totals for a single reward token and distributor.\\r\\n     */\\r\\n    struct RewardSummary {\\r\\n        address distributorAddress;\\r\\n        address rewardTokenAddress;\\r\\n        uint256 totalRewards;\\r\\n        PendingReward[] pendingRewards;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct used in RewardDistributor to save last updated market state.\\r\\n     */\\r\\n    struct RewardTokenState {\\r\\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\\r\\n        uint224 index;\\r\\n        // The block number the index was last updated at\\r\\n        uint32 block;\\r\\n        // The block number at which to stop rewards\\r\\n        uint32 lastRewardingBlock;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct with bad debt of a market denominated\\r\\n     */\\r\\n    struct BadDebt {\\r\\n        address leTokenAddress;\\r\\n        uint256 badDebtUsd;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Struct with bad debt total denominated in usd for a pool and an array of BadDebt structs for each market\\r\\n     */\\r\\n    struct BadDebtSummary {\\r\\n        address comptroller;\\r\\n        uint256 totalBadDebtUsd;\\r\\n        BadDebt[] badDebts;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Queries the user's supply/borrow balances in leTokens\\r\\n     * @param leTokens The list of leToken addresses\\r\\n     * @param account The user Account\\r\\n     * @return A list of structs containing balances data\\r\\n     */\\r\\n    function leTokenBalancesAll(LeToken[] calldata leTokens, address account) external returns (LeTokenBalances[] memory) {\\r\\n        uint256 leTokenCount = leTokens.length;\\r\\n        LeTokenBalances[] memory res = new LeTokenBalances[](leTokenCount);\\r\\n        for (uint256 i; i < leTokenCount; ++i) {\\r\\n            res[i] = leTokenBalances(leTokens[i], account);\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Queries all pools with addtional details for each of them\\r\\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive\\r\\n     * @param poolRegistryAddress The address of the PoolRegistry contract\\r\\n     * @return Arrays of all LendLand pools' data\\r\\n     */\\r\\n    function getAllPools(address poolRegistryAddress) external view returns (PoolData[] memory) {\\r\\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\\r\\n        PoolRegistry.LendLandPool[] memory lendlandPools = poolRegistryInterface.getAllPools();\\r\\n        uint256 poolLength = lendlandPools.length;\\r\\n\\r\\n        PoolData[] memory poolDataItems = new PoolData[](poolLength);\\r\\n\\r\\n        for (uint256 i; i < poolLength; ++i) {\\r\\n            PoolRegistry.LendLandPool memory lendlandPool = lendlandPools[i];\\r\\n            PoolData memory poolData = getPoolDataFromLendLandPool(poolRegistryAddress, lendlandPool);\\r\\n            poolDataItems[i] = poolData;\\r\\n        }\\r\\n\\r\\n        return poolDataItems;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Queries the details of a pool identified by Comptroller address\\r\\n     * @param poolRegistryAddress The address of the PoolRegistry contract\\r\\n     * @param comptroller The Comptroller implementation address\\r\\n     * @return PoolData structure containing the details of the pool\\r\\n     */\\r\\n    function getPoolByComptroller(\\r\\n        address poolRegistryAddress,\\r\\n        address comptroller\\r\\n    ) external view returns (PoolData memory) {\\r\\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\\r\\n        return getPoolDataFromLendLandPool(poolRegistryAddress, poolRegistryInterface.getPoolByComptroller(comptroller));\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns leToken holding the specified underlying asset in the specified pool\\r\\n     * @param poolRegistryAddress The address of the PoolRegistry contract\\r\\n     * @param comptroller The pool comptroller\\r\\n     * @param asset The underlyingAsset of LeToken\\r\\n     * @return Address of the leToken\\r\\n     */\\r\\n    function getLeTokenForAsset(\\r\\n        address poolRegistryAddress,\\r\\n        address comptroller,\\r\\n        address asset\\r\\n    ) external view returns (address) {\\r\\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\\r\\n        return poolRegistryInterface.getLeTokenForAsset(comptroller, asset);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns all pools that support the specified underlying asset\\r\\n     * @param poolRegistryAddress The address of the PoolRegistry contract\\r\\n     * @param asset The underlying asset of leToken\\r\\n     * @return A list of Comptroller contracts\\r\\n     */\\r\\n    function getPoolsSupportedByAsset(\\r\\n        address poolRegistryAddress,\\r\\n        address asset\\r\\n    ) external view returns (address[] memory) {\\r\\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\\r\\n        return poolRegistryInterface.getPoolsSupportedByAsset(asset);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the price data for the underlying assets of the specified leTokens\\r\\n     * @param leTokens The list of leToken addresses\\r\\n     * @return An array containing the price data for each asset\\r\\n     */\\r\\n    function leTokenUnderlyingPriceAll(\\r\\n        LeToken[] calldata leTokens\\r\\n    ) external view returns (LeTokenUnderlyingPrice[] memory) {\\r\\n        uint256 leTokenCount = leTokens.length;\\r\\n        LeTokenUnderlyingPrice[] memory res = new LeTokenUnderlyingPrice[](leTokenCount);\\r\\n        for (uint256 i; i < leTokenCount; ++i) {\\r\\n            res[i] = leTokenUnderlyingPrice(leTokens[i]);\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the pending rewards for a user for a given pool.\\r\\n     * @param account The user account.\\r\\n     * @param comptrollerAddress address\\r\\n     * @return Pending rewards array\\r\\n     */\\r\\n    function getPendingRewards(\\r\\n        address account,\\r\\n        address comptrollerAddress\\r\\n    ) external view returns (RewardSummary[] memory) {\\r\\n        LeToken[] memory markets = ComptrollerInterface(comptrollerAddress).getAllMarkets();\\r\\n        RewardsDistributor[] memory rewardsDistributors = ComptrollerViewInterface(comptrollerAddress)\\r\\n            .getRewardDistributors();\\r\\n        RewardSummary[] memory rewardSummary = new RewardSummary[](rewardsDistributors.length);\\r\\n        for (uint256 i; i < rewardsDistributors.length; ++i) {\\r\\n            RewardSummary memory reward;\\r\\n            reward.distributorAddress = address(rewardsDistributors[i]);\\r\\n            reward.rewardTokenAddress = address(rewardsDistributors[i].rewardToken());\\r\\n            reward.totalRewards = rewardsDistributors[i].rewardTokenAccrued(account);\\r\\n            reward.pendingRewards = _calculateNotDistributedAwards(account, markets, rewardsDistributors[i]);\\r\\n            rewardSummary[i] = reward;\\r\\n        }\\r\\n        return rewardSummary;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns a summary of a pool's bad debt broken down by market\\r\\n     *\\r\\n     * @param comptrollerAddress Address of the comptroller\\r\\n     *\\r\\n     * @return badDebtSummary A struct with comptroller address, total bad debut denominated in usd, and\\r\\n     *   a break down of bad debt by market\\r\\n     */\\r\\n    function getPoolBadDebt(address comptrollerAddress) external view returns (BadDebtSummary memory) {\\r\\n        uint256 totalBadDebtUsd;\\r\\n\\r\\n        // Get every market in the pool\\r\\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(comptrollerAddress);\\r\\n        LeToken[] memory markets = comptroller.getAllMarkets();\\r\\n        ResilientOracleInterface priceOracle = comptroller.oracle();\\r\\n\\r\\n        BadDebt[] memory badDebts = new BadDebt[](markets.length);\\r\\n\\r\\n        BadDebtSummary memory badDebtSummary;\\r\\n        badDebtSummary.comptroller = comptrollerAddress;\\r\\n        badDebtSummary.badDebts = badDebts;\\r\\n\\r\\n        // // Calculate the bad debt is USD per market\\r\\n        for (uint256 i; i < markets.length; ++i) {\\r\\n            BadDebt memory badDebt;\\r\\n            badDebt.leTokenAddress = address(markets[i]);\\r\\n            badDebt.badDebtUsd =\\r\\n                (LeToken(address(markets[i])).badDebt() * priceOracle.getUnderlyingPrice(address(markets[i]))) /\\r\\n                EXP_SCALE;\\r\\n            badDebtSummary.badDebts[i] = badDebt;\\r\\n            totalBadDebtUsd = totalBadDebtUsd + badDebt.badDebtUsd;\\r\\n        }\\r\\n\\r\\n        badDebtSummary.totalBadDebtUsd = totalBadDebtUsd;\\r\\n\\r\\n        return badDebtSummary;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Queries the user's supply/borrow balances in the specified leToken\\r\\n     * @param leToken leToken address\\r\\n     * @param account The user Account\\r\\n     * @return A struct containing the balances data\\r\\n     */\\r\\n    function leTokenBalances(LeToken leToken, address account) public returns (LeTokenBalances memory) {\\r\\n        uint256 balanceOf = leToken.balanceOf(account);\\r\\n        uint256 borrowBalanceCurrent = leToken.borrowBalanceCurrent(account);\\r\\n        uint256 balanceOfUnderlying = leToken.balanceOfUnderlying(account);\\r\\n        uint256 tokenBalance;\\r\\n        uint256 tokenAllowance;\\r\\n\\r\\n        IERC20 underlying = IERC20(leToken.underlying());\\r\\n        tokenBalance = underlying.balanceOf(account);\\r\\n        tokenAllowance = underlying.allowance(account, address(leToken));\\r\\n\\r\\n        return\\r\\n            LeTokenBalances({\\r\\n                leToken: address(leToken),\\r\\n                balanceOf: balanceOf,\\r\\n                borrowBalanceCurrent: borrowBalanceCurrent,\\r\\n                balanceOfUnderlying: balanceOfUnderlying,\\r\\n                tokenBalance: tokenBalance,\\r\\n                tokenAllowance: tokenAllowance\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Queries additional information for the pool\\r\\n     * @param poolRegistryAddress Address of the PoolRegistry\\r\\n     * @param lendlandPool The LendLandPool Object from PoolRegistry\\r\\n     * @return Enriched PoolData\\r\\n     */\\r\\n    function getPoolDataFromLendLandPool(\\r\\n        address poolRegistryAddress,\\r\\n        PoolRegistry.LendLandPool memory lendlandPool\\r\\n    ) public view returns (PoolData memory) {\\r\\n        // Get tokens in the Pool\\r\\n        ComptrollerInterface comptrollerInstance = ComptrollerInterface(lendlandPool.comptroller);\\r\\n\\r\\n        LeToken[] memory leTokens = comptrollerInstance.getAllMarkets();\\r\\n\\r\\n        LeTokenMetadata[] memory leTokenMetadataItems = leTokenMetadataAll(leTokens);\\r\\n\\r\\n        PoolRegistryInterface poolRegistryInterface = PoolRegistryInterface(poolRegistryAddress);\\r\\n\\r\\n        PoolRegistry.LendLandPoolMetaData memory lendlandPoolMetaData = poolRegistryInterface.getLendLandPoolMetadata(\\r\\n            lendlandPool.comptroller\\r\\n        );\\r\\n\\r\\n        ComptrollerViewInterface comptrollerViewInstance = ComptrollerViewInterface(lendlandPool.comptroller);\\r\\n\\r\\n        PoolData memory poolData = PoolData({\\r\\n            name: lendlandPool.name,\\r\\n            creator: lendlandPool.creator,\\r\\n            comptroller: lendlandPool.comptroller,\\r\\n            blockPosted: lendlandPool.blockPosted,\\r\\n            timestampPosted: lendlandPool.timestampPosted,\\r\\n            category: lendlandPoolMetaData.category,\\r\\n            logoURL: lendlandPoolMetaData.logoURL,\\r\\n            description: lendlandPoolMetaData.description,\\r\\n            leTokens: leTokenMetadataItems,\\r\\n            priceOracle: address(comptrollerViewInstance.oracle()),\\r\\n            closeFactor: comptrollerViewInstance.closeFactorMantissa(),\\r\\n            liquidationIncentive: comptrollerViewInstance.liquidationIncentiveMantissa(),\\r\\n            minLiquidatableCollateral: comptrollerViewInstance.minLiquidatableCollateral()\\r\\n        });\\r\\n\\r\\n        return poolData;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the metadata of LeToken\\r\\n     * @param leToken The address of leToken\\r\\n     * @return LeTokenMetadata struct\\r\\n     */\\r\\n    function leTokenMetadata(LeToken leToken) public view returns (LeTokenMetadata memory) {\\r\\n        uint256 exchangeRateCurrent = leToken.exchangeRateStored();\\r\\n        address comptrollerAddress = address(leToken.comptroller());\\r\\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(comptrollerAddress);\\r\\n        (bool isListed, uint256 collateralFactorMantissa) = comptroller.markets(address(leToken));\\r\\n\\r\\n        address underlyingAssetAddress = leToken.underlying();\\r\\n        uint256 underlyingDecimals = IERC20Metadata(underlyingAssetAddress).decimals();\\r\\n\\r\\n        uint256 pausedActions;\\r\\n        for (uint8 i; i <= uint8(type(Action).max); ++i) {\\r\\n            uint256 paused = ComptrollerInterface(comptrollerAddress).actionPaused(address(leToken), Action(i)) ? 1 : 0;\\r\\n            pausedActions |= paused << i;\\r\\n        }\\r\\n\\r\\n        return\\r\\n            LeTokenMetadata({\\r\\n                leToken: address(leToken),\\r\\n                exchangeRateCurrent: exchangeRateCurrent,\\r\\n                supplyRatePerBlock: leToken.supplyRatePerBlock(),\\r\\n                borrowRatePerBlock: leToken.borrowRatePerBlock(),\\r\\n                reserveFactorMantissa: leToken.reserveFactorMantissa(),\\r\\n                supplyCaps: comptroller.supplyCaps(address(leToken)),\\r\\n                borrowCaps: comptroller.borrowCaps(address(leToken)),\\r\\n                totalBorrows: leToken.totalBorrows(),\\r\\n                totalReserves: leToken.totalReserves(),\\r\\n                totalSupply: leToken.totalSupply(),\\r\\n                totalCash: leToken.getCash(),\\r\\n                isListed: isListed,\\r\\n                collateralFactorMantissa: collateralFactorMantissa,\\r\\n                underlyingAssetAddress: underlyingAssetAddress,\\r\\n                leTokenDecimals: leToken.decimals(),\\r\\n                underlyingDecimals: underlyingDecimals,\\r\\n                pausedActions: pausedActions\\r\\n            });\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the metadata of all LeTokens\\r\\n     * @param leTokens The list of leToken addresses\\r\\n     * @return An array of LeTokenMetadata structs\\r\\n     */\\r\\n    function leTokenMetadataAll(LeToken[] memory leTokens) public view returns (LeTokenMetadata[] memory) {\\r\\n        uint256 leTokenCount = leTokens.length;\\r\\n        LeTokenMetadata[] memory res = new LeTokenMetadata[](leTokenCount);\\r\\n        for (uint256 i; i < leTokenCount; ++i) {\\r\\n            res[i] = leTokenMetadata(leTokens[i]);\\r\\n        }\\r\\n        return res;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the price data for the underlying asset of the specified leToken\\r\\n     * @param leToken leToken address\\r\\n     * @return The price data for each asset\\r\\n     */\\r\\n    function leTokenUnderlyingPrice(LeToken leToken) public view returns (LeTokenUnderlyingPrice memory) {\\r\\n        ComptrollerViewInterface comptroller = ComptrollerViewInterface(address(leToken.comptroller()));\\r\\n        ResilientOracleInterface priceOracle = comptroller.oracle();\\r\\n\\r\\n        return\\r\\n            LeTokenUnderlyingPrice({\\r\\n                leToken: address(leToken),\\r\\n                underlyingPrice: priceOracle.getUnderlyingPrice(address(leToken))\\r\\n            });\\r\\n    }\\r\\n\\r\\n    function _calculateNotDistributedAwards(\\r\\n        address account,\\r\\n        LeToken[] memory markets,\\r\\n        RewardsDistributor rewardsDistributor\\r\\n    ) internal view returns (PendingReward[] memory) {\\r\\n        PendingReward[] memory pendingRewards = new PendingReward[](markets.length);\\r\\n        for (uint256 i; i < markets.length; ++i) {\\r\\n            // Market borrow and supply state we will modify update in-memory, in order to not modify storage\\r\\n            RewardTokenState memory borrowState;\\r\\n            (borrowState.index, borrowState.block, borrowState.lastRewardingBlock) = rewardsDistributor\\r\\n                .rewardTokenBorrowState(address(markets[i]));\\r\\n            RewardTokenState memory supplyState;\\r\\n            (supplyState.index, supplyState.block, supplyState.lastRewardingBlock) = rewardsDistributor\\r\\n                .rewardTokenSupplyState(address(markets[i]));\\r\\n            Exp memory marketBorrowIndex = Exp({ mantissa: markets[i].borrowIndex() });\\r\\n\\r\\n            // Update market supply and borrow index in-memory\\r\\n            updateMarketBorrowIndex(address(markets[i]), rewardsDistributor, borrowState, marketBorrowIndex);\\r\\n            updateMarketSupplyIndex(address(markets[i]), rewardsDistributor, supplyState);\\r\\n\\r\\n            // Calculate pending rewards\\r\\n            uint256 borrowReward = calculateBorrowerReward(\\r\\n                address(markets[i]),\\r\\n                rewardsDistributor,\\r\\n                account,\\r\\n                borrowState,\\r\\n                marketBorrowIndex\\r\\n            );\\r\\n            uint256 supplyReward = calculateSupplierReward(\\r\\n                address(markets[i]),\\r\\n                rewardsDistributor,\\r\\n                account,\\r\\n                supplyState\\r\\n            );\\r\\n\\r\\n            PendingReward memory pendingReward;\\r\\n            pendingReward.leTokenAddress = address(markets[i]);\\r\\n            pendingReward.amount = borrowReward + supplyReward;\\r\\n            pendingRewards[i] = pendingReward;\\r\\n        }\\r\\n        return pendingRewards;\\r\\n    }\\r\\n\\r\\n    function updateMarketBorrowIndex(\\r\\n        address leToken,\\r\\n        RewardsDistributor rewardsDistributor,\\r\\n        RewardTokenState memory borrowState,\\r\\n        Exp memory marketBorrowIndex\\r\\n    ) internal view {\\r\\n        uint256 borrowSpeed = rewardsDistributor.rewardTokenBorrowSpeeds(leToken);\\r\\n        uint256 blockNumber = block.number;\\r\\n\\r\\n        if (borrowState.lastRewardingBlock > 0 && blockNumber > borrowState.lastRewardingBlock) {\\r\\n            blockNumber = borrowState.lastRewardingBlock;\\r\\n        }\\r\\n\\r\\n        uint256 deltaBlocks = sub_(blockNumber, uint256(borrowState.block));\\r\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\r\\n            // Remove the total earned interest rate since the opening of the market from total borrows\\r\\n            uint256 borrowAmount = div_(LeToken(leToken).totalBorrows(), marketBorrowIndex);\\r\\n            uint256 tokensAccrued = mul_(deltaBlocks, borrowSpeed);\\r\\n            Double memory ratio = borrowAmount > 0 ? fraction(tokensAccrued, borrowAmount) : Double({ mantissa: 0 });\\r\\n            Double memory index = add_(Double({ mantissa: borrowState.index }), ratio);\\r\\n            borrowState.index = safe224(index.mantissa, \\\"new index overflows\\\");\\r\\n            borrowState.block = safe32(blockNumber, \\\"block number overflows\\\");\\r\\n        } else if (deltaBlocks > 0) {\\r\\n            borrowState.block = safe32(blockNumber, \\\"block number overflows\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function updateMarketSupplyIndex(\\r\\n        address leToken,\\r\\n        RewardsDistributor rewardsDistributor,\\r\\n        RewardTokenState memory supplyState\\r\\n    ) internal view {\\r\\n        uint256 supplySpeed = rewardsDistributor.rewardTokenSupplySpeeds(leToken);\\r\\n        uint256 blockNumber = block.number;\\r\\n\\r\\n        if (supplyState.lastRewardingBlock > 0 && blockNumber > supplyState.lastRewardingBlock) {\\r\\n            blockNumber = supplyState.lastRewardingBlock;\\r\\n        }\\r\\n\\r\\n        uint256 deltaBlocks = sub_(blockNumber, uint256(supplyState.block));\\r\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\r\\n            uint256 supplyTokens = LeToken(leToken).totalSupply();\\r\\n            uint256 tokensAccrued = mul_(deltaBlocks, supplySpeed);\\r\\n            Double memory ratio = supplyTokens > 0 ? fraction(tokensAccrued, supplyTokens) : Double({ mantissa: 0 });\\r\\n            Double memory index = add_(Double({ mantissa: supplyState.index }), ratio);\\r\\n            supplyState.index = safe224(index.mantissa, \\\"new index overflows\\\");\\r\\n            supplyState.block = safe32(blockNumber, \\\"block number overflows\\\");\\r\\n        } else if (deltaBlocks > 0) {\\r\\n            supplyState.block = safe32(blockNumber, \\\"block number overflows\\\");\\r\\n        }\\r\\n    }\\r\\n\\r\\n    function calculateBorrowerReward(\\r\\n        address leToken,\\r\\n        RewardsDistributor rewardsDistributor,\\r\\n        address borrower,\\r\\n        RewardTokenState memory borrowState,\\r\\n        Exp memory marketBorrowIndex\\r\\n    ) internal view returns (uint256) {\\r\\n        Double memory borrowIndex = Double({ mantissa: borrowState.index });\\r\\n        Double memory borrowerIndex = Double({\\r\\n            mantissa: rewardsDistributor.rewardTokenBorrowerIndex(leToken, borrower)\\r\\n        });\\r\\n        if (borrowerIndex.mantissa == 0 && borrowIndex.mantissa >= rewardsDistributor.INITIAL_INDEX()) {\\r\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set\\r\\n            borrowerIndex.mantissa = rewardsDistributor.INITIAL_INDEX();\\r\\n        }\\r\\n        Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\\r\\n        uint256 borrowerAmount = div_(LeToken(leToken).borrowBalanceStored(borrower), marketBorrowIndex);\\r\\n        uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\r\\n        return borrowerDelta;\\r\\n    }\\r\\n\\r\\n    function calculateSupplierReward(\\r\\n        address leToken,\\r\\n        RewardsDistributor rewardsDistributor,\\r\\n        address supplier,\\r\\n        RewardTokenState memory supplyState\\r\\n    ) internal view returns (uint256) {\\r\\n        Double memory supplyIndex = Double({ mantissa: supplyState.index });\\r\\n        Double memory supplierIndex = Double({\\r\\n            mantissa: rewardsDistributor.rewardTokenSupplierIndex(leToken, supplier)\\r\\n        });\\r\\n        if (supplierIndex.mantissa == 0 && supplyIndex.mantissa >= rewardsDistributor.INITIAL_INDEX()) {\\r\\n            // Covers the case where users supplied tokens before the market's supply state index was set\\r\\n            supplierIndex.mantissa = rewardsDistributor.INITIAL_INDEX();\\r\\n        }\\r\\n        Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\\r\\n        uint256 supplierTokens = LeToken(leToken).balanceOf(supplier);\\r\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\r\\n        return supplierDelta;\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x0373291549a7f0ecc06df5386b8d743666559eb34d13c22e3327b938dd5823c2\",\"license\":\"BSD-3-Clause\"},\"contracts/MaxLoopsLimitHelper.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\n/**\\r\\n * @title MaxLoopsLimitHelper\\r\\n * @author LendLand\\r\\n * @notice Abstract contract used to avoid collection with too many items that would generate gas errors and DoS.\\r\\n */\\r\\nabstract contract MaxLoopsLimitHelper {\\r\\n    // Limit for the loops to avoid the DOS\\r\\n    uint256 public maxLoopsLimit;\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[49] private __gap;\\r\\n\\r\\n    /// @notice Emitted when max loops limit is set\\r\\n    event MaxLoopsLimitUpdated(uint256 oldMaxLoopsLimit, uint256 newmaxLoopsLimit);\\r\\n\\r\\n    /// @notice Thrown an error on maxLoopsLimit exceeds for any loop\\r\\n    error MaxLoopsLimitExceeded(uint256 loopsLimit, uint256 requiredLoops);\\r\\n\\r\\n    /**\\r\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\r\\n     * @param limit Limit for the max loops can execute at a time\\r\\n     */\\r\\n    function _setMaxLoopsLimit(uint256 limit) internal {\\r\\n        require(limit > maxLoopsLimit, \\\"Comptroller: Invalid maxLoopsLimit\\\");\\r\\n\\r\\n        uint256 oldMaxLoopsLimit = maxLoopsLimit;\\r\\n        maxLoopsLimit = limit;\\r\\n\\r\\n        emit MaxLoopsLimitUpdated(oldMaxLoopsLimit, limit);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Compare the maxLoopsLimit with number of the times loop iterate\\r\\n     * @param len Length of the loops iterate\\r\\n     * @custom:error MaxLoopsLimitExceeded error is thrown when loops length exceeds maxLoopsLimit\\r\\n     */\\r\\n    function _ensureMaxLoops(uint256 len) internal view {\\r\\n        if (len > maxLoopsLimit) {\\r\\n            revert MaxLoopsLimitExceeded(maxLoopsLimit, len);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x49fff4cf8ac7c9beb7b2b83699619cc3b11501ba84a35ecec2a7ecbde5807091\",\"license\":\"BSD-3-Clause\"},\"contracts/Pool/PoolRegistry.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport { AccessControlledV8 } from \\\"../access-controll/AccessControlledV8.sol\\\";\\r\\n\\r\\nimport { PoolRegistryInterface } from \\\"./PoolRegistryInterface.sol\\\";\\r\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\r\\nimport { LeToken } from \\\"../LeToken.sol\\\";\\r\\nimport { ensureNonzeroAddress } from \\\"../lib/validators.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title PoolRegistry\\r\\n * @author LendLand\\r\\n * @notice The Isolated Pools architecture centers around the `PoolRegistry` contract. The `PoolRegistry` maintains a directory of isolated lending\\r\\n * pools and can perform actions like creating and registering new pools, adding new markets to existing pools, setting and updating the pool's required\\r\\n * metadata, and providing the getter methods to get information on the pools.\\r\\n *\\r\\n * Isolated lending has three main components: PoolRegistry, pools, and markets. The PoolRegistry is responsible for managing pools.\\r\\n * It can create new pools, update pool metadata and manage markets within pools. PoolRegistry contains getter methods to get the details of\\r\\n * any existing pool like `getLeTokenForAsset` and `getPoolsSupportedByAsset`. It also contains methods for updating pool metadata (`updatePoolMetadata`)\\r\\n * and setting pool name (`setPoolName`).\\r\\n *\\r\\n * The directory of pools is managed through two mappings: `_poolByComptroller` which is a hashmap with the comptroller address as the key and `LendLandPool` as\\r\\n * the value and `_poolsByID` which is an array of comptroller addresses. Individual pools can be accessed by calling `getPoolByComptroller` with the pool's\\r\\n * comptroller address. `_poolsByID` is used to iterate through all of the pools.\\r\\n *\\r\\n * PoolRegistry also contains a map of asset addresses called `_supportedPools` that maps to an array of assets suppored by each pool. This array of pools by\\r\\n * asset is retrieved by calling `getPoolsSupportedByAsset`.\\r\\n *\\r\\n * PoolRegistry registers new isolated pools in the directory with the `createRegistryPool` method. Isolated pools are composed of independent markets with\\r\\n * specific assets and custom risk management configurations according to their markets.\\r\\n */\\r\\ncontract PoolRegistry is Ownable2StepUpgradeable, AccessControlledV8, PoolRegistryInterface {\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    struct AddMarketInput {\\r\\n        LeToken leToken;\\r\\n        uint256 collateralFactor;\\r\\n        uint256 liquidationThreshold;\\r\\n        uint256 initialSupply;\\r\\n        address leTokenReceiver;\\r\\n        uint256 supplyCap;\\r\\n        uint256 borrowCap;\\r\\n    }\\r\\n\\r\\n    uint256 internal constant MAX_POOL_NAME_LENGTH = 100;\\r\\n\\r\\n    /**\\r\\n     * @notice Maps pool's comptroller address to metadata.\\r\\n     */\\r\\n    mapping(address => LendLandPoolMetaData) public metadata;\\r\\n\\r\\n    /**\\r\\n     * @dev Maps pool ID to pool's comptroller address\\r\\n     */\\r\\n    mapping(uint256 => address) private _poolsByID;\\r\\n\\r\\n    /**\\r\\n     * @dev Total number of pools created.\\r\\n     */\\r\\n    uint256 private _numberOfPools;\\r\\n\\r\\n    /**\\r\\n     * @dev Maps comptroller address to LendLand pool Index.\\r\\n     */\\r\\n    mapping(address => LendLandPool) private _poolByComptroller;\\r\\n\\r\\n    /**\\r\\n     * @dev Maps pool's comptroller address to asset to leToken.\\r\\n     */\\r\\n    mapping(address => mapping(address => address)) private _leTokens;\\r\\n\\r\\n    /**\\r\\n     * @dev Maps asset to list of supported pools.\\r\\n     */\\r\\n    mapping(address => address[]) private _supportedPools;\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a new LendLand pool is added to the directory.\\r\\n     */\\r\\n    event PoolRegistered(address indexed comptroller, LendLandPool pool);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a pool name is set.\\r\\n     */\\r\\n    event PoolNameSet(address indexed comptroller, string oldName, string newName);\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a pool metadata is updated.\\r\\n     */\\r\\n    event PoolMetadataUpdated(\\r\\n        address indexed comptroller,\\r\\n        LendLandPoolMetaData oldMetadata,\\r\\n        LendLandPoolMetaData newMetadata\\r\\n    );\\r\\n\\r\\n    /**\\r\\n     * @notice Emitted when a Market is added to the pool.\\r\\n     */\\r\\n    event MarketAdded(address indexed comptroller, address indexed leTokenAddress);\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor() {\\r\\n        // Note that the contract is upgradeable. Use initialize() or reinitializers\\r\\n        // to set the state variables.\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Initializes the deployer to owner\\r\\n     * @param accessControlManager_ AccessControlManager contract address\\r\\n     */\\r\\n    function initialize(address accessControlManager_) external initializer {\\r\\n        __Ownable2Step_init();\\r\\n        __AccessControlled_init_unchained(accessControlManager_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Adds a new LendLand pool to the directory\\r\\n     * @dev Price oracle must be configured before adding a pool\\r\\n     * @param name The name of the pool\\r\\n     * @param comptroller Pool's Comptroller contract\\r\\n     * @param closeFactor The pool's close factor (scaled by 1e18)\\r\\n     * @param liquidationIncentive The pool's liquidation incentive (scaled by 1e18)\\r\\n     * @param minLiquidatableCollateral Minimal collateral for regular (non-batch) liquidations flow\\r\\n     * @return index The index of the registered LendLand pool\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when Comptroller address is zero\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when price oracle address is zero\\r\\n     */\\r\\n    function addPool(\\r\\n        string calldata name,\\r\\n        Comptroller comptroller,\\r\\n        uint256 closeFactor,\\r\\n        uint256 liquidationIncentive,\\r\\n        uint256 minLiquidatableCollateral\\r\\n    ) external virtual returns (uint256 index) {\\r\\n        _checkAccessAllowed(\\\"addPool(string,address,uint256,uint256,uint256)\\\");\\r\\n        // Input validation\\r\\n        ensureNonzeroAddress(address(comptroller));\\r\\n        ensureNonzeroAddress(address(comptroller.oracle()));\\r\\n\\r\\n        uint256 poolId = _registerPool(name, address(comptroller));\\r\\n\\r\\n        // Set LendLand pool parameters\\r\\n        comptroller.setCloseFactor(closeFactor);\\r\\n        comptroller.setLiquidationIncentive(liquidationIncentive);\\r\\n        comptroller.setMinLiquidatableCollateral(minLiquidatableCollateral);\\r\\n\\r\\n        return poolId;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Add a market to an existing pool and then mint to provide initial supply\\r\\n     * @param input The structure describing the parameters for adding a market to a pool\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when leToken address is zero\\r\\n     * @custom:error ZeroAddressNotAllowed is thrown when leTokenReceiver address is zero\\r\\n     */\\r\\n    function addMarket(AddMarketInput memory input) external {\\r\\n        _checkAccessAllowed(\\\"addMarket(AddMarketInput)\\\");\\r\\n        ensureNonzeroAddress(address(input.leToken));\\r\\n        ensureNonzeroAddress(input.leTokenReceiver);\\r\\n        require(input.initialSupply > 0, \\\"PoolRegistry: initialSupply is zero\\\");\\r\\n\\r\\n        LeToken leToken = input.leToken;\\r\\n        address leTokenAddress = address(leToken);\\r\\n        address comptrollerAddress = address(leToken.comptroller());\\r\\n        Comptroller comptroller = Comptroller(comptrollerAddress);\\r\\n        address underlyingAddress = leToken.underlying();\\r\\n        IERC20Upgradeable underlying = IERC20Upgradeable(underlyingAddress);\\r\\n\\r\\n        require(_poolByComptroller[comptrollerAddress].creator != address(0), \\\"PoolRegistry: Pool not registered\\\");\\r\\n        // solhint-disable-next-line reason-string\\r\\n        require(\\r\\n            _leTokens[comptrollerAddress][underlyingAddress] == address(0),\\r\\n            \\\"PoolRegistry: Market already added for asset comptroller combination\\\"\\r\\n        );\\r\\n\\r\\n        comptroller.supportMarket(leToken);\\r\\n        comptroller.setCollateralFactor(leToken, input.collateralFactor, input.liquidationThreshold);\\r\\n\\r\\n        uint256[] memory newSupplyCaps = new uint256[](1);\\r\\n        uint256[] memory newBorrowCaps = new uint256[](1);\\r\\n        LeToken[] memory leTokens = new LeToken[](1);\\r\\n\\r\\n        newSupplyCaps[0] = input.supplyCap;\\r\\n        newBorrowCaps[0] = input.borrowCap;\\r\\n        leTokens[0] = leToken;\\r\\n\\r\\n        comptroller.setMarketSupplyCaps(leTokens, newSupplyCaps);\\r\\n        comptroller.setMarketBorrowCaps(leTokens, newBorrowCaps);\\r\\n\\r\\n        _leTokens[comptrollerAddress][underlyingAddress] = leTokenAddress;\\r\\n        _supportedPools[underlyingAddress].push(comptrollerAddress);\\r\\n\\r\\n        uint256 amountToSupply = _transferIn(underlying, msg.sender, input.initialSupply);\\r\\n        underlying.forceApprove(leTokenAddress, 0);\\r\\n        underlying.forceApprove(leTokenAddress, amountToSupply);\\r\\n        leToken.mintBehalf(input.leTokenReceiver, amountToSupply);\\r\\n\\r\\n        emit MarketAdded(comptrollerAddress, leTokenAddress);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Modify existing LendLand pool name\\r\\n     * @param comptroller Pool's Comptroller\\r\\n     * @param name New pool name\\r\\n     */\\r\\n    function setPoolName(address comptroller, string calldata name) external {\\r\\n        _checkAccessAllowed(\\\"setPoolName(address,string)\\\");\\r\\n        _ensureValidName(name);\\r\\n        LendLandPool storage pool = _poolByComptroller[comptroller];\\r\\n        string memory oldName = pool.name;\\r\\n        pool.name = name;\\r\\n        emit PoolNameSet(comptroller, oldName, name);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Update metadata of an existing pool\\r\\n     * @param comptroller Pool's Comptroller\\r\\n     * @param metadata_ New pool metadata\\r\\n     */\\r\\n    function updatePoolMetadata(address comptroller, LendLandPoolMetaData calldata metadata_) external {\\r\\n        _checkAccessAllowed(\\\"updatePoolMetadata(address,LendLandPoolMetaData)\\\");\\r\\n        LendLandPoolMetaData memory oldMetadata = metadata[comptroller];\\r\\n        metadata[comptroller] = metadata_;\\r\\n        emit PoolMetadataUpdated(comptroller, oldMetadata, metadata_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns arrays of all LendLand pools' data\\r\\n     * @dev This function is not designed to be called in a transaction: it is too gas-intensive\\r\\n     * @return A list of all pools within PoolRegistry, with details for each pool\\r\\n     */\\r\\n    function getAllPools() external view override returns (LendLandPool[] memory) {\\r\\n        uint256 numberOfPools_ = _numberOfPools; // storage load to save gas\\r\\n        LendLandPool[] memory _pools = new LendLandPool[](numberOfPools_);\\r\\n        for (uint256 i = 1; i <= numberOfPools_; ++i) {\\r\\n            address comptroller = _poolsByID[i];\\r\\n            _pools[i - 1] = (_poolByComptroller[comptroller]);\\r\\n        }\\r\\n        return _pools;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param comptroller The comptroller proxy address associated to the pool\\r\\n     * @return  Returns LendLand pool\\r\\n     */\\r\\n    function getPoolByComptroller(address comptroller) external view override returns (LendLandPool memory) {\\r\\n        return _poolByComptroller[comptroller];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @param comptroller comptroller of LendLand pool\\r\\n     * @return Returns Metadata of LendLand pool\\r\\n     */\\r\\n    function getLendLandPoolMetadata(address comptroller) external view override returns (LendLandPoolMetaData memory) {\\r\\n        return metadata[comptroller];\\r\\n    }\\r\\n\\r\\n    function getLeTokenForAsset(address comptroller, address asset) external view override returns (address) {\\r\\n        return _leTokens[comptroller][asset];\\r\\n    }\\r\\n\\r\\n    function getPoolsSupportedByAsset(address asset) external view override returns (address[] memory) {\\r\\n        return _supportedPools[asset];\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Adds a new LendLand pool to the directory (without checking msg.sender).\\r\\n     * @param name The name of the pool\\r\\n     * @param comptroller The pool's Comptroller proxy contract address\\r\\n     * @return The index of the registered LendLand pool\\r\\n     */\\r\\n    function _registerPool(string calldata name, address comptroller) internal returns (uint256) {\\r\\n        LendLandPool storage storedPool = _poolByComptroller[comptroller];\\r\\n\\r\\n        require(storedPool.creator == address(0), \\\"PoolRegistry: Pool already exists in the directory.\\\");\\r\\n        _ensureValidName(name);\\r\\n\\r\\n        ++_numberOfPools;\\r\\n        uint256 numberOfPools_ = _numberOfPools; // cache on stack to save storage read gas\\r\\n\\r\\n        LendLandPool memory pool = LendLandPool(name, msg.sender, comptroller, block.number, block.timestamp);\\r\\n\\r\\n        _poolsByID[numberOfPools_] = comptroller;\\r\\n        _poolByComptroller[comptroller] = pool;\\r\\n\\r\\n        emit PoolRegistered(comptroller, pool);\\r\\n        return numberOfPools_;\\r\\n    }\\r\\n\\r\\n    function _transferIn(IERC20Upgradeable token, address from, uint256 amount) internal returns (uint256) {\\r\\n        uint256 balanceBefore = token.balanceOf(address(this));\\r\\n        token.safeTransferFrom(from, address(this), amount);\\r\\n        uint256 balanceAfter = token.balanceOf(address(this));\\r\\n        return balanceAfter - balanceBefore;\\r\\n    }\\r\\n\\r\\n    function _ensureValidName(string calldata name) internal pure {\\r\\n        require(bytes(name).length <= MAX_POOL_NAME_LENGTH, \\\"Pool's name is too large\\\");\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x28b1f796d5154680bdad5b4cf75a636dd6b7e494ad928f6c40f65c149cee5257\",\"license\":\"BSD-3-Clause\"},\"contracts/Pool/PoolRegistryInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\n/**\\r\\n * @title PoolRegistryInterface\\r\\n * @author LendLand\\r\\n * @notice Interface implemented by `PoolRegistry`.\\r\\n */\\r\\ninterface PoolRegistryInterface {\\r\\n    /**\\r\\n     * @notice Struct for a LendLand interest rate pool.\\r\\n     */\\r\\n    struct LendLandPool {\\r\\n        string name;\\r\\n        address creator;\\r\\n        address comptroller;\\r\\n        uint256 blockPosted;\\r\\n        uint256 timestampPosted;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Struct for a LendLand interest rate pool metadata.\\r\\n     */\\r\\n    struct LendLandPoolMetaData {\\r\\n        string category;\\r\\n        string logoURL;\\r\\n        string description;\\r\\n    }\\r\\n\\r\\n    /// @notice Get all pools in PoolRegistry\\r\\n    function getAllPools() external view returns (LendLandPool[] memory);\\r\\n\\r\\n    /// @notice Get a pool by comptroller address\\r\\n    function getPoolByComptroller(address comptroller) external view returns (LendLandPool memory);\\r\\n\\r\\n    /// @notice Get the address of the LeToken contract in the Pool where the underlying token is the provided asset\\r\\n    function getLeTokenForAsset(address comptroller, address asset) external view returns (address);\\r\\n\\r\\n    /// @notice Get the addresss of the Pools supported that include a market for the provided asset\\r\\n    function getPoolsSupportedByAsset(address asset) external view returns (address[] memory);\\r\\n\\r\\n    /// @notice Get the metadata of a Pool by comptroller address\\r\\n    function getLendLandPoolMetadata(address comptroller) external view returns (LendLandPoolMetaData memory);\\r\\n}\\r\\n\",\"keccak256\":\"0x9a8e8035d965109b71a3941d687601139270871c06f28b0fb0afc38ab81d28d2\",\"license\":\"BSD-3-Clause\"},\"contracts/Rewards/RewardsDistributor.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport { Ownable2StepUpgradeable } from \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\nimport { IERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\\\";\\r\\nimport { SafeERC20Upgradeable } from \\\"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\\\";\\r\\nimport { AccessControlledV8 } from \\\"../access-controll/AccessControlledV8.sol\\\";\\r\\n\\r\\nimport { ExponentialNoError } from \\\"../ExponentialNoError.sol\\\";\\r\\nimport { LeToken } from \\\"../LeToken.sol\\\";\\r\\nimport { Comptroller } from \\\"../Comptroller.sol\\\";\\r\\nimport { MaxLoopsLimitHelper } from \\\"../MaxLoopsLimitHelper.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title `RewardsDistributor`\\r\\n * @author LendLand\\r\\n * @notice Contract used to configure, track and distribute rewards to users based on their actions (borrows and supplies) in the protocol.\\r\\n * Users can receive additional rewards through a `RewardsDistributor`. Each `RewardsDistributor` proxy is initialized with a specific reward\\r\\n * token and `Comptroller`, which can then distribute the reward token to users that supply or borrow in the associated pool.\\r\\n * Authorized users can set the reward token borrow and supply speeds for each market in the pool. This sets a fixed amount of reward\\r\\n * token to be released each block for borrowers and suppliers, which is distributed based on a user\\u2019s percentage of the borrows or supplies\\r\\n * respectively. The owner can also set up reward distributions to contributor addresses (distinct from suppliers and borrowers) by setting\\r\\n * their contributor reward token speed, which similarly allocates a fixed amount of reward token per block.\\r\\n *\\r\\n * The owner has the ability to transfer any amount of reward tokens held by the contract to any other address. Rewards are not distributed\\r\\n * automatically and must be claimed by a user calling `claimRewardToken()`. Users should be aware that it is up to the owner and other centralized\\r\\n * entities to ensure that the `RewardsDistributor` holds enough tokens to distribute the accumulated rewards of users and contributors.\\r\\n */\\r\\ncontract RewardsDistributor is ExponentialNoError, Ownable2StepUpgradeable, AccessControlledV8, MaxLoopsLimitHelper {\\r\\n    using SafeERC20Upgradeable for IERC20Upgradeable;\\r\\n\\r\\n    struct RewardToken {\\r\\n        // The market's last updated rewardTokenBorrowIndex or rewardTokenSupplyIndex\\r\\n        uint224 index;\\r\\n        // The block number the index was last updated at\\r\\n        uint32 block;\\r\\n        // The block number at which to stop rewards\\r\\n        uint32 lastRewardingBlock;\\r\\n    }\\r\\n\\r\\n    /// @notice The initial REWARD TOKEN index for a market\\r\\n    uint224 public constant INITIAL_INDEX = 1e36;\\r\\n\\r\\n    /// @notice The REWARD TOKEN market supply state for each market\\r\\n    mapping(address => RewardToken) public rewardTokenSupplyState;\\r\\n\\r\\n    /// @notice The REWARD TOKEN borrow index for each market for each supplier as of the last time they accrued REWARD TOKEN\\r\\n    mapping(address => mapping(address => uint256)) public rewardTokenSupplierIndex;\\r\\n\\r\\n    /// @notice The REWARD TOKEN accrued but not yet transferred to each user\\r\\n    mapping(address => uint256) public rewardTokenAccrued;\\r\\n\\r\\n    /// @notice The rate at which rewardToken is distributed to the corresponding borrow market (per block)\\r\\n    mapping(address => uint256) public rewardTokenBorrowSpeeds;\\r\\n\\r\\n    /// @notice The rate at which rewardToken is distributed to the corresponding supply market (per block)\\r\\n    mapping(address => uint256) public rewardTokenSupplySpeeds;\\r\\n\\r\\n    /// @notice The REWARD TOKEN market borrow state for each market\\r\\n    mapping(address => RewardToken) public rewardTokenBorrowState;\\r\\n\\r\\n    /// @notice The portion of REWARD TOKEN that each contributor receives per block\\r\\n    mapping(address => uint256) public rewardTokenContributorSpeeds;\\r\\n\\r\\n    /// @notice Last block at which a contributor's REWARD TOKEN rewards have been allocated\\r\\n    mapping(address => uint256) public lastContributorBlock;\\r\\n\\r\\n    /// @notice The REWARD TOKEN borrow index for each market for each borrower as of the last time they accrued REWARD TOKEN\\r\\n    mapping(address => mapping(address => uint256)) public rewardTokenBorrowerIndex;\\r\\n\\r\\n    Comptroller private comptroller;\\r\\n\\r\\n    IERC20Upgradeable public rewardToken;\\r\\n\\r\\n    /// @notice Emitted when REWARD TOKEN is distributed to a supplier\\r\\n    event DistributedSupplierRewardToken(\\r\\n        LeToken indexed leToken,\\r\\n        address indexed supplier,\\r\\n        uint256 rewardTokenDelta,\\r\\n        uint256 rewardTokenTotal,\\r\\n        uint256 rewardTokenSupplyIndex\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when REWARD TOKEN is distributed to a borrower\\r\\n    event DistributedBorrowerRewardToken(\\r\\n        LeToken indexed leToken,\\r\\n        address indexed borrower,\\r\\n        uint256 rewardTokenDelta,\\r\\n        uint256 rewardTokenTotal,\\r\\n        uint256 rewardTokenBorrowIndex\\r\\n    );\\r\\n\\r\\n    /// @notice Emitted when a new supply-side REWARD TOKEN speed is calculated for a market\\r\\n    event RewardTokenSupplySpeedUpdated(LeToken indexed leToken, uint256 newSpeed);\\r\\n\\r\\n    /// @notice Emitted when a new borrow-side REWARD TOKEN speed is calculated for a market\\r\\n    event RewardTokenBorrowSpeedUpdated(LeToken indexed leToken, uint256 newSpeed);\\r\\n\\r\\n    /// @notice Emitted when REWARD TOKEN is granted by admin\\r\\n    event RewardTokenGranted(address indexed recipient, uint256 amount);\\r\\n\\r\\n    /// @notice Emitted when a new REWARD TOKEN speed is set for a contributor\\r\\n    event ContributorRewardTokenSpeedUpdated(address indexed contributor, uint256 newSpeed);\\r\\n\\r\\n    /// @notice Emitted when a market is initialized\\r\\n    event MarketInitialized(address indexed leToken);\\r\\n\\r\\n    /// @notice Emitted when a reward token supply index is updated\\r\\n    event RewardTokenSupplyIndexUpdated(address indexed leToken);\\r\\n\\r\\n    /// @notice Emitted when a reward token borrow index is updated\\r\\n    event RewardTokenBorrowIndexUpdated(address indexed leToken, Exp marketBorrowIndex);\\r\\n\\r\\n    /// @notice Emitted when a reward for contributor is updated\\r\\n    event ContributorRewardsUpdated(address indexed contributor, uint256 rewardAccrued);\\r\\n\\r\\n    /// @notice Emitted when a reward token last rewarding block for supply is updated\\r\\n    event SupplyLastRewardingBlockUpdated(address indexed leToken, uint32 newBlock);\\r\\n\\r\\n    /// @notice Emitted when a reward token last rewarding block for borrow is updated\\r\\n    event BorrowLastRewardingBlockUpdated(address indexed leToken, uint32 newBlock);\\r\\n\\r\\n    modifier onlyComptroller() {\\r\\n        require(address(comptroller) == msg.sender, \\\"Only comptroller can call this function\\\");\\r\\n        _;\\r\\n    }\\r\\n\\r\\n    /// @custom:oz-upgrades-unsafe-allow constructor\\r\\n    constructor() {\\r\\n        _disableInitializers();\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice RewardsDistributor initializer\\r\\n     * @dev Initializes the deployer to owner\\r\\n     * @param comptroller_ Comptroller to attach the reward distributor to\\r\\n     * @param rewardToken_ Reward token to distribute\\r\\n     * @param loopsLimit_ Maximum number of iterations for the loops in this contract\\r\\n     * @param accessControlManager_ AccessControlManager contract address\\r\\n     */\\r\\n    function initialize(\\r\\n        Comptroller comptroller_,\\r\\n        IERC20Upgradeable rewardToken_,\\r\\n        uint256 loopsLimit_,\\r\\n        address accessControlManager_\\r\\n    ) external initializer {\\r\\n        comptroller = comptroller_;\\r\\n        rewardToken = rewardToken_;\\r\\n        __Ownable2Step_init();\\r\\n        __AccessControlled_init_unchained(accessControlManager_);\\r\\n\\r\\n        _setMaxLoopsLimit(loopsLimit_);\\r\\n    }\\r\\n\\r\\n    function initializeMarket(address leToken) external onlyComptroller {\\r\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\r\\n\\r\\n        RewardToken storage supplyState = rewardTokenSupplyState[leToken];\\r\\n        RewardToken storage borrowState = rewardTokenBorrowState[leToken];\\r\\n\\r\\n        /*\\r\\n         * Update market state indices\\r\\n         */\\r\\n        if (supplyState.index == 0) {\\r\\n            // Initialize supply state index with default value\\r\\n            supplyState.index = INITIAL_INDEX;\\r\\n        }\\r\\n\\r\\n        if (borrowState.index == 0) {\\r\\n            // Initialize borrow state index with default value\\r\\n            borrowState.index = INITIAL_INDEX;\\r\\n        }\\r\\n\\r\\n        /*\\r\\n         * Update market state block numbers\\r\\n         */\\r\\n        supplyState.block = borrowState.block = blockNumber;\\r\\n\\r\\n        emit MarketInitialized(leToken);\\r\\n    }\\r\\n\\r\\n    /*** Reward Token Distribution ***/\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them\\r\\n     *         Borrowers will begin to accrue after the first interaction with the protocol.\\r\\n     * @dev This function should only be called when the user has a borrow position in the market\\r\\n     *      (e.g. Comptroller.preBorrowHook, and Comptroller.preRepayHook)\\r\\n     *      We avoid an external call to check if they are in the market to save gas because this function is called in many places\\r\\n     * @param leToken The market in which the borrower is interacting\\r\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\r\\n     * @param marketBorrowIndex The current global borrow index of leToken\\r\\n     */\\r\\n    function distributeBorrowerRewardToken(\\r\\n        address leToken,\\r\\n        address borrower,\\r\\n        Exp memory marketBorrowIndex\\r\\n    ) external onlyComptroller {\\r\\n        _distributeBorrowerRewardToken(leToken, borrower, marketBorrowIndex);\\r\\n    }\\r\\n\\r\\n    function updateRewardTokenSupplyIndex(address leToken) external onlyComptroller {\\r\\n        _updateRewardTokenSupplyIndex(leToken);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer REWARD TOKEN to the recipient\\r\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all\\r\\n     * @param recipient The address of the recipient to transfer REWARD TOKEN to\\r\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\r\\n     */\\r\\n    function grantRewardToken(address recipient, uint256 amount) external onlyOwner {\\r\\n        uint256 amountLeft = _grantRewardToken(recipient, amount);\\r\\n        require(amountLeft == 0, \\\"insufficient rewardToken for grant\\\");\\r\\n        emit RewardTokenGranted(recipient, amount);\\r\\n    }\\r\\n\\r\\n    function updateRewardTokenBorrowIndex(address leToken, Exp memory marketBorrowIndex) external onlyComptroller {\\r\\n        _updateRewardTokenBorrowIndex(leToken, marketBorrowIndex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set REWARD TOKEN borrow and supply speeds for the specified markets\\r\\n     * @param leTokens The markets whose REWARD TOKEN speed to update\\r\\n     * @param supplySpeeds New supply-side REWARD TOKEN speed for the corresponding market\\r\\n     * @param borrowSpeeds New borrow-side REWARD TOKEN speed for the corresponding market\\r\\n     */\\r\\n    function setRewardTokenSpeeds(\\r\\n        LeToken[] memory leTokens,\\r\\n        uint256[] memory supplySpeeds,\\r\\n        uint256[] memory borrowSpeeds\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setRewardTokenSpeeds(address[],uint256[],uint256[])\\\");\\r\\n        uint256 numTokens = leTokens.length;\\r\\n        require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \\\"invalid setRewardTokenSpeeds\\\");\\r\\n\\r\\n        for (uint256 i; i < numTokens; ++i) {\\r\\n            _setRewardTokenSpeed(leTokens[i], supplySpeeds[i], borrowSpeeds[i]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set REWARD TOKEN last rewarding block for the specified markets\\r\\n     * @param leTokens The markets whose REWARD TOKEN last rewarding block to update\\r\\n     * @param supplyLastRewardingBlocks New supply-side REWARD TOKEN last rewarding block for the corresponding market\\r\\n     * @param borrowLastRewardingBlocks New borrow-side REWARD TOKEN last rewarding block for the corresponding market\\r\\n     */\\r\\n    function setLastRewardingBlocks(\\r\\n        LeToken[] calldata leTokens,\\r\\n        uint32[] calldata supplyLastRewardingBlocks,\\r\\n        uint32[] calldata borrowLastRewardingBlocks\\r\\n    ) external {\\r\\n        _checkAccessAllowed(\\\"setLastRewardingBlock(address[],uint32[],uint32[])\\\");\\r\\n        uint256 numTokens = leTokens.length;\\r\\n        require(\\r\\n            numTokens == supplyLastRewardingBlocks.length && numTokens == borrowLastRewardingBlocks.length,\\r\\n            \\\"RewardsDistributor::setLastRewardingBlocks invalid input\\\"\\r\\n        );\\r\\n\\r\\n        for (uint256 i; i < numTokens; ) {\\r\\n            _setLastRewardingBlock(leTokens[i], supplyLastRewardingBlocks[i], borrowLastRewardingBlocks[i]);\\r\\n            unchecked {\\r\\n                ++i;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set REWARD TOKEN speed for a single contributor\\r\\n     * @param contributor The contributor whose REWARD TOKEN speed to update\\r\\n     * @param rewardTokenSpeed New REWARD TOKEN speed for contributor\\r\\n     */\\r\\n    function setContributorRewardTokenSpeed(address contributor, uint256 rewardTokenSpeed) external onlyOwner {\\r\\n        // note that REWARD TOKEN speed could be set to 0 to halt liquidity rewards for a contributor\\r\\n        updateContributorRewards(contributor);\\r\\n        if (rewardTokenSpeed == 0) {\\r\\n            // release storage\\r\\n            delete lastContributorBlock[contributor];\\r\\n        } else {\\r\\n            lastContributorBlock[contributor] = getBlockNumber();\\r\\n        }\\r\\n        rewardTokenContributorSpeeds[contributor] = rewardTokenSpeed;\\r\\n\\r\\n        emit ContributorRewardTokenSpeedUpdated(contributor, rewardTokenSpeed);\\r\\n    }\\r\\n\\r\\n    function distributeSupplierRewardToken(address leToken, address supplier) external onlyComptroller {\\r\\n        _distributeSupplierRewardToken(leToken, supplier);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim all the rewardToken accrued by holder in all markets\\r\\n     * @param holder The address to claim REWARD TOKEN for\\r\\n     */\\r\\n    function claimRewardToken(address holder) external {\\r\\n        return claimRewardToken(holder, comptroller.getAllMarkets());\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\r\\n     * @param limit Limit for the max loops can execute at a time\\r\\n     */\\r\\n    function setMaxLoopsLimit(uint256 limit) external onlyOwner {\\r\\n        _setMaxLoopsLimit(limit);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate additional accrued REWARD TOKEN for a contributor since last accrual\\r\\n     * @param contributor The address to calculate contributor rewards for\\r\\n     */\\r\\n    function updateContributorRewards(address contributor) public {\\r\\n        uint256 rewardTokenSpeed = rewardTokenContributorSpeeds[contributor];\\r\\n        uint256 blockNumber = getBlockNumber();\\r\\n        uint256 deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\\r\\n        if (deltaBlocks > 0 && rewardTokenSpeed > 0) {\\r\\n            uint256 newAccrued = mul_(deltaBlocks, rewardTokenSpeed);\\r\\n            uint256 contributorAccrued = add_(rewardTokenAccrued[contributor], newAccrued);\\r\\n\\r\\n            rewardTokenAccrued[contributor] = contributorAccrued;\\r\\n            lastContributorBlock[contributor] = blockNumber;\\r\\n\\r\\n            emit ContributorRewardsUpdated(contributor, rewardTokenAccrued[contributor]);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Claim all the rewardToken accrued by holder in the specified markets\\r\\n     * @param holder The address to claim REWARD TOKEN for\\r\\n     * @param leTokens The list of markets to claim REWARD TOKEN in\\r\\n     */\\r\\n    function claimRewardToken(address holder, LeToken[] memory leTokens) public {\\r\\n        uint256 leTokensCount = leTokens.length;\\r\\n\\r\\n        _ensureMaxLoops(leTokensCount);\\r\\n\\r\\n        for (uint256 i; i < leTokensCount; ++i) {\\r\\n            LeToken leToken = leTokens[i];\\r\\n            require(comptroller.isMarketListed(leToken), \\\"market must be listed\\\");\\r\\n            Exp memory borrowIndex = Exp({ mantissa: leToken.borrowIndex() });\\r\\n            _updateRewardTokenBorrowIndex(address(leToken), borrowIndex);\\r\\n            _distributeBorrowerRewardToken(address(leToken), holder, borrowIndex);\\r\\n            _updateRewardTokenSupplyIndex(address(leToken));\\r\\n            _distributeSupplierRewardToken(address(leToken), holder);\\r\\n        }\\r\\n        rewardTokenAccrued[holder] = _grantRewardToken(holder, rewardTokenAccrued[holder]);\\r\\n    }\\r\\n\\r\\n    function getBlockNumber() public view virtual returns (uint256) {\\r\\n        return block.number;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set REWARD TOKEN last rewarding block for a single market.\\r\\n     * @param leToken market's whose reward token last rewarding block to be updated\\r\\n     * @param supplyLastRewardingBlock New supply-side REWARD TOKEN last rewarding block for market\\r\\n     * @param borrowLastRewardingBlock New borrow-side REWARD TOKEN last rewarding block for market\\r\\n     */\\r\\n    function _setLastRewardingBlock(\\r\\n        LeToken leToken,\\r\\n        uint32 supplyLastRewardingBlock,\\r\\n        uint32 borrowLastRewardingBlock\\r\\n    ) internal {\\r\\n        require(comptroller.isMarketListed(leToken), \\\"rewardToken market is not listed\\\");\\r\\n\\r\\n        uint256 blockNumber = getBlockNumber();\\r\\n\\r\\n        require(supplyLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\r\\n        require(borrowLastRewardingBlock > blockNumber, \\\"setting last rewarding block in the past is not allowed\\\");\\r\\n\\r\\n        uint32 currentSupplyLastRewardingBlock = rewardTokenSupplyState[address(leToken)].lastRewardingBlock;\\r\\n        uint32 currentBorrowLastRewardingBlock = rewardTokenBorrowState[address(leToken)].lastRewardingBlock;\\r\\n\\r\\n        require(\\r\\n            currentSupplyLastRewardingBlock == 0 || currentSupplyLastRewardingBlock > blockNumber,\\r\\n            \\\"this RewardsDistributor is already locked\\\"\\r\\n        );\\r\\n        require(\\r\\n            currentBorrowLastRewardingBlock == 0 || currentBorrowLastRewardingBlock > blockNumber,\\r\\n            \\\"this RewardsDistributor is already locked\\\"\\r\\n        );\\r\\n\\r\\n        if (currentSupplyLastRewardingBlock != supplyLastRewardingBlock) {\\r\\n            rewardTokenSupplyState[address(leToken)].lastRewardingBlock = supplyLastRewardingBlock;\\r\\n            emit SupplyLastRewardingBlockUpdated(address(leToken), supplyLastRewardingBlock);\\r\\n        }\\r\\n\\r\\n        if (currentBorrowLastRewardingBlock != borrowLastRewardingBlock) {\\r\\n            rewardTokenBorrowState[address(leToken)].lastRewardingBlock = borrowLastRewardingBlock;\\r\\n            emit BorrowLastRewardingBlockUpdated(address(leToken), borrowLastRewardingBlock);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Set REWARD TOKEN speed for a single market.\\r\\n     * @param leToken market's whose reward token rate to be updated\\r\\n     * @param supplySpeed New supply-side REWARD TOKEN speed for market\\r\\n     * @param borrowSpeed New borrow-side REWARD TOKEN speed for market\\r\\n     */\\r\\n    function _setRewardTokenSpeed(LeToken leToken, uint256 supplySpeed, uint256 borrowSpeed) internal {\\r\\n        require(comptroller.isMarketListed(leToken), \\\"rewardToken market is not listed\\\");\\r\\n\\r\\n        if (rewardTokenSupplySpeeds[address(leToken)] != supplySpeed) {\\r\\n            // Supply speed updated so let's update supply state to ensure that\\r\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\r\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\r\\n            _updateRewardTokenSupplyIndex(address(leToken));\\r\\n\\r\\n            // Update speed and emit event\\r\\n            rewardTokenSupplySpeeds[address(leToken)] = supplySpeed;\\r\\n            emit RewardTokenSupplySpeedUpdated(leToken, supplySpeed);\\r\\n        }\\r\\n\\r\\n        if (rewardTokenBorrowSpeeds[address(leToken)] != borrowSpeed) {\\r\\n            // Borrow speed updated so let's update borrow state to ensure that\\r\\n            //  1. REWARD TOKEN accrued properly for the old speed, and\\r\\n            //  2. REWARD TOKEN accrued at the new speed starts after this block.\\r\\n            Exp memory borrowIndex = Exp({ mantissa: leToken.borrowIndex() });\\r\\n            _updateRewardTokenBorrowIndex(address(leToken), borrowIndex);\\r\\n\\r\\n            // Update speed and emit event\\r\\n            rewardTokenBorrowSpeeds[address(leToken)] = borrowSpeed;\\r\\n            emit RewardTokenBorrowSpeedUpdated(leToken, borrowSpeed);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate REWARD TOKEN accrued by a supplier and possibly transfer it to them.\\r\\n     * @param leToken The market in which the supplier is interacting\\r\\n     * @param supplier The address of the supplier to distribute REWARD TOKEN to\\r\\n     */\\r\\n    function _distributeSupplierRewardToken(address leToken, address supplier) internal {\\r\\n        RewardToken storage supplyState = rewardTokenSupplyState[leToken];\\r\\n        uint256 supplyIndex = supplyState.index;\\r\\n        uint256 supplierIndex = rewardTokenSupplierIndex[leToken][supplier];\\r\\n\\r\\n        // Update supplier's index to the current index since we are distributing accrued REWARD TOKEN\\r\\n        rewardTokenSupplierIndex[leToken][supplier] = supplyIndex;\\r\\n\\r\\n        if (supplierIndex == 0 && supplyIndex >= INITIAL_INDEX) {\\r\\n            // Covers the case where users supplied tokens before the market's supply state index was set.\\r\\n            // Rewards the user with REWARD TOKEN accrued from the start of when supplier rewards were first\\r\\n            // set for the market.\\r\\n            supplierIndex = INITIAL_INDEX;\\r\\n        }\\r\\n\\r\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per leToken accrued\\r\\n        Double memory deltaIndex = Double({ mantissa: sub_(supplyIndex, supplierIndex) });\\r\\n\\r\\n        uint256 supplierTokens = LeToken(leToken).balanceOf(supplier);\\r\\n\\r\\n        // Calculate REWARD TOKEN accrued: leTokenAmount * accruedPerLeToken\\r\\n        uint256 supplierDelta = mul_(supplierTokens, deltaIndex);\\r\\n\\r\\n        uint256 supplierAccrued = add_(rewardTokenAccrued[supplier], supplierDelta);\\r\\n        rewardTokenAccrued[supplier] = supplierAccrued;\\r\\n\\r\\n        emit DistributedSupplierRewardToken(LeToken(leToken), supplier, supplierDelta, supplierAccrued, supplyIndex);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Calculate reward token accrued by a borrower and possibly transfer it to them.\\r\\n     * @param leToken The market in which the borrower is interacting\\r\\n     * @param borrower The address of the borrower to distribute REWARD TOKEN to\\r\\n     * @param marketBorrowIndex The current global borrow index of leToken\\r\\n     */\\r\\n    function _distributeBorrowerRewardToken(address leToken, address borrower, Exp memory marketBorrowIndex) internal {\\r\\n        RewardToken storage borrowState = rewardTokenBorrowState[leToken];\\r\\n        uint256 borrowIndex = borrowState.index;\\r\\n        uint256 borrowerIndex = rewardTokenBorrowerIndex[leToken][borrower];\\r\\n\\r\\n        // Update borrowers's index to the current index since we are distributing accrued REWARD TOKEN\\r\\n        rewardTokenBorrowerIndex[leToken][borrower] = borrowIndex;\\r\\n\\r\\n        if (borrowerIndex == 0 && borrowIndex >= INITIAL_INDEX) {\\r\\n            // Covers the case where users borrowed tokens before the market's borrow state index was set.\\r\\n            // Rewards the user with REWARD TOKEN accrued from the start of when borrower rewards were first\\r\\n            // set for the market.\\r\\n            borrowerIndex = INITIAL_INDEX;\\r\\n        }\\r\\n\\r\\n        // Calculate change in the cumulative sum of the REWARD TOKEN per borrowed unit accrued\\r\\n        Double memory deltaIndex = Double({ mantissa: sub_(borrowIndex, borrowerIndex) });\\r\\n\\r\\n        uint256 borrowerAmount = div_(LeToken(leToken).borrowBalanceStored(borrower), marketBorrowIndex);\\r\\n\\r\\n        // Calculate REWARD TOKEN accrued: leTokenAmount * accruedPerBorrowedUnit\\r\\n        if (borrowerAmount != 0) {\\r\\n            uint256 borrowerDelta = mul_(borrowerAmount, deltaIndex);\\r\\n\\r\\n            uint256 borrowerAccrued = add_(rewardTokenAccrued[borrower], borrowerDelta);\\r\\n            rewardTokenAccrued[borrower] = borrowerAccrued;\\r\\n\\r\\n            emit DistributedBorrowerRewardToken(LeToken(leToken), borrower, borrowerDelta, borrowerAccrued, borrowIndex);\\r\\n        }\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Transfer REWARD TOKEN to the user.\\r\\n     * @dev Note: If there is not enough REWARD TOKEN, we do not perform the transfer all.\\r\\n     * @param user The address of the user to transfer REWARD TOKEN to\\r\\n     * @param amount The amount of REWARD TOKEN to (possibly) transfer\\r\\n     * @return The amount of REWARD TOKEN which was NOT transferred to the user\\r\\n     */\\r\\n    function _grantRewardToken(address user, uint256 amount) internal returns (uint256) {\\r\\n        uint256 rewardTokenRemaining = rewardToken.balanceOf(address(this));\\r\\n        if (amount > 0 && amount <= rewardTokenRemaining) {\\r\\n            rewardToken.safeTransfer(user, amount);\\r\\n            return 0;\\r\\n        }\\r\\n        return amount;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue REWARD TOKEN to the market by updating the supply index\\r\\n     * @param leToken The market whose supply index to update\\r\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per leToken accrued\\r\\n     */\\r\\n    function _updateRewardTokenSupplyIndex(address leToken) internal {\\r\\n        RewardToken storage supplyState = rewardTokenSupplyState[leToken];\\r\\n        uint256 supplySpeed = rewardTokenSupplySpeeds[leToken];\\r\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\r\\n\\r\\n        if (supplyState.lastRewardingBlock > 0 && blockNumber > supplyState.lastRewardingBlock) {\\r\\n            blockNumber = supplyState.lastRewardingBlock;\\r\\n        }\\r\\n\\r\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(supplyState.block));\\r\\n\\r\\n        if (deltaBlocks > 0 && supplySpeed > 0) {\\r\\n            uint256 supplyTokens = LeToken(leToken).totalSupply();\\r\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, supplySpeed);\\r\\n            Double memory ratio = supplyTokens > 0\\r\\n                ? fraction(accruedSinceUpdate, supplyTokens)\\r\\n                : Double({ mantissa: 0 });\\r\\n            supplyState.index = safe224(\\r\\n                add_(Double({ mantissa: supplyState.index }), ratio).mantissa,\\r\\n                \\\"new index exceeds 224 bits\\\"\\r\\n            );\\r\\n            supplyState.block = blockNumber;\\r\\n        } else if (deltaBlocks > 0) {\\r\\n            supplyState.block = blockNumber;\\r\\n        }\\r\\n\\r\\n        emit RewardTokenSupplyIndexUpdated(leToken);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Accrue REWARD TOKEN to the market by updating the borrow index\\r\\n     * @param leToken The market whose borrow index to update\\r\\n     * @param marketBorrowIndex The current global borrow index of leToken\\r\\n     * @dev Index is a cumulative sum of the REWARD TOKEN per leToken accrued\\r\\n     */\\r\\n    function _updateRewardTokenBorrowIndex(address leToken, Exp memory marketBorrowIndex) internal {\\r\\n        RewardToken storage borrowState = rewardTokenBorrowState[leToken];\\r\\n        uint256 borrowSpeed = rewardTokenBorrowSpeeds[leToken];\\r\\n        uint32 blockNumber = safe32(getBlockNumber(), \\\"block number exceeds 32 bits\\\");\\r\\n\\r\\n        if (borrowState.lastRewardingBlock > 0 && blockNumber > borrowState.lastRewardingBlock) {\\r\\n            blockNumber = borrowState.lastRewardingBlock;\\r\\n        }\\r\\n\\r\\n        uint256 deltaBlocks = sub_(uint256(blockNumber), uint256(borrowState.block));\\r\\n        if (deltaBlocks > 0 && borrowSpeed > 0) {\\r\\n            uint256 borrowAmount = div_(LeToken(leToken).totalBorrows(), marketBorrowIndex);\\r\\n            uint256 accruedSinceUpdate = mul_(deltaBlocks, borrowSpeed);\\r\\n            Double memory ratio = borrowAmount > 0\\r\\n                ? fraction(accruedSinceUpdate, borrowAmount)\\r\\n                : Double({ mantissa: 0 });\\r\\n            borrowState.index = safe224(\\r\\n                add_(Double({ mantissa: borrowState.index }), ratio).mantissa,\\r\\n                \\\"new index exceeds 224 bits\\\"\\r\\n            );\\r\\n            borrowState.block = blockNumber;\\r\\n        } else if (deltaBlocks > 0) {\\r\\n            borrowState.block = blockNumber;\\r\\n        }\\r\\n\\r\\n        emit RewardTokenBorrowIndexUpdated(leToken, marketBorrowIndex);\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x8c584c5118af2850b3b543b7e65cb3605524a810374131d673f43efe0c15f5a3\",\"license\":\"BSD-3-Clause\"},\"contracts/access-controll/AccessControlledV8.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\r\\nimport \\\"@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol\\\";\\r\\n\\r\\nimport \\\"./IAccessControlManagerV8.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title AccessControlledV8\\r\\n * @author LendLand\\r\\n * @notice This contract is helper between access control manager and actual contract. This contract further inherited by other contract (using solidity 0.8.13)\\r\\n * to integrate access controlled mechanism. It provides initialise methods and verifying access methods.\\r\\n */\\r\\nabstract contract AccessControlledV8 is Initializable, Ownable2StepUpgradeable {\\r\\n    /// @notice Access control manager contract\\r\\n    IAccessControlManagerV8 private _accessControlManager;\\r\\n\\r\\n    /**\\r\\n     * @dev This empty reserved space is put in place to allow future versions to add new\\r\\n     * variables without shifting down storage in the inheritance chain.\\r\\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n     */\\r\\n    uint256[49] private __gap;\\r\\n\\r\\n    /// @notice Emitted when access control manager contract address is changed\\r\\n    event NewAccessControlManager(address oldAccessControlManager, address newAccessControlManager);\\r\\n\\r\\n    /// @notice Thrown when the action is prohibited by AccessControlManager\\r\\n    error Unauthorized(address sender, address calledContract, string methodSignature);\\r\\n\\r\\n    function __AccessControlled_init(address accessControlManager_) internal onlyInitializing {\\r\\n        __Ownable2Step_init();\\r\\n        __AccessControlled_init_unchained(accessControlManager_);\\r\\n    }\\r\\n\\r\\n    function __AccessControlled_init_unchained(address accessControlManager_) internal onlyInitializing {\\r\\n        _setAccessControlManager(accessControlManager_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Sets the address of AccessControlManager\\r\\n     * @dev Admin function to set address of AccessControlManager\\r\\n     * @param accessControlManager_ The new address of the AccessControlManager\\r\\n     * @custom:event Emits NewAccessControlManager event\\r\\n     * @custom:access Only Governance\\r\\n     */\\r\\n    function setAccessControlManager(address accessControlManager_) external onlyOwner {\\r\\n        _setAccessControlManager(accessControlManager_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns the address of the access control manager contract\\r\\n     */\\r\\n    function accessControlManager() external view returns (IAccessControlManagerV8) {\\r\\n        return _accessControlManager;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @dev Internal function to set address of AccessControlManager\\r\\n     * @param accessControlManager_ The new address of the AccessControlManager\\r\\n     */\\r\\n    function _setAccessControlManager(address accessControlManager_) internal {\\r\\n        require(address(accessControlManager_) != address(0), \\\"invalid acess control manager address\\\");\\r\\n        address oldAccessControlManager = address(_accessControlManager);\\r\\n        _accessControlManager = IAccessControlManagerV8(accessControlManager_);\\r\\n        emit NewAccessControlManager(oldAccessControlManager, accessControlManager_);\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Reverts if the call is not allowed by AccessControlManager\\r\\n     * @param signature Method signature\\r\\n     */\\r\\n    function _checkAccessAllowed(string memory signature) internal view {\\r\\n        bool isAllowedToCall = _accessControlManager.isAllowedToCall(msg.sender, signature);\\r\\n\\r\\n        if (!isAllowedToCall) {\\r\\n            revert Unauthorized(msg.sender, address(this), signature);\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x412e944e26485381ef9730380f41e4d1eefe1303db7f9157aef74b6486f905cc\",\"license\":\"BSD-3-Clause\"},\"contracts/access-controll/IAccessControlManagerV8.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport \\\"@openzeppelin/contracts/access/IAccessControl.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IAccessControlManagerV8\\r\\n * @author LendLand\\r\\n * @notice Interface implemented by the `AccessControlManagerV8` contract.\\r\\n */\\r\\ninterface IAccessControlManagerV8 is IAccessControl {\\r\\n    function giveCallPermission(address contractAddress, string calldata functionSig, address accountToPermit) external;\\r\\n\\r\\n    function revokeCallPermission(\\r\\n        address contractAddress,\\r\\n        string calldata functionSig,\\r\\n        address accountToRevoke\\r\\n    ) external;\\r\\n\\r\\n    function isAllowedToCall(address account, string calldata functionSig) external view returns (bool);\\r\\n\\r\\n    function hasPermission(\\r\\n        address account,\\r\\n        address contractAddress,\\r\\n        string calldata functionSig\\r\\n    ) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0xa5689bef11bf69f5c25436b8a80718b37c4985cd7ffa1a971eb53fbe6874a555\",\"license\":\"BSD-3-Clause\"},\"contracts/access-controll/IPrime.sol\":{\"content\":\"pragma solidity 0.8.13;\\r\\n\\r\\nimport { PrimeStorageV1 } from \\\"./PrimeStorage.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title IPrime\\r\\n * @author LendLand\\r\\n * @notice Interface for Prime Token\\r\\n */\\r\\ninterface IPrime {\\r\\n    struct APRInfo {\\r\\n        // supply APR of the user in BPS\\r\\n        uint256 supplyAPR;\\r\\n        // borrow APR of the user in BPS\\r\\n        uint256 borrowAPR;\\r\\n        // total score of the market\\r\\n        uint256 totalScore;\\r\\n        // score of the user\\r\\n        uint256 userScore;\\r\\n        // capped XVS balance of the user\\r\\n        uint256 xvsBalanceForScore;\\r\\n        // capital of the user\\r\\n        uint256 capital;\\r\\n        // capped supply of the user\\r\\n        uint256 cappedSupply;\\r\\n        // capped borrow of the user\\r\\n        uint256 cappedBorrow;\\r\\n        // capped supply of user in USD\\r\\n        uint256 supplyCapUSD;\\r\\n        // capped borrow of user in USD\\r\\n        uint256 borrowCapUSD;\\r\\n    }\\r\\n\\r\\n    struct Capital {\\r\\n        // capital of the user\\r\\n        uint256 capital;\\r\\n        // capped supply of the user\\r\\n        uint256 cappedSupply;\\r\\n        // capped borrow of the user\\r\\n        uint256 cappedBorrow;\\r\\n        // capped supply of user in USD\\r\\n        uint256 supplyCapUSD;\\r\\n        // capped borrow of user in USD\\r\\n        uint256 borrowCapUSD;\\r\\n    }\\r\\n\\r\\n    /**\\r\\n     * @notice Returns boosted pending interest accrued for a user for all markets\\r\\n     * @param user the account for which to get the accrued interests\\r\\n     * @return pendingRewards the number of underlying tokens accrued by the user for all markets\\r\\n     */\\r\\n    function getPendingRewards(address user) external returns (PrimeStorageV1.PendingReward[] memory pendingRewards);\\r\\n\\r\\n    /**\\r\\n     * @notice Update total score of multiple users and market\\r\\n     * @param users accounts for which we need to update score\\r\\n     */\\r\\n    function updateScores(address[] memory users) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update value of alpha\\r\\n     * @param _alphaNumerator numerator of alpha. If alpha is 0.5 then numerator is 1\\r\\n     * @param _alphaDenominator denominator of alpha. If alpha is 0.5 then denominator is 2\\r\\n     */\\r\\n    function updateAlpha(uint128 _alphaNumerator, uint128 _alphaDenominator) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update multipliers for a market\\r\\n     * @param market address of the market leToken\\r\\n     * @param supplyMultiplier new supply multiplier for the market, scaled by 1e18\\r\\n     * @param borrowMultiplier new borrow multiplier for the market, scaled by 1e18\\r\\n     */\\r\\n    function updateMultipliers(address market, uint256 supplyMultiplier, uint256 borrowMultiplier) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Add a market to prime program\\r\\n     * @param comptroller address of the comptroller\\r\\n     * @param market address of the market leToken\\r\\n     * @param supplyMultiplier the multiplier for supply cap. It should be converted to 1e18\\r\\n     * @param borrowMultiplier the multiplier for borrow cap. It should be converted to 1e18\\r\\n     */\\r\\n    function addMarket(\\r\\n        address comptroller,\\r\\n        address market,\\r\\n        uint256 supplyMultiplier,\\r\\n        uint256 borrowMultiplier\\r\\n    ) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Set limits for total tokens that can be minted\\r\\n     * @param _irrevocableLimit total number of irrevocable tokens that can be minted\\r\\n     * @param _revocableLimit total number of revocable tokens that can be minted\\r\\n     */\\r\\n    function setLimit(uint256 _irrevocableLimit, uint256 _revocableLimit) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Directly issue prime tokens to users\\r\\n     * @param isIrrevocable are the tokens being issued\\r\\n     * @param users list of address to issue tokens to\\r\\n     */\\r\\n    function issue(bool isIrrevocable, address[] calldata users) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Executed by XVSVault whenever user's XVSVault balance changes\\r\\n     * @param user the account address whose balance was updated\\r\\n     */\\r\\n    function xvsUpdated(address user) external;\\r\\n\\r\\n    /**\\r\\n     * @notice accrues interest and updates score for an user for a specific market\\r\\n     * @param user the account address for which to accrue interest and update score\\r\\n     * @param market the market for which to accrue interest and update score\\r\\n     */\\r\\n    function accrueInterestAndUpdateScore(address user, address market) external;\\r\\n\\r\\n    /**\\r\\n     * @notice For claiming prime token when staking period is completed\\r\\n     */\\r\\n    function claim() external;\\r\\n\\r\\n    /**\\r\\n     * @notice For burning any prime token\\r\\n     * @param user the account address for which the prime token will be burned\\r\\n     */\\r\\n    function burn(address user) external;\\r\\n\\r\\n    /**\\r\\n     * @notice To pause or unpause claiming of interest\\r\\n     */\\r\\n    function togglePause() external;\\r\\n\\r\\n    /**\\r\\n     * @notice For user to claim boosted yield\\r\\n     * @param leToken the market for which claim the accrued interest\\r\\n     * @return amount the amount of tokens transferred to the user\\r\\n     */\\r\\n    function claimInterest(address leToken) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice For user to claim boosted yield\\r\\n     * @param leToken the market for which claim the accrued interest\\r\\n     * @param user the user for which to claim the accrued interest\\r\\n     * @return amount the amount of tokens transferred to the user\\r\\n     */\\r\\n    function claimInterest(address leToken, address user) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Distributes income from market since last distribution\\r\\n     * @param leToken the market for which to distribute the income\\r\\n     */\\r\\n    function accrueInterest(address leToken) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Returns boosted interest accrued for a user\\r\\n     * @param leToken the market for which to fetch the accrued interest\\r\\n     * @param user the account for which to get the accrued interest\\r\\n     * @return interestAccrued the number of underlying tokens accrued by the user since the last accrual\\r\\n     */\\r\\n    function getInterestAccrued(address leToken, address user) external returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Retrieves an array of all available markets\\r\\n     * @return an array of addresses representing all available markets\\r\\n     */\\r\\n    function getAllMarkets() external view returns (address[] memory);\\r\\n\\r\\n    /**\\r\\n     * @notice fetch the numbers of seconds remaining for staking period to complete\\r\\n     * @param user the account address for which we are checking the remaining time\\r\\n     * @return timeRemaining the number of seconds the user needs to wait to claim prime token\\r\\n     */\\r\\n    function claimTimeRemaining(address user) external view returns (uint256);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns supply and borrow APR for user for a given market\\r\\n     * @param market the market for which to fetch the APR\\r\\n     * @param user the account for which to get the APR\\r\\n     * @return aprInfo APR information for the user for the given market\\r\\n     */\\r\\n    function calculateAPR(address market, address user) external view returns (APRInfo memory aprInfo);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns supply and borrow APR for estimated supply, borrow and XVS staked\\r\\n     * @param market the market for which to fetch the APR\\r\\n     * @param user the account for which to get the APR\\r\\n     * @param borrow hypothetical borrow amount\\r\\n     * @param supply hypothetical supply amount\\r\\n     * @param xvsStaked hypothetical staked XVS amount\\r\\n     * @return aprInfo APR information for the user for the given market\\r\\n     */\\r\\n    function estimateAPR(\\r\\n        address market,\\r\\n        address user,\\r\\n        uint256 borrow,\\r\\n        uint256 supply,\\r\\n        uint256 xvsStaked\\r\\n    ) external view returns (APRInfo memory aprInfo);\\r\\n\\r\\n    /**\\r\\n     * @notice the total income that's going to be distributed in a year to prime token holders\\r\\n     * @param leToken the market for which to fetch the total income that's going to distributed in a year\\r\\n     * @return amount the total income\\r\\n     */\\r\\n    function incomeDistributionYearly(address leToken) external view returns (uint256 amount);\\r\\n\\r\\n    /**\\r\\n     * @notice Returns if user is a prime holder\\r\\n     * @return isPrimeHolder true if user is a prime holder\\r\\n     */\\r\\n    function isUserPrimeHolder(address user) external view returns (bool);\\r\\n\\r\\n    /**\\r\\n     * @notice Set the limit for the loops can iterate to avoid the DOS\\r\\n     * @param loopsLimit Number of loops limit\\r\\n     */\\r\\n    function setMaxLoopsLimit(uint256 loopsLimit) external;\\r\\n\\r\\n    /**\\r\\n     * @notice Update staked at timestamp for multiple users\\r\\n     * @param users accounts for which we need to update staked at timestamp\\r\\n     * @param timestamps new staked at timestamp for the users\\r\\n     */\\r\\n    function setStakedAt(address[] calldata users, uint256[] calldata timestamps) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xa175afcc27852c31ac1db9cf83dcc9e7a4f6664d73cc11984b551f9110eef4db\"},\"contracts/access-controll/IProtocolShareReserve.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface IProtocolShareReserve {\\r\\n    /// @notice it represents the type of leToken income\\r\\n    enum IncomeType {\\r\\n        SPREAD,\\r\\n        LIQUIDATION\\r\\n    }\\r\\n\\r\\n    function updateAssetsState(\\r\\n        address comptroller,\\r\\n        address asset,\\r\\n        IncomeType incomeType\\r\\n    ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xeb64cda76580de1aee965102fdd642a142eff05bf12b7f0451081eafdb8e58ee\",\"license\":\"BSD-3-Clause\"},\"contracts/access-controll/PrimeStorage.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\nimport { ResilientOracleInterface } from \\\"./interfaces/OracleInterface.sol\\\";\\r\\n\\r\\n/**\\r\\n * @title PrimeStorageV1\\r\\n * @author LendLand\\r\\n * @notice Storage for Prime Token\\r\\n */\\r\\ncontract PrimeStorageV1 {\\r\\n    struct Token {\\r\\n        bool exists;\\r\\n        bool isIrrevocable;\\r\\n    }\\r\\n\\r\\n    struct Market {\\r\\n        uint256 supplyMultiplier;\\r\\n        uint256 borrowMultiplier;\\r\\n        uint256 rewardIndex;\\r\\n        uint256 sumOfMembersScore;\\r\\n        bool exists;\\r\\n    }\\r\\n\\r\\n    struct Interest {\\r\\n        uint256 accrued;\\r\\n        uint256 score;\\r\\n        uint256 rewardIndex;\\r\\n    }\\r\\n\\r\\n    struct PendingReward {\\r\\n        address leToken;\\r\\n        address rewardToken;\\r\\n        uint256 amount;\\r\\n    }\\r\\n\\r\\n    /// @notice Base unit for computations, usually used in scaling (multiplications, divisions)\\r\\n    uint256 internal constant EXP_SCALE = 1e18;\\r\\n\\r\\n    /// @notice maximum BPS = 100%\\r\\n    uint256 internal constant MAXIMUM_BPS = 1e4;\\r\\n\\r\\n    /// @notice Mapping to get prime token's metadata\\r\\n    mapping(address => Token) public tokens;\\r\\n\\r\\n    /// @notice  Tracks total irrevocable tokens minted\\r\\n    uint256 public totalIrrevocable;\\r\\n\\r\\n    /// @notice  Tracks total revocable tokens minted\\r\\n    uint256 public totalRevocable;\\r\\n\\r\\n    /// @notice  Indicates maximum revocable tokens that can be minted\\r\\n    uint256 public revocableLimit;\\r\\n\\r\\n    /// @notice  Indicates maximum irrevocable tokens that can be minted\\r\\n    uint256 public irrevocableLimit;\\r\\n\\r\\n    /// @notice Tracks when prime token eligible users started staking for claiming prime token\\r\\n    mapping(address => uint256) public stakedAt;\\r\\n\\r\\n    /// @notice leToken to market configuration\\r\\n    mapping(address => Market) public markets;\\r\\n\\r\\n    /// @notice leToken to user to user index\\r\\n    mapping(address => mapping(address => Interest)) public interests;\\r\\n\\r\\n    /// @notice A list of boosted markets\\r\\n    address[] internal _allMarkets;\\r\\n\\r\\n    /// @notice numerator of alpha. Ex: if alpha is 0.5 then this will be 1\\r\\n    uint128 public alphaNumerator;\\r\\n\\r\\n    /// @notice denominator of alpha. Ex: if alpha is 0.5 then this will be 2\\r\\n    uint128 public alphaDenominator;\\r\\n\\r\\n    /// @notice address of XVS vault\\r\\n    address public xvsVault;\\r\\n\\r\\n    /// @notice address of XVS vault reward token\\r\\n    address public xvsVaultRewardToken;\\r\\n\\r\\n    /// @notice address of XVS vault pool id\\r\\n    uint256 public xvsVaultPoolId;\\r\\n\\r\\n    /// @notice mapping to check if a account's score was updated in the round\\r\\n    mapping(uint256 => mapping(address => bool)) public isScoreUpdated;\\r\\n\\r\\n    /// @notice unique id for next round\\r\\n    uint256 public nextScoreUpdateRoundId;\\r\\n\\r\\n    /// @notice total number of accounts whose score needs to be updated\\r\\n    uint256 public totalScoreUpdatesRequired;\\r\\n\\r\\n    /// @notice total number of accounts whose score is yet to be updated\\r\\n    uint256 public pendingScoreUpdates;\\r\\n\\r\\n    /// @notice mapping used to find if an asset is part of prime markets\\r\\n    mapping(address => address) public leTokenForAsset;\\r\\n\\r\\n    /// @notice Address of core pool comptroller contract\\r\\n    address internal corePoolComptroller;\\r\\n\\r\\n    /// @notice unreleased income from PLP that's already distributed to prime holders\\r\\n    /// @dev mapping of asset address => amount\\r\\n    mapping(address => uint256) public unreleasedPLPIncome;\\r\\n\\r\\n    /// @notice The address of PLP contract\\r\\n    address public primeLiquidityProvider;\\r\\n\\r\\n    /// @notice The address of ResilientOracle contract\\r\\n    ResilientOracleInterface public oracle;\\r\\n\\r\\n    /// @notice The address of PoolRegistry contract\\r\\n    address public poolRegistry;\\r\\n\\r\\n    /// @dev This empty reserved space is put in place to allow future versions to add new\\r\\n    /// variables without shifting down storage in the inheritance chain.\\r\\n    uint256[26] private __gap;\\r\\n}\\r\\n\",\"keccak256\":\"0xd28441f475d858f45bc04d448d4d0ae6d8477569436657d2cc133bd2d8149018\",\"license\":\"BSD-3-Clause\"},\"contracts/access-controll/interfaces/OracleInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\ninterface OracleInterface {\\r\\n    function getPrice(address asset) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface ResilientOracleInterface is OracleInterface {\\r\\n    function updatePrice(\\r\\n        address leToken,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external;\\r\\n\\r\\n    function updateAssetPrice(\\r\\n        address asset,\\r\\n        bytes[] calldata priceUpdateData\\r\\n    ) external;\\r\\n\\r\\n    function getUnderlyingPrice(\\r\\n        address leToken\\r\\n    ) external view returns (uint256);\\r\\n}\\r\\n\\r\\ninterface TwapInterface is OracleInterface {\\r\\n    function updateTwap(address asset) external returns (uint256);\\r\\n}\\r\\n\\r\\ninterface BoundValidatorInterface {\\r\\n    function validatePriceWithAnchorPrice(\\r\\n        address asset,\\r\\n        uint256 reporterPrice,\\r\\n        uint256 anchorPrice\\r\\n    ) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x4e370c6c48ce7eac40df2a0dff0c4490785f8edf38ff16c6f6c86dafca353fe4\",\"license\":\"BSD-3-Clause\"},\"contracts/lib/constants.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\n/// @dev Base unit for computations, usually used in scaling (multiplications, divisions)\\r\\nuint256 constant EXP_SCALE = 1e18;\\r\\n\\r\\n/// @dev A unit (literal one) in EXP_SCALE, usually used in additions/subtractions\\r\\nuint256 constant MANTISSA_ONE = EXP_SCALE;\\r\\n\",\"keccak256\":\"0xa9b979de5ff387f284f46be5054404cd1bcc30a93d5b586371ff557c8e4086d9\",\"license\":\"BSD-3-Clause\"},\"contracts/lib/validators.sol\":{\"content\":\"// SPDX-License-Identifier: BSD-3-Clause\\r\\npragma solidity 0.8.13;\\r\\n\\r\\n/// @notice Thrown if the supplied address is a zero address where it is not allowed\\r\\nerror ZeroAddressNotAllowed();\\r\\n\\r\\n/// @notice Checks if the provided address is nonzero, reverts otherwise\\r\\n/// @param address_ Address to check\\r\\n/// @custom:error ZeroAddressNotAllowed is thrown if the provided address is a zero address\\r\\nfunction ensureNonzeroAddress(address address_) pure {\\r\\n    if (address_ == address(0)) {\\r\\n        revert ZeroAddressNotAllowed();\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x1691145b365cdb8c4c6e1bf139bd0d1105c16f9ce33f971c1ae485c35ca15141\",\"license\":\"BSD-3-Clause\"}},\"version\":1}",
  "bytecode": "0x608060405234801561001057600080fd5b50613db9806100206000396000f3fe608060405234801561001057600080fd5b50600436106100cf5760003560e01c80637a27db571161008c578063cfa5ff6911610066578063cfa5ff69146101fd578063d77ebf9614610210578063dc7634c314610230578063ffa71f6d1461025057600080fd5b80637a27db571461019d5780637e9ab2cb146101bd578063ad0d9822146101dd57600080fd5b8063345954dc146100d457806334c16ef9146100fd5780633e3e399c1461011d5780634399f7791461013d57806347d86a811461015d57806355e3a7d91461017d575b600080fd5b6100e76100e2366004612d1d565b61027b565b6040516100f49190612fbb565b60405180910390f35b61011061010b366004613068565b6103b7565b6040516100f491906130a9565b61013061012b366004612d1d565b61048a565b6040516100f49190613109565b61015061014b366004612d1d565b610805565b6040516100f49190613193565b61017061016b3660046131a2565b610f53565b6040516100f491906131db565b61019061018b3660046131a2565b610fda565b6040516100f4919061322e565b6101b06101ab3660046131a2565b6112c1565b6040516100f4919061323c565b6101d06101cb366004612d1d565b6115d7565b6040516100f49190613316565b6101f06101eb3660046133e9565b611741565b6040516100f49190613487565b61017061020b3660046134fd565b6117ff565b61022361021e3660046131a2565b611b32565b6040516100f491906135ef565b61024361023e366004613630565b611ba5565b6040516100f49190613686565b61026361025e3660046136c8565b611c67565b6040516001600160a01b0390911681526020016100f4565b606060008290506000816001600160a01b031663d88ff1f46040518163ffffffff1660e01b8152600401600060405180830381865afa1580156102c2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526102ea91908101906137d0565b80519091506000816001600160401b0381111561030957610309613336565b60405190808252806020026020018201604052801561034257816020015b61032f612b9b565b8152602001906001900390816103275790505b50905060005b828110156103ad57600084828151811061036457610364613880565b60200260200101519050600061037a89836117ff565b90508084848151811061038f5761038f613880565b60200260200101819052505050806103a6906138ac565b9050610348565b5095945050505050565b6060816000816001600160401b038111156103d4576103d4613336565b60405190808252806020026020018201604052801561041957816020015b60408051808201909152600080825260208201528152602001906001900390816103f25790505b50905060005b8281101561047f5761045186868381811061043c5761043c613880565b90506020020160208101906101cb9190612d1d565b82828151811061046357610463613880565b602002602001018190525080610478906138ac565b905061041f565b509150505b92915050565b604080516060808201835260008083526020830152918101919091526000808390506000816001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156104ec573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261051491908101906138c5565b90506000826001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610556573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061057a9190613953565b9050600082516001600160401b0381111561059757610597613336565b6040519080825280602002602001820160405280156105dc57816020015b60408051808201909152600080825260208201528152602001906001900390816105b55790505b50905061060c604051806060016040528060006001600160a01b0316815260200160008152602001606081525090565b6001600160a01b03881681526040810182905260005b84518110156107f157604080518082019091526000808252602082015285828151811061065157610651613880565b602002602001015181600001906001600160a01b031690816001600160a01b031681525050670de0b6b3a7640000856001600160a01b031663fc57d4df8885815181106106a0576106a0613880565b60200260200101516040518263ffffffff1660e01b81526004016106d391906001600160a01b0391909116815260200190565b602060405180830381865afa1580156106f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107149190613970565b87848151811061072657610726613880565b60200260200101516001600160a01b031663bbcac5576040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190613970565b6107999190613989565b6107a391906139a8565b602082015260408301518051829190849081106107c2576107c2613880565b60200260200101819052508060200151886107dd91906139ca565b975050806107ea906138ac565b9050610622565b506020810195909552509295945050505050565b61080d612c1e565b6000826001600160a01b031663182df0f56040518163ffffffff1660e01b8152600401602060405180830381865afa15801561084d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108719190613970565b90506000836001600160a01b0316635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d79190613953565b604051638e8f294b60e01b81526001600160a01b03868116600483015291925082916000918291841690638e8f294b906024016040805180830381865afa158015610926573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094a91906139f2565b915091506000876001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa15801561098e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b29190613953565b90506000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a189190613a1e565b60ff1690506000805b600860ff821611610ade576000886001600160a01b031663e85a29608d8460ff166008811115610a5357610a53613a41565b6040518363ffffffff1660e01b8152600401610a70929190613a57565b602060405180830381865afa158015610a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab19190613a92565b610abc576000610abf565b60015b60ff9081169083161b929092179150610ad781613aad565b9050610a21565b506040518061022001604052808b6001600160a01b031681526020018981526020018b6001600160a01b031663ae9d70b06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b629190613970565b81526020018b6001600160a01b031663f8f9da286040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ba5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc99190613970565b81526020018b6001600160a01b031663173b99046040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c0c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c309190613970565b81526040516302c3bcbb60e01b81526001600160a01b038d811660048301526020909201918916906302c3bcbb90602401602060405180830381865afa158015610c7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ca29190613970565b815260405163252c221960e11b81526001600160a01b038d81166004830152602090920191891690634a58443290602401602060405180830381865afa158015610cf0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d149190613970565b81526020018b6001600160a01b03166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d7b9190613970565b81526020018b6001600160a01b0316638f840ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610dbe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de29190613970565b81526020018b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e499190613970565b81526020018b6001600160a01b0316633b1d21a26040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e8c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb09190613970565b81526020018615158152602001858152602001846001600160a01b031681526020018b6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f10573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f349190613a1e565b60ff168152602081019390935260409092015298975050505050505050565b610f5b612b9b565b604051637aee632d60e01b81526001600160a01b0383811660048301528491610fd291839190821690637aee632d90602401600060405180830381865afa158015610faa573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261020b9190810190613acc565b949350505050565b610fe2612cb6565b6040516370a0823160e01b81526001600160a01b038381166004830152600091908516906370a0823190602401602060405180830381865afa15801561102c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110509190613970565b6040516305eff7ef60e21b81526001600160a01b0385811660048301529192506000918616906317bfdfbc906024016020604051808303816000875af115801561109e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110c29190613970565b604051633af9e66960e01b81526001600160a01b038681166004830152919250600091871690633af9e669906024016020604051808303816000875af1158015611110573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111349190613970565b90506000806000886001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa158015611179573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061119d9190613953565b6040516370a0823160e01b81526001600160a01b038a81166004830152919250908216906370a0823190602401602060405180830381865afa1580156111e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061120b9190613970565b604051636eb1769f60e11b81526001600160a01b038a811660048301528b811660248301529194509082169063dd62ed3e90604401602060405180830381865afa15801561125d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112819190613970565b6040805160c0810182526001600160a01b038c168152602081019890985287019590955250506060840191909152608083015260a0820152905092915050565b60606000826001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611303573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261132b91908101906138c5565b90506000836001600160a01b03166361252fd16040518163ffffffff1660e01b8152600401600060405180830381865afa15801561136d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113959190810190613b00565b9050600081516001600160401b038111156113b2576113b2613336565b60405190808252806020026020018201604052801561140357816020015b60408051608081018252600080825260208083018290529282015260608082015282526000199092019101816113d05790505b50905060005b82518110156103ad57604080516080810182526000808252602082018190529181019190915260608082015283828151811061144757611447613880565b60209081029190910101516001600160a01b03168152835184908390811061147157611471613880565b60200260200101516001600160a01b031663f7c618c16040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114da9190613953565b6001600160a01b0316602082015283518490839081106114fc576114fc613880565b6020908102919091010151604051631627ee8960e01b81526001600160a01b038a8116600483015290911690631627ee8990602401602060405180830381865afa15801561154e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115729190613970565b81604001818152505061159f888686858151811061159257611592613880565b6020026020010151611ce7565b8160600181905250808383815181106115ba576115ba613880565b602002602001018190525050806115d0906138ac565b9050611409565b60408051808201909152600080825260208201526000826001600160a01b0316635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561162b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061164f9190613953565b90506000816001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015611691573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116b59190613953565b6040805180820182526001600160a01b03808816808352925163fc57d4df60e01b815260048101939093529293509160208301919084169063fc57d4df90602401602060405180830381865afa158015611713573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117379190613970565b9052949350505050565b80516060906000816001600160401b0381111561176057611760613336565b60405190808252806020026020018201604052801561179957816020015b611786612c1e565b81526020019060019003908161177e5790505b50905060005b828110156117f7576117c98582815181106117bc576117bc613880565b6020026020010151610805565b8282815181106117db576117db613880565b6020026020010181905250806117f0906138ac565b905061179f565b509392505050565b611807612b9b565b6000826040015190506000816001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611850573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261187891908101906138c5565b9050600061188582611741565b604086810151905163e2bb29f360e01b81526001600160a01b039182166004820152919250879160009183169063e2bb29f390602401600060405180830381865afa1580156118d8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526119009190810190613b8e565b90506000876040015190506000604051806101a001604052808a6000015181526020018a602001516001600160a01b031681526020018a604001516001600160a01b031681526020018a6060015181526020018a608001518152602001846000015181526020018460200151815260200184604001518152602001836001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119dd9190613953565b6001600160a01b03168152602001836001600160a01b031663e87554466040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4d9190613970565b8152602001836001600160a01b0316634ada90af6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ab49190613970565b8152602001836001600160a01b031663db5c65de6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611af7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b1b9190613970565b815260200195909552509298975050505050505050565b604051631e6db74760e31b81526001600160a01b038281166004830152606091849182169063f36dba3890602401600060405180830381865afa158015611b7d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610fd29190810190613c42565b6060826000816001600160401b03811115611bc257611bc2613336565b604051908082528060200260200182016040528015611bfb57816020015b611be8612cb6565b815260200190600190039081611be05790505b50905060005b828110156103ad57611c39878783818110611c1e57611c1e613880565b9050602002016020810190611c339190612d1d565b86610fda565b828281518110611c4b57611c4b613880565b602002602001018190525080611c60906138ac565b9050611c01565b6040516326b7178560e11b81526001600160a01b03838116600483015282811660248301526000918591821690634d6e2f0a90604401602060405180830381865afa158015611cba573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cde9190613953565b95945050505050565b6060600083516001600160401b03811115611d0457611d04613336565b604051908082528060200260200182016040528015611d4957816020015b6040805180820190915260008082526020820152815260200190600190039081611d225790505b50905060005b84518110156120b8576040805160608101825260008082526020820181905291810191909152846001600160a01b0316632c427b57878481518110611d9657611d96613880565b60200260200101516040518263ffffffff1660e01b8152600401611dc991906001600160a01b0391909116815260200190565b606060405180830381865afa158015611de6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e0a9190613cfb565b63ffffffff90811660408501521660208301526001600160e01b03168152611e4b604080516060810182526000808252602082018190529181019190915290565b856001600160a01b03166392a18235888581518110611e6c57611e6c613880565b60200260200101516040518263ffffffff1660e01b8152600401611e9f91906001600160a01b0391909116815260200190565b606060405180830381865afa158015611ebc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ee09190613cfb565b63ffffffff90811660408086019190915291166020808501919091526001600160e01b0390921683528051918201905287516000919081908a9087908110611f2a57611f2a613880565b60200260200101516001600160a01b031663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611f6f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f939190613970565b8152509050611fbd888581518110611fad57611fad613880565b60200260200101518885846120c1565b611fe1888581518110611fd257611fd2613880565b60200260200101518884612349565b6000612009898681518110611ff857611ff8613880565b6020026020010151898c87866125c7565b905060006120328a878151811061202257612022613880565b60200260200101518a8d876127f7565b60408051808201909152600080825260208201529091508a878151811061205b5761205b613880565b60209081029190910101516001600160a01b0316815261207b82846139ca565b60208201528751819089908990811061209657612096613880565b6020026020010181905250505050505050806120b1906138ac565b9050611d4f565b50949350505050565b604051637c05a7c560e01b81526001600160a01b03858116600483015260009190851690637c05a7c590602401602060405180830381865afa15801561210b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061212f9190613970565b6040840151909150439063ffffffff16158015906121565750836040015163ffffffff1681115b156121685750604083015163ffffffff165b600061217e82866020015163ffffffff16612a1b565b90506000811180156121905750600083115b156122f6576000612202886001600160a01b03166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa1580156121d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121fc9190613970565b86612a2e565b905060006122108386612a4c565b90506000808311612230576040518060200160405280600081525061223a565b61223a8284612a58565b9050600061226360405180602001604052808b600001516001600160e01b031681525083612a9d565b905061229e8160000151604051806040016040528060138152602001726e657720696e646578206f766572666c6f777360681b815250612ac9565b6001600160e01b03168952604080518082019091526016815275626c6f636b206e756d626572206f766572666c6f777360501b60208201526122e1908790612b05565b63ffffffff1660208a01525061234092505050565b8015612340576123348260405180604001604052806016815260200175626c6f636b206e756d626572206f766572666c6f777360501b815250612b05565b63ffffffff1660208601525b50505050505050565b604051631d31307360e21b81526001600160a01b038481166004830152600091908416906374c4c1cc90602401602060405180830381865afa158015612393573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123b79190613970565b6040830151909150439063ffffffff16158015906123de5750826040015163ffffffff1681115b156123f05750604082015163ffffffff165b600061240682856020015163ffffffff16612a1b565b90506000811180156124185750600083115b15612575576000866001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561245d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124819190613970565b9050600061248f8386612a4c565b905060008083116124af57604051806020016040528060008152506124b9565b6124b98284612a58565b905060006124e260405180602001604052808a600001516001600160e01b031681525083612a9d565b905061251d8160000151604051806040016040528060138152602001726e657720696e646578206f766572666c6f777360681b815250612ac9565b6001600160e01b03168852604080518082019091526016815275626c6f636b206e756d626572206f766572666c6f777360501b6020820152612560908790612b05565b63ffffffff166020890152506125bf92505050565b80156125bf576125b38260405180604001604052806016815260200175626c6f636b206e756d626572206f766572666c6f777360501b815250612b05565b63ffffffff1660208501525b505050505050565b604080516020808201835284516001600160e01b031682528251908101928390526336fe846560e11b9092526001600160a01b0387811660248401528581166044840152600092839181908916636dfd08ca60648301602060405180830381865afa15801561263a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061265e9190613970565b905280519091501580156126e05750866001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa1580156126ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126cf9190613d3e565b6001600160e01b0316826000015110155b1561275357866001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa158015612723573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127479190613d3e565b6001600160e01b031681525b600061275f8383612b2d565b6040516395dd919360e01b81526001600160a01b0389811660048301529192506000916127da91908c16906395dd919390602401602060405180830381865afa1580156127b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127d49190613970565b87612a2e565b905060006127e88284612b59565b9b9a5050505050505050505050565b604080516020808201835283516001600160e01b0316825282519081019283905263552c097160e01b9092526001600160a01b038681166024840152848116604484015260009283918190881663552c097160648301602060405180830381865afa15801561286a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061288e9190613970565b905280519091501580156129105750856001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa1580156128db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128ff9190613d3e565b6001600160e01b0316826000015110155b1561298357856001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa158015612953573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129779190613d3e565b6001600160e01b031681525b600061298f8383612b2d565b6040516370a0823160e01b81526001600160a01b0388811660048301529192506000918a16906370a0823190602401602060405180830381865afa1580156129db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129ff9190613970565b90506000612a0d8284612b59565b9a9950505050505050505050565b6000612a278284613d59565b9392505050565b6000612a27612a4584670de0b6b3a7640000612a4c565b8351612b83565b6000612a278284613989565b6040805160208101909152600081526040518060200160405280612a94612a8e866ec097ce7bc90715b34b9f1000000000612a4c565b85612b83565b90529392505050565b6040805160208101909152600081526040518060200160405280612a9485600001518560000151612b8f565b6000816001600160e01b03841115612afd5760405162461bcd60e51b8152600401612af49190613d70565b60405180910390fd5b509192915050565b60008163ffffffff841115612afd5760405162461bcd60e51b8152600401612af49190613d70565b6040805160208101909152600081526040518060200160405280612a9485600001518560000151612a1b565b60006ec097ce7bc90715b34b9f1000000000612b79848460000151612a4c565b612a2791906139a8565b6000612a2782846139a8565b6000612a2782846139ca565b604051806101a001604052806060815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160608152602001606081526020016060815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001606081525090565b60405180610220016040528060006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581526020016000815260200160006001600160a01b031681526020016000815260200160008152602001600081525090565b6040518060c0016040528060006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b0381168114612d0a57600080fd5b50565b8035612d1881612cf5565b919050565b600060208284031215612d2f57600080fd5b8135612a2781612cf5565b60005b83811015612d55578181015183820152602001612d3d565b83811115612d64576000848401525b50505050565b60008151808452612d82816020860160208601612d3a565b601f01601f19169290920160200192915050565b80516001600160a01b031682526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c083015260e081015160e083015261010080820151818401525061012080820151818401525061014080820151818401525061016080820151612e218285018215159052565b505061018081810151908301526101a0808201516001600160a01b0316908301526101c080820151908301526101e0808201519083015261020090810151910152565b600081518084526020808501945080840160005b83811015612e9f57612e8b878351612d96565b610220969096019590820190600101612e78565b509495945050505050565b60006101a08251818552612ec082860182612d6a565b9150506020830151612edd60208601826001600160a01b03169052565b506040830151612ef860408601826001600160a01b03169052565b50606083015160608501526080830151608085015260a083015184820360a0860152612f248282612d6a565b91505060c083015184820360c0860152612f3e8282612d6a565b91505060e083015184820360e0860152612f588282612d6a565b91505061010080840151612f76828701826001600160a01b03169052565b50506101208381015190850152610140808401519085015261016080840151908501526101808084015185830382870152612fb18382612e64565b9695505050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561301057603f19888603018452612ffe858351612eaa565b94509285019290850190600101612fe2565b5092979650505050505050565b60008083601f84011261302f57600080fd5b5081356001600160401b0381111561304657600080fd5b6020830191508360208260051b850101111561306157600080fd5b9250929050565b6000806020838503121561307b57600080fd5b82356001600160401b0381111561309157600080fd5b61309d8582860161301d565b90969095509350505050565b602080825282518282018190526000919060409081850190868401855b828110156130fc576130ec84835180516001600160a01b03168252602090810151910152565b92840192908501906001016130c6565b5091979650505050505050565b602080825282516001600160a01b03168282015282810151604080840191909152808401516060808501528051608085018190526000939291830191849160a08701905b808410156131875761317382865180516001600160a01b03168252602090810151910152565b93850193600193909301929082019061314d565b50979650505050505050565b61022081016104848284612d96565b600080604083850312156131b557600080fd5b82356131c081612cf5565b915060208301356131d081612cf5565b809150509250929050565b602081526000612a276020830184612eaa565b80516001600160a01b031682526020808201519083015260408082015190830152606080820151908301526080808201519083015260a090810151910152565b60c0810161048482846131ee565b60006020808301818452808551808352604092508286019150828160051b8701018488016000805b8481101561330757898403603f19018652825180516001600160a01b03908116865289820151168986015287810151888601526060908101516080918601829052805191860182905289019060a086019084905b808210156132f2576132de83855180516001600160a01b03168252602090810151910152565b928b0192918a0191600191909101906132b8565b50509689019694505091870191600101613264565b50919998505050505050505050565b81516001600160a01b031681526020808301519082015260408101610484565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b038111828210171561336e5761336e613336565b60405290565b604051606081016001600160401b038111828210171561336e5761336e613336565b604051601f8201601f191681016001600160401b03811182821017156133be576133be613336565b604052919050565b60006001600160401b038211156133df576133df613336565b5060051b60200190565b600060208083850312156133fc57600080fd5b82356001600160401b0381111561341257600080fd5b8301601f8101851361342357600080fd5b8035613436613431826133c6565b613396565b81815260059190911b8201830190838101908783111561345557600080fd5b928401925b8284101561347c57833561346d81612cf5565b8252928401929084019061345a565b979650505050505050565b6020808252825182820181905260009190848201906040850190845b818110156134ca576134b6838551612d96565b9284019261022092909201916001016134a3565b50909695505050505050565b60006001600160401b038211156134ef576134ef613336565b50601f01601f191660200190565b6000806040838503121561351057600080fd5b823561351b81612cf5565b91506020838101356001600160401b038082111561353857600080fd5b9085019060a0828803121561354c57600080fd5b61355461334c565b82358281111561356357600080fd5b83019150601f8201881361357657600080fd5b8135613584613431826134d6565b818152898683860101111561359857600080fd5b8186850187830137600086838301015280835250506135b8848401612d0d565b848201526135c860408401612d0d565b60408201526060830135606082015260808301356080820152809450505050509250929050565b6020808252825182820181905260009190848201906040850190845b818110156134ca5783516001600160a01b03168352928401929184019160010161360b565b60008060006040848603121561364557600080fd5b83356001600160401b0381111561365b57600080fd5b6136678682870161301d565b909450925050602084013561367b81612cf5565b809150509250925092565b6020808252825182820181905260009190848201906040850190845b818110156134ca576136b58385516131ee565b9284019260c092909201916001016136a2565b6000806000606084860312156136dd57600080fd5b83356136e881612cf5565b925060208401356136f881612cf5565b9150604084013561367b81612cf5565b600082601f83011261371957600080fd5b8151613727613431826134d6565b81815284602083860101111561373c57600080fd5b610fd2826020830160208701612d3a565b600060a0828403121561375f57600080fd5b61376761334c565b905081516001600160401b0381111561377f57600080fd5b61378b84828501613708565b825250602082015161379c81612cf5565b602082015260408201516137af81612cf5565b80604083015250606082015160608201526080820151608082015292915050565b600060208083850312156137e357600080fd5b82516001600160401b03808211156137fa57600080fd5b818501915085601f83011261380e57600080fd5b815161381c613431826133c6565b81815260059190911b8301840190848101908883111561383b57600080fd5b8585015b83811015613873578051858111156138575760008081fd5b6138658b89838a010161374d565b84525091860191860161383f565b5098975050505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016138be576138be613896565b5060010190565b600060208083850312156138d857600080fd5b82516001600160401b038111156138ee57600080fd5b8301601f810185136138ff57600080fd5b805161390d613431826133c6565b81815260059190911b8201830190838101908783111561392c57600080fd5b928401925b8284101561347c57835161394481612cf5565b82529284019290840190613931565b60006020828403121561396557600080fd5b8151612a2781612cf5565b60006020828403121561398257600080fd5b5051919050565b60008160001904831182151516156139a3576139a3613896565b500290565b6000826139c557634e487b7160e01b600052601260045260246000fd5b500490565b600082198211156139dd576139dd613896565b500190565b80518015158114612d1857600080fd5b60008060408385031215613a0557600080fd5b613a0e836139e2565b9150602083015190509250929050565b600060208284031215613a3057600080fd5b815160ff81168114612a2757600080fd5b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03831681526040810160098310613a8557634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b600060208284031215613aa457600080fd5b612a27826139e2565b600060ff821660ff8103613ac357613ac3613896565b60010192915050565b600060208284031215613ade57600080fd5b81516001600160401b03811115613af457600080fd5b610fd28482850161374d565b60006020808385031215613b1357600080fd5b82516001600160401b03811115613b2957600080fd5b8301601f81018513613b3a57600080fd5b8051613b48613431826133c6565b81815260059190911b82018301908381019087831115613b6757600080fd5b928401925b8284101561347c578351613b7f81612cf5565b82529284019290840190613b6c565b600060208284031215613ba057600080fd5b81516001600160401b0380821115613bb757600080fd5b9083019060608286031215613bcb57600080fd5b613bd3613374565b825182811115613be257600080fd5b613bee87828601613708565b825250602083015182811115613c0357600080fd5b613c0f87828601613708565b602083015250604083015182811115613c2757600080fd5b613c3387828601613708565b60408301525095945050505050565b60006020808385031215613c5557600080fd5b82516001600160401b03811115613c6b57600080fd5b8301601f81018513613c7c57600080fd5b8051613c8a613431826133c6565b81815260059190911b82018301908381019087831115613ca957600080fd5b928401925b8284101561347c578351613cc181612cf5565b82529284019290840190613cae565b80516001600160e01b0381168114612d1857600080fd5b805163ffffffff81168114612d1857600080fd5b600080600060608486031215613d1057600080fd5b613d1984613cd0565b9250613d2760208501613ce7565b9150613d3560408501613ce7565b90509250925092565b600060208284031215613d5057600080fd5b612a2782613cd0565b600082821015613d6b57613d6b613896565b500390565b602081526000612a276020830184612d6a56fea264697066735822122066df8361f3c036ece738b0f64c16a2f743243aca3c631ed5ff2c847284b1826464736f6c634300080d0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100cf5760003560e01c80637a27db571161008c578063cfa5ff6911610066578063cfa5ff69146101fd578063d77ebf9614610210578063dc7634c314610230578063ffa71f6d1461025057600080fd5b80637a27db571461019d5780637e9ab2cb146101bd578063ad0d9822146101dd57600080fd5b8063345954dc146100d457806334c16ef9146100fd5780633e3e399c1461011d5780634399f7791461013d57806347d86a811461015d57806355e3a7d91461017d575b600080fd5b6100e76100e2366004612d1d565b61027b565b6040516100f49190612fbb565b60405180910390f35b61011061010b366004613068565b6103b7565b6040516100f491906130a9565b61013061012b366004612d1d565b61048a565b6040516100f49190613109565b61015061014b366004612d1d565b610805565b6040516100f49190613193565b61017061016b3660046131a2565b610f53565b6040516100f491906131db565b61019061018b3660046131a2565b610fda565b6040516100f4919061322e565b6101b06101ab3660046131a2565b6112c1565b6040516100f4919061323c565b6101d06101cb366004612d1d565b6115d7565b6040516100f49190613316565b6101f06101eb3660046133e9565b611741565b6040516100f49190613487565b61017061020b3660046134fd565b6117ff565b61022361021e3660046131a2565b611b32565b6040516100f491906135ef565b61024361023e366004613630565b611ba5565b6040516100f49190613686565b61026361025e3660046136c8565b611c67565b6040516001600160a01b0390911681526020016100f4565b606060008290506000816001600160a01b031663d88ff1f46040518163ffffffff1660e01b8152600401600060405180830381865afa1580156102c2573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526102ea91908101906137d0565b80519091506000816001600160401b0381111561030957610309613336565b60405190808252806020026020018201604052801561034257816020015b61032f612b9b565b8152602001906001900390816103275790505b50905060005b828110156103ad57600084828151811061036457610364613880565b60200260200101519050600061037a89836117ff565b90508084848151811061038f5761038f613880565b60200260200101819052505050806103a6906138ac565b9050610348565b5095945050505050565b6060816000816001600160401b038111156103d4576103d4613336565b60405190808252806020026020018201604052801561041957816020015b60408051808201909152600080825260208201528152602001906001900390816103f25790505b50905060005b8281101561047f5761045186868381811061043c5761043c613880565b90506020020160208101906101cb9190612d1d565b82828151811061046357610463613880565b602002602001018190525080610478906138ac565b905061041f565b509150505b92915050565b604080516060808201835260008083526020830152918101919091526000808390506000816001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa1580156104ec573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261051491908101906138c5565b90506000826001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610556573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061057a9190613953565b9050600082516001600160401b0381111561059757610597613336565b6040519080825280602002602001820160405280156105dc57816020015b60408051808201909152600080825260208201528152602001906001900390816105b55790505b50905061060c604051806060016040528060006001600160a01b0316815260200160008152602001606081525090565b6001600160a01b03881681526040810182905260005b84518110156107f157604080518082019091526000808252602082015285828151811061065157610651613880565b602002602001015181600001906001600160a01b031690816001600160a01b031681525050670de0b6b3a7640000856001600160a01b031663fc57d4df8885815181106106a0576106a0613880565b60200260200101516040518263ffffffff1660e01b81526004016106d391906001600160a01b0391909116815260200190565b602060405180830381865afa1580156106f0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107149190613970565b87848151811061072657610726613880565b60200260200101516001600160a01b031663bbcac5576040518163ffffffff1660e01b8152600401602060405180830381865afa15801561076b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061078f9190613970565b6107999190613989565b6107a391906139a8565b602082015260408301518051829190849081106107c2576107c2613880565b60200260200101819052508060200151886107dd91906139ca565b975050806107ea906138ac565b9050610622565b506020810195909552509295945050505050565b61080d612c1e565b6000826001600160a01b031663182df0f56040518163ffffffff1660e01b8152600401602060405180830381865afa15801561084d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108719190613970565b90506000836001600160a01b0316635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156108b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108d79190613953565b604051638e8f294b60e01b81526001600160a01b03868116600483015291925082916000918291841690638e8f294b906024016040805180830381865afa158015610926573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061094a91906139f2565b915091506000876001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa15801561098e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b29190613953565b90506000816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156109f4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a189190613a1e565b60ff1690506000805b600860ff821611610ade576000886001600160a01b031663e85a29608d8460ff166008811115610a5357610a53613a41565b6040518363ffffffff1660e01b8152600401610a70929190613a57565b602060405180830381865afa158015610a8d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ab19190613a92565b610abc576000610abf565b60015b60ff9081169083161b929092179150610ad781613aad565b9050610a21565b506040518061022001604052808b6001600160a01b031681526020018981526020018b6001600160a01b031663ae9d70b06040518163ffffffff1660e01b8152600401602060405180830381865afa158015610b3e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b629190613970565b81526020018b6001600160a01b031663f8f9da286040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ba5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bc99190613970565b81526020018b6001600160a01b031663173b99046040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c0c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c309190613970565b81526040516302c3bcbb60e01b81526001600160a01b038d811660048301526020909201918916906302c3bcbb90602401602060405180830381865afa158015610c7e573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ca29190613970565b815260405163252c221960e11b81526001600160a01b038d81166004830152602090920191891690634a58443290602401602060405180830381865afa158015610cf0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d149190613970565b81526020018b6001600160a01b03166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa158015610d57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610d7b9190613970565b81526020018b6001600160a01b0316638f840ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610dbe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610de29190613970565b81526020018b6001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e499190613970565b81526020018b6001600160a01b0316633b1d21a26040518163ffffffff1660e01b8152600401602060405180830381865afa158015610e8c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610eb09190613970565b81526020018615158152602001858152602001846001600160a01b031681526020018b6001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f10573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f349190613a1e565b60ff168152602081019390935260409092015298975050505050505050565b610f5b612b9b565b604051637aee632d60e01b81526001600160a01b0383811660048301528491610fd291839190821690637aee632d90602401600060405180830381865afa158015610faa573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261020b9190810190613acc565b949350505050565b610fe2612cb6565b6040516370a0823160e01b81526001600160a01b038381166004830152600091908516906370a0823190602401602060405180830381865afa15801561102c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110509190613970565b6040516305eff7ef60e21b81526001600160a01b0385811660048301529192506000918616906317bfdfbc906024016020604051808303816000875af115801561109e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110c29190613970565b604051633af9e66960e01b81526001600160a01b038681166004830152919250600091871690633af9e669906024016020604051808303816000875af1158015611110573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111349190613970565b90506000806000886001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa158015611179573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061119d9190613953565b6040516370a0823160e01b81526001600160a01b038a81166004830152919250908216906370a0823190602401602060405180830381865afa1580156111e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061120b9190613970565b604051636eb1769f60e11b81526001600160a01b038a811660048301528b811660248301529194509082169063dd62ed3e90604401602060405180830381865afa15801561125d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112819190613970565b6040805160c0810182526001600160a01b038c168152602081019890985287019590955250506060840191909152608083015260a0820152905092915050565b60606000826001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611303573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261132b91908101906138c5565b90506000836001600160a01b03166361252fd16040518163ffffffff1660e01b8152600401600060405180830381865afa15801561136d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526113959190810190613b00565b9050600081516001600160401b038111156113b2576113b2613336565b60405190808252806020026020018201604052801561140357816020015b60408051608081018252600080825260208083018290529282015260608082015282526000199092019101816113d05790505b50905060005b82518110156103ad57604080516080810182526000808252602082018190529181019190915260608082015283828151811061144757611447613880565b60209081029190910101516001600160a01b03168152835184908390811061147157611471613880565b60200260200101516001600160a01b031663f7c618c16040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114da9190613953565b6001600160a01b0316602082015283518490839081106114fc576114fc613880565b6020908102919091010151604051631627ee8960e01b81526001600160a01b038a8116600483015290911690631627ee8990602401602060405180830381865afa15801561154e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115729190613970565b81604001818152505061159f888686858151811061159257611592613880565b6020026020010151611ce7565b8160600181905250808383815181106115ba576115ba613880565b602002602001018190525050806115d0906138ac565b9050611409565b60408051808201909152600080825260208201526000826001600160a01b0316635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561162b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061164f9190613953565b90506000816001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa158015611691573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116b59190613953565b6040805180820182526001600160a01b03808816808352925163fc57d4df60e01b815260048101939093529293509160208301919084169063fc57d4df90602401602060405180830381865afa158015611713573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117379190613970565b9052949350505050565b80516060906000816001600160401b0381111561176057611760613336565b60405190808252806020026020018201604052801561179957816020015b611786612c1e565b81526020019060019003908161177e5790505b50905060005b828110156117f7576117c98582815181106117bc576117bc613880565b6020026020010151610805565b8282815181106117db576117db613880565b6020026020010181905250806117f0906138ac565b905061179f565b509392505050565b611807612b9b565b6000826040015190506000816001600160a01b031663b0772d0b6040518163ffffffff1660e01b8152600401600060405180830381865afa158015611850573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261187891908101906138c5565b9050600061188582611741565b604086810151905163e2bb29f360e01b81526001600160a01b039182166004820152919250879160009183169063e2bb29f390602401600060405180830381865afa1580156118d8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526119009190810190613b8e565b90506000876040015190506000604051806101a001604052808a6000015181526020018a602001516001600160a01b031681526020018a604001516001600160a01b031681526020018a6060015181526020018a608001518152602001846000015181526020018460200151815260200184604001518152602001836001600160a01b0316637dc0d1d06040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119dd9190613953565b6001600160a01b03168152602001836001600160a01b031663e87554466040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a29573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4d9190613970565b8152602001836001600160a01b0316634ada90af6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611a90573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ab49190613970565b8152602001836001600160a01b031663db5c65de6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611af7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b1b9190613970565b815260200195909552509298975050505050505050565b604051631e6db74760e31b81526001600160a01b038281166004830152606091849182169063f36dba3890602401600060405180830381865afa158015611b7d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610fd29190810190613c42565b6060826000816001600160401b03811115611bc257611bc2613336565b604051908082528060200260200182016040528015611bfb57816020015b611be8612cb6565b815260200190600190039081611be05790505b50905060005b828110156103ad57611c39878783818110611c1e57611c1e613880565b9050602002016020810190611c339190612d1d565b86610fda565b828281518110611c4b57611c4b613880565b602002602001018190525080611c60906138ac565b9050611c01565b6040516326b7178560e11b81526001600160a01b03838116600483015282811660248301526000918591821690634d6e2f0a90604401602060405180830381865afa158015611cba573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cde9190613953565b95945050505050565b6060600083516001600160401b03811115611d0457611d04613336565b604051908082528060200260200182016040528015611d4957816020015b6040805180820190915260008082526020820152815260200190600190039081611d225790505b50905060005b84518110156120b8576040805160608101825260008082526020820181905291810191909152846001600160a01b0316632c427b57878481518110611d9657611d96613880565b60200260200101516040518263ffffffff1660e01b8152600401611dc991906001600160a01b0391909116815260200190565b606060405180830381865afa158015611de6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e0a9190613cfb565b63ffffffff90811660408501521660208301526001600160e01b03168152611e4b604080516060810182526000808252602082018190529181019190915290565b856001600160a01b03166392a18235888581518110611e6c57611e6c613880565b60200260200101516040518263ffffffff1660e01b8152600401611e9f91906001600160a01b0391909116815260200190565b606060405180830381865afa158015611ebc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ee09190613cfb565b63ffffffff90811660408086019190915291166020808501919091526001600160e01b0390921683528051918201905287516000919081908a9087908110611f2a57611f2a613880565b60200260200101516001600160a01b031663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611f6f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f939190613970565b8152509050611fbd888581518110611fad57611fad613880565b60200260200101518885846120c1565b611fe1888581518110611fd257611fd2613880565b60200260200101518884612349565b6000612009898681518110611ff857611ff8613880565b6020026020010151898c87866125c7565b905060006120328a878151811061202257612022613880565b60200260200101518a8d876127f7565b60408051808201909152600080825260208201529091508a878151811061205b5761205b613880565b60209081029190910101516001600160a01b0316815261207b82846139ca565b60208201528751819089908990811061209657612096613880565b6020026020010181905250505050505050806120b1906138ac565b9050611d4f565b50949350505050565b604051637c05a7c560e01b81526001600160a01b03858116600483015260009190851690637c05a7c590602401602060405180830381865afa15801561210b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061212f9190613970565b6040840151909150439063ffffffff16158015906121565750836040015163ffffffff1681115b156121685750604083015163ffffffff165b600061217e82866020015163ffffffff16612a1b565b90506000811180156121905750600083115b156122f6576000612202886001600160a01b03166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa1580156121d8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121fc9190613970565b86612a2e565b905060006122108386612a4c565b90506000808311612230576040518060200160405280600081525061223a565b61223a8284612a58565b9050600061226360405180602001604052808b600001516001600160e01b031681525083612a9d565b905061229e8160000151604051806040016040528060138152602001726e657720696e646578206f766572666c6f777360681b815250612ac9565b6001600160e01b03168952604080518082019091526016815275626c6f636b206e756d626572206f766572666c6f777360501b60208201526122e1908790612b05565b63ffffffff1660208a01525061234092505050565b8015612340576123348260405180604001604052806016815260200175626c6f636b206e756d626572206f766572666c6f777360501b815250612b05565b63ffffffff1660208601525b50505050505050565b604051631d31307360e21b81526001600160a01b038481166004830152600091908416906374c4c1cc90602401602060405180830381865afa158015612393573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123b79190613970565b6040830151909150439063ffffffff16158015906123de5750826040015163ffffffff1681115b156123f05750604082015163ffffffff165b600061240682856020015163ffffffff16612a1b565b90506000811180156124185750600083115b15612575576000866001600160a01b03166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561245d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124819190613970565b9050600061248f8386612a4c565b905060008083116124af57604051806020016040528060008152506124b9565b6124b98284612a58565b905060006124e260405180602001604052808a600001516001600160e01b031681525083612a9d565b905061251d8160000151604051806040016040528060138152602001726e657720696e646578206f766572666c6f777360681b815250612ac9565b6001600160e01b03168852604080518082019091526016815275626c6f636b206e756d626572206f766572666c6f777360501b6020820152612560908790612b05565b63ffffffff166020890152506125bf92505050565b80156125bf576125b38260405180604001604052806016815260200175626c6f636b206e756d626572206f766572666c6f777360501b815250612b05565b63ffffffff1660208501525b505050505050565b604080516020808201835284516001600160e01b031682528251908101928390526336fe846560e11b9092526001600160a01b0387811660248401528581166044840152600092839181908916636dfd08ca60648301602060405180830381865afa15801561263a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061265e9190613970565b905280519091501580156126e05750866001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa1580156126ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126cf9190613d3e565b6001600160e01b0316826000015110155b1561275357866001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa158015612723573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127479190613d3e565b6001600160e01b031681525b600061275f8383612b2d565b6040516395dd919360e01b81526001600160a01b0389811660048301529192506000916127da91908c16906395dd919390602401602060405180830381865afa1580156127b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906127d49190613970565b87612a2e565b905060006127e88284612b59565b9b9a5050505050505050505050565b604080516020808201835283516001600160e01b0316825282519081019283905263552c097160e01b9092526001600160a01b038681166024840152848116604484015260009283918190881663552c097160648301602060405180830381865afa15801561286a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061288e9190613970565b905280519091501580156129105750856001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa1580156128db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128ff9190613d3e565b6001600160e01b0316826000015110155b1561298357856001600160a01b031663160c3a036040518163ffffffff1660e01b8152600401602060405180830381865afa158015612953573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129779190613d3e565b6001600160e01b031681525b600061298f8383612b2d565b6040516370a0823160e01b81526001600160a01b0388811660048301529192506000918a16906370a0823190602401602060405180830381865afa1580156129db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129ff9190613970565b90506000612a0d8284612b59565b9a9950505050505050505050565b6000612a278284613d59565b9392505050565b6000612a27612a4584670de0b6b3a7640000612a4c565b8351612b83565b6000612a278284613989565b6040805160208101909152600081526040518060200160405280612a94612a8e866ec097ce7bc90715b34b9f1000000000612a4c565b85612b83565b90529392505050565b6040805160208101909152600081526040518060200160405280612a9485600001518560000151612b8f565b6000816001600160e01b03841115612afd5760405162461bcd60e51b8152600401612af49190613d70565b60405180910390fd5b509192915050565b60008163ffffffff841115612afd5760405162461bcd60e51b8152600401612af49190613d70565b6040805160208101909152600081526040518060200160405280612a9485600001518560000151612a1b565b60006ec097ce7bc90715b34b9f1000000000612b79848460000151612a4c565b612a2791906139a8565b6000612a2782846139a8565b6000612a2782846139ca565b604051806101a001604052806060815260200160006001600160a01b0316815260200160006001600160a01b03168152602001600081526020016000815260200160608152602001606081526020016060815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001606081525090565b60405180610220016040528060006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000815260200160008152602001600081526020016000151581526020016000815260200160006001600160a01b031681526020016000815260200160008152602001600081525090565b6040518060c0016040528060006001600160a01b0316815260200160008152602001600081526020016000815260200160008152602001600081525090565b6001600160a01b0381168114612d0a57600080fd5b50565b8035612d1881612cf5565b919050565b600060208284031215612d2f57600080fd5b8135612a2781612cf5565b60005b83811015612d55578181015183820152602001612d3d565b83811115612d64576000848401525b50505050565b60008151808452612d82816020860160208601612d3a565b601f01601f19169290920160200192915050565b80516001600160a01b031682526020810151602083015260408101516040830152606081015160608301526080810151608083015260a081015160a083015260c081015160c083015260e081015160e083015261010080820151818401525061012080820151818401525061014080820151818401525061016080820151612e218285018215159052565b505061018081810151908301526101a0808201516001600160a01b0316908301526101c080820151908301526101e0808201519083015261020090810151910152565b600081518084526020808501945080840160005b83811015612e9f57612e8b878351612d96565b610220969096019590820190600101612e78565b509495945050505050565b60006101a08251818552612ec082860182612d6a565b9150506020830151612edd60208601826001600160a01b03169052565b506040830151612ef860408601826001600160a01b03169052565b50606083015160608501526080830151608085015260a083015184820360a0860152612f248282612d6a565b91505060c083015184820360c0860152612f3e8282612d6a565b91505060e083015184820360e0860152612f588282612d6a565b91505061010080840151612f76828701826001600160a01b03169052565b50506101208381015190850152610140808401519085015261016080840151908501526101808084015185830382870152612fb18382612e64565b9695505050505050565b6000602080830181845280855180835260408601915060408160051b870101925083870160005b8281101561301057603f19888603018452612ffe858351612eaa565b94509285019290850190600101612fe2565b5092979650505050505050565b60008083601f84011261302f57600080fd5b5081356001600160401b0381111561304657600080fd5b6020830191508360208260051b850101111561306157600080fd5b9250929050565b6000806020838503121561307b57600080fd5b82356001600160401b0381111561309157600080fd5b61309d8582860161301d565b90969095509350505050565b602080825282518282018190526000919060409081850190868401855b828110156130fc576130ec84835180516001600160a01b03168252602090810151910152565b92840192908501906001016130c6565b5091979650505050505050565b602080825282516001600160a01b03168282015282810151604080840191909152808401516060808501528051608085018190526000939291830191849160a08701905b808410156131875761317382865180516001600160a01b03168252602090810151910152565b93850193600193909301929082019061314d565b50979650505050505050565b61022081016104848284612d96565b600080604083850312156131b557600080fd5b82356131c081612cf5565b915060208301356131d081612cf5565b809150509250929050565b602081526000612a276020830184612eaa565b80516001600160a01b031682526020808201519083015260408082015190830152606080820151908301526080808201519083015260a090810151910152565b60c0810161048482846131ee565b60006020808301818452808551808352604092508286019150828160051b8701018488016000805b8481101561330757898403603f19018652825180516001600160a01b03908116865289820151168986015287810151888601526060908101516080918601829052805191860182905289019060a086019084905b808210156132f2576132de83855180516001600160a01b03168252602090810151910152565b928b0192918a0191600191909101906132b8565b50509689019694505091870191600101613264565b50919998505050505050505050565b81516001600160a01b031681526020808301519082015260408101610484565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b038111828210171561336e5761336e613336565b60405290565b604051606081016001600160401b038111828210171561336e5761336e613336565b604051601f8201601f191681016001600160401b03811182821017156133be576133be613336565b604052919050565b60006001600160401b038211156133df576133df613336565b5060051b60200190565b600060208083850312156133fc57600080fd5b82356001600160401b0381111561341257600080fd5b8301601f8101851361342357600080fd5b8035613436613431826133c6565b613396565b81815260059190911b8201830190838101908783111561345557600080fd5b928401925b8284101561347c57833561346d81612cf5565b8252928401929084019061345a565b979650505050505050565b6020808252825182820181905260009190848201906040850190845b818110156134ca576134b6838551612d96565b9284019261022092909201916001016134a3565b50909695505050505050565b60006001600160401b038211156134ef576134ef613336565b50601f01601f191660200190565b6000806040838503121561351057600080fd5b823561351b81612cf5565b91506020838101356001600160401b038082111561353857600080fd5b9085019060a0828803121561354c57600080fd5b61355461334c565b82358281111561356357600080fd5b83019150601f8201881361357657600080fd5b8135613584613431826134d6565b818152898683860101111561359857600080fd5b8186850187830137600086838301015280835250506135b8848401612d0d565b848201526135c860408401612d0d565b60408201526060830135606082015260808301356080820152809450505050509250929050565b6020808252825182820181905260009190848201906040850190845b818110156134ca5783516001600160a01b03168352928401929184019160010161360b565b60008060006040848603121561364557600080fd5b83356001600160401b0381111561365b57600080fd5b6136678682870161301d565b909450925050602084013561367b81612cf5565b809150509250925092565b6020808252825182820181905260009190848201906040850190845b818110156134ca576136b58385516131ee565b9284019260c092909201916001016136a2565b6000806000606084860312156136dd57600080fd5b83356136e881612cf5565b925060208401356136f881612cf5565b9150604084013561367b81612cf5565b600082601f83011261371957600080fd5b8151613727613431826134d6565b81815284602083860101111561373c57600080fd5b610fd2826020830160208701612d3a565b600060a0828403121561375f57600080fd5b61376761334c565b905081516001600160401b0381111561377f57600080fd5b61378b84828501613708565b825250602082015161379c81612cf5565b602082015260408201516137af81612cf5565b80604083015250606082015160608201526080820151608082015292915050565b600060208083850312156137e357600080fd5b82516001600160401b03808211156137fa57600080fd5b818501915085601f83011261380e57600080fd5b815161381c613431826133c6565b81815260059190911b8301840190848101908883111561383b57600080fd5b8585015b83811015613873578051858111156138575760008081fd5b6138658b89838a010161374d565b84525091860191860161383f565b5098975050505050505050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b6000600182016138be576138be613896565b5060010190565b600060208083850312156138d857600080fd5b82516001600160401b038111156138ee57600080fd5b8301601f810185136138ff57600080fd5b805161390d613431826133c6565b81815260059190911b8201830190838101908783111561392c57600080fd5b928401925b8284101561347c57835161394481612cf5565b82529284019290840190613931565b60006020828403121561396557600080fd5b8151612a2781612cf5565b60006020828403121561398257600080fd5b5051919050565b60008160001904831182151516156139a3576139a3613896565b500290565b6000826139c557634e487b7160e01b600052601260045260246000fd5b500490565b600082198211156139dd576139dd613896565b500190565b80518015158114612d1857600080fd5b60008060408385031215613a0557600080fd5b613a0e836139e2565b9150602083015190509250929050565b600060208284031215613a3057600080fd5b815160ff81168114612a2757600080fd5b634e487b7160e01b600052602160045260246000fd5b6001600160a01b03831681526040810160098310613a8557634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b600060208284031215613aa457600080fd5b612a27826139e2565b600060ff821660ff8103613ac357613ac3613896565b60010192915050565b600060208284031215613ade57600080fd5b81516001600160401b03811115613af457600080fd5b610fd28482850161374d565b60006020808385031215613b1357600080fd5b82516001600160401b03811115613b2957600080fd5b8301601f81018513613b3a57600080fd5b8051613b48613431826133c6565b81815260059190911b82018301908381019087831115613b6757600080fd5b928401925b8284101561347c578351613b7f81612cf5565b82529284019290840190613b6c565b600060208284031215613ba057600080fd5b81516001600160401b0380821115613bb757600080fd5b9083019060608286031215613bcb57600080fd5b613bd3613374565b825182811115613be257600080fd5b613bee87828601613708565b825250602083015182811115613c0357600080fd5b613c0f87828601613708565b602083015250604083015182811115613c2757600080fd5b613c3387828601613708565b60408301525095945050505050565b60006020808385031215613c5557600080fd5b82516001600160401b03811115613c6b57600080fd5b8301601f81018513613c7c57600080fd5b8051613c8a613431826133c6565b81815260059190911b82018301908381019087831115613ca957600080fd5b928401925b8284101561347c578351613cc181612cf5565b82529284019290840190613cae565b80516001600160e01b0381168114612d1857600080fd5b805163ffffffff81168114612d1857600080fd5b600080600060608486031215613d1057600080fd5b613d1984613cd0565b9250613d2760208501613ce7565b9150613d3560408501613ce7565b90509250925092565b600060208284031215613d5057600080fd5b612a2782613cd0565b600082821015613d6b57613d6b613896565b500390565b602081526000612a276020830184612d6a56fea264697066735822122066df8361f3c036ece738b0f64c16a2f743243aca3c631ed5ff2c847284b1826464736f6c634300080d0033",
  "devdoc": {
    "author": "LendLand",
    "kind": "dev",
    "methods": {
      "getAllPools(address)": {
        "details": "This function is not designed to be called in a transaction: it is too gas-intensive",
        "params": {
          "poolRegistryAddress": "The address of the PoolRegistry contract"
        },
        "returns": {
          "_0": "Arrays of all LendLand pools' data"
        }
      },
      "getLeTokenForAsset(address,address,address)": {
        "params": {
          "asset": "The underlyingAsset of LeToken",
          "comptroller": "The pool comptroller",
          "poolRegistryAddress": "The address of the PoolRegistry contract"
        },
        "returns": {
          "_0": "Address of the leToken"
        }
      },
      "getPendingRewards(address,address)": {
        "params": {
          "account": "The user account.",
          "comptrollerAddress": "address"
        },
        "returns": {
          "_0": "Pending rewards array"
        }
      },
      "getPoolBadDebt(address)": {
        "params": {
          "comptrollerAddress": "Address of the comptroller"
        },
        "returns": {
          "_0": "badDebtSummary A struct with comptroller address, total bad debut denominated in usd, and   a break down of bad debt by market"
        }
      },
      "getPoolByComptroller(address,address)": {
        "params": {
          "comptroller": "The Comptroller implementation address",
          "poolRegistryAddress": "The address of the PoolRegistry contract"
        },
        "returns": {
          "_0": "PoolData structure containing the details of the pool"
        }
      },
      "getPoolDataFromLendLandPool(address,(string,address,address,uint256,uint256))": {
        "params": {
          "lendlandPool": "The LendLandPool Object from PoolRegistry",
          "poolRegistryAddress": "Address of the PoolRegistry"
        },
        "returns": {
          "_0": "Enriched PoolData"
        }
      },
      "getPoolsSupportedByAsset(address,address)": {
        "params": {
          "asset": "The underlying asset of leToken",
          "poolRegistryAddress": "The address of the PoolRegistry contract"
        },
        "returns": {
          "_0": "A list of Comptroller contracts"
        }
      },
      "leTokenBalances(address,address)": {
        "params": {
          "account": "The user Account",
          "leToken": "leToken address"
        },
        "returns": {
          "_0": "A struct containing the balances data"
        }
      },
      "leTokenBalancesAll(address[],address)": {
        "params": {
          "account": "The user Account",
          "leTokens": "The list of leToken addresses"
        },
        "returns": {
          "_0": "A list of structs containing balances data"
        }
      },
      "leTokenMetadata(address)": {
        "params": {
          "leToken": "The address of leToken"
        },
        "returns": {
          "_0": "LeTokenMetadata struct"
        }
      },
      "leTokenMetadataAll(address[])": {
        "params": {
          "leTokens": "The list of leToken addresses"
        },
        "returns": {
          "_0": "An array of LeTokenMetadata structs"
        }
      },
      "leTokenUnderlyingPrice(address)": {
        "params": {
          "leToken": "leToken address"
        },
        "returns": {
          "_0": "The price data for each asset"
        }
      },
      "leTokenUnderlyingPriceAll(address[])": {
        "params": {
          "leTokens": "The list of leToken addresses"
        },
        "returns": {
          "_0": "An array containing the price data for each asset"
        }
      }
    },
    "title": "PoolLens",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAllPools(address)": {
        "notice": "Queries all pools with addtional details for each of them"
      },
      "getLeTokenForAsset(address,address,address)": {
        "notice": "Returns leToken holding the specified underlying asset in the specified pool"
      },
      "getPendingRewards(address,address)": {
        "notice": "Returns the pending rewards for a user for a given pool."
      },
      "getPoolBadDebt(address)": {
        "notice": "Returns a summary of a pool's bad debt broken down by market"
      },
      "getPoolByComptroller(address,address)": {
        "notice": "Queries the details of a pool identified by Comptroller address"
      },
      "getPoolDataFromLendLandPool(address,(string,address,address,uint256,uint256))": {
        "notice": "Queries additional information for the pool"
      },
      "getPoolsSupportedByAsset(address,address)": {
        "notice": "Returns all pools that support the specified underlying asset"
      },
      "leTokenBalances(address,address)": {
        "notice": "Queries the user's supply/borrow balances in the specified leToken"
      },
      "leTokenBalancesAll(address[],address)": {
        "notice": "Queries the user's supply/borrow balances in leTokens"
      },
      "leTokenMetadata(address)": {
        "notice": "Returns the metadata of LeToken"
      },
      "leTokenMetadataAll(address[])": {
        "notice": "Returns the metadata of all LeTokens"
      },
      "leTokenUnderlyingPrice(address)": {
        "notice": "Returns the price data for the underlying asset of the specified leToken"
      },
      "leTokenUnderlyingPriceAll(address[])": {
        "notice": "Returns the price data for the underlying assets of the specified leTokens"
      }
    },
    "notice": "The `PoolLens` contract is designed to retrieve important information for each registered pool. A list of essential information for all pools within the lending protocol can be acquired through the function `getAllPools()`. Additionally, the following records can be looked up for specific pools and markets: - the leToken balance of a given user; - the pool data (oracle address, associated leToken, liquidation incentive, etc) of a pool via its associated comptroller address; - the leToken address in a pool for a given asset; - a list of all pools that support an asset; - the underlying asset price of a leToken; - the metadata (exchange/borrow/supply rate, total supply, collateral factor, etc) of any leToken.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}